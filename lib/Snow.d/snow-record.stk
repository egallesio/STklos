;;;;
;;;; snow-record.stk	-- Snow record support
;;;; 
;;;; Copyright © 2006 Erick Gallesio - I3S-CNRS/ESSI <eg@essi.fr>
;;;; 
;;;; 
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;; 
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;; 
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
;;;; USA.
;;;; 
;;;;           Author: Erick Gallesio [eg@essi.fr]
;;;;    Creation date: 21-Dec-2006 12:00 (eg)
;;;; Last file update: 21-Dec-2006 12:02 (eg)
;;;;


(define (%define-record->struct name parent slots exported?)
  (let ((pred    (string->symbol (format "~a?" name)))
	(constr  (string->symbol (format "make-~a" name)))
	(arg     (gensym))
	(val     (gensym)))
    `(begin
       ;; Build the structure
       (define ,name (make-struct-type ',name ,parent ',(map car slots)))

       ;; Build the constructor
       (define (,constr . ,arg)
	 (apply make-struct ,name ,arg))

       ;; Build the predicate
       (define (,pred ,arg)
	 (and (struct? ,arg) (struct-is-a? ,arg ,name)))

       ;; Build the slot readers
       ,@(map (lambda (x)
		`(define ,(cadr x)
		   (lambda (,arg)
		     (%fast-struct-ref ,arg ,name ',(cadr x) ,(cadddr x)))))
	      slots)
       ;; Build the slot setters
       ,@(map (lambda (x)
		`(define ,(caddr x)
		   (lambda (,arg ,val)
		     (%fast-struct-set! ,arg ,name ',(caddr x) ,(cadddr x) ,val))))
	      slots)
       ,(if exported?
	    `(export ,name ,constr ,pred
		     ,@(map cadr slots)
		     ,@(map caddr slots))
	    '(void))

       ;; Build the toplevel result
       (values (void) ',name))))


(define (%define-record* name body exported?)
  (let Loop ((body body)
	     (parent #f)
	     (fields '())
	     (offset 0))
    (cond
      ((null? body)
       (%define-record->struct name parent (reverse! fields) exported?))

      ((not (pair? body))
       (error "bad record ~S" body))

      ((keyword? (car body))
       (cond
	 ((null? (cdr body))
	     (error "value expected after keyword ~S" (car body)))
	 ((eq? (car body) parent:)
	     (Loop (cddr body) (cadr body) fields offset))
	 (else ;; ignore this keyword for STklos
	     (Loop (cddr body) parent fields offset))))

      (else
         (match-case (car body)
	   ((? symbol?)
	      (let ((fld (car body)))
		(Loop (cdr body)
		      parent
		      (cons (list fld
				  (string->symbol (format "~a-~a" name fld))
				  (string->symbol (format "~a-~a-set!" name fld))
				  offset)
			    fields)
		      (+ offset 1))))
	   (((? symbol?) (? symbol?) (? symbol?))
	      (let ((fld    (caar body))
		    (getter (cadar body))
		    (setter (cadar body)))
		(Loop (cdr body)
		      parent
		      (cons (list fld getter setter offset) fields)
		      (+ offset 1))))
	   (else
	      (error "bad record field ~S" (car body))))))))

(define-macro (define-record* name . body)
  (%define-record* name body #f))

