;;;;
;;;; c o m p i l e r . s t k                    -- STklos Compiler
;;;;
;;;; Copyright Â© 2000-2021 Erick Gallesio - I3S-CNRS/ESSI <eg@unice.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 26-Feb-2000 10:47 (eg)
;;;; Last file update: 14-Dec-2021 17:35 (eg)
;;;;

(define-module STKLOS-COMPILER
  (import SCHEME)
  (export eval
          disassemble disassemble-expr
          compiler:time-display
          compiler:gen-line-number
          compiler:warn-use-undefined
          compiler:warn-use-undefined-postpone
          compiler:show-assembly-code
          compiler:generate-signature
          compiler:inline-common-functions

          %grab-file-information
          %compiler-new-label
          <syntax>?   ;; FIMXE
          syntax-type
          syntax-name
          syntax-expander
          syntax-compiled-expander
          syntax-environment
          syntax-module
          %macroexpand-1))

(select-module STKLOS-COMPILER)

(define *compiler-port* #f)

(define *inline-table* `((+              . ,+)
                         (-              . ,-)
                         (*              . ,*)
                         (/              . ,/)
                         (fx+            . ,fx+)
                         (fx-            . ,fx-)
                         (fx*            . ,fx*)
                         (fxquotient     . ,fxquotient)
                         (=              . ,=)
                         (<              . ,<)
                         (<=             . ,<=)
                         (>              . ,>)
                         (>=             . ,>=)
                         (fx=?           . ,fx=?)
                         (fx<?           . ,fx<?)
                         (fx<=?          . ,fx<=?)
                         (fx>?           . ,fx>?)
                         (fx>=?          . ,fx>=?)
                         (cons           . ,cons)
                         (car            . ,car)
                         (cdr            . ,cdr)
                         (null?          . ,null?)
                         (list           . ,list)
                         (not              . ,not)
                         (vector-ref     . ,vector-ref)
                         (vector-set!    . ,vector-set!)
                         (string-ref     . ,string-ref)
                         (string-set!    . ,string-set!)
                         (eq?            . ,eq?)
                         (eqv?           . ,eqv?)
                         (equal?         . ,equal?)
                         (void           . ,void)))

(define *inline-symbols* (map car *inline-table*))

(define *always-inlined*        '(%set-current-module %%set-current-module
                                  %%execute %%execute-handler))

(define *code-instr*            #f)
(define *code-constants*        '())
(define *code-labels*           0)

(include "peephole.stk")
(include "assembler.stk")
(include "computils.stk")

; ======================================================================
;
;                            ENVIRONMENTS
;
; ======================================================================


;;; Environments are represented as lists of lists. An example:
;;; (let ((a 1)
;;;       (b 2)
;;;       (c 3))
;;;  (let ((d 4)
;;;        (e 5))
;;;
;;; This would be represented as the list
;;; ( (d e)
;;;   (a b c) )

;;; Lexically-scoped macros need to use the same stack as other identifiers,
;;; so we also include them here. However, they cannot be treated as other
;;; identifiers (they need to be expanded at compile time), so we represent them
;;; differently on the stack, as a pair of name-expander:
;;; (f . e) represents a macro "f" with its expander e.

;;; Symbol-in-env? was changed from a predicate to a procedure that
;;; searches and returns a symbol, and renamed to find-symbol-in-env.




;; Find-symbol-in-env searches for a symbol in an environment.
;; - if the symbol S is not found, #f is returned
;; - if the symbol S is found and it is represented as itself,
;;   "S", then it is itself returned.
;; - if the symbol S is found and it is represented as a
;;   pair (S . E), then it is a macro with its expander,
;;   and the pair is returned
;;
;; Suppose the environment is
;; env: ( (a b c)
;;        (x (m . e) y)
;;        (z) )
;;
;; Then:
;;
;; (find-symbol-in-env x env) => x
;; (find-symbol-in-env g env) => #f
;; (find-symbol-in-env m env) => (m . e)
;;
(define (find-symbol-in-env symb env)

  (define (compare? a b)
    (if (pair? b)
        (eq? a (car b))
        (eq? a b)))
  
  (let Loop ((l env))
    (if (null? l)
        #f
        (let ((x (member symb (car l) compare?)))
          (if x
              (caar l)
              (Loop (cdr l)))))))

;;;; ----------------------------------------------------------------------
;;;;
;;;; Lexically-scoped macros
;;;;
;;;; ----------------------------------------------------------------------

;; Lexically scoped macros work as this:
;;
;; 1. GLOBAL MACROS
;;
;; A global macro needs to be DEFINEd first, so it will have been
;; computed and can be stored in a global variable. So its value will
;; be a <syntax> structure, containing the expander.
;; When the compiler finds a global variable of this type, it just
;; expands and compiles the expanded form.
;;
;; Scheme implementation usally do not allow SET!-ing a variable that
;; is bound to a macro transformer, but it may be interesting to be
;; able to change the transformer of a macro.
;;
;; When the compiler finds a global macro being used,
;; (define-syntax f ...)
;; ...
;; (f ...)   <= f is bound to a <syntax> structure!
;;
;; then it will call f's expander on that form and call itself
;; recursively.
;;
;;
;; 2. LOCAL MACROS
;;
;; A local macro needs to have its identifier inserted in the same
;; stack structure that holds the names of variables, so lexical
;; scope works as intended (identifiers for variables -- used at execution
;; time -- and macros -- expanded at compile time -- may shadow each other).
;; Also, local macros defined in outermost code should be available for use
;; in macro code in innermost code:
;;
;; (define-syntax h ...)
;;
;; (let-syntax ((g ...))
;;   ...
;;     (let-syntax ((f ... ,(g ...) ...))  <= f may refer to g and h
;;
;; The local macro name is kept on the environment stack by the compiler
;; as a pair (not a symbol), so that it's clear it's a macro. The pair
;; is (name macro-obj), where macro-obj is an instance of <syntax>
;;
;; When the compiler finds a reference to an identifier,
;; - if it is stored as a symbol, compile reference-to-variable
;; - if it is stored as a pair, run the expander (which is stored
;;   along with the macro name), then recursively run the compiler.
;;
;;
;; 3. ENVIRONMENTS: HOW EXPANDERS ARE COMPILED
;;
;; A macro expander should use the environment in which it was defined.
;; So, compiled-expander should be compiled as
;;
;; (eval expander-in-env module)
;;
;; Where:
;; - expander-in-env is the expander source code, surrounded by LETs
;;   that bind the names of the macros in its environment to their
;;   <syntax> objects:
;;   (let-syntax ((h ...))
;;     (let-syntax ((g ...))
;;       (let-syntax ((f ...))
;;
;;   The expander-in-env for f is
;;   (let ((h h-obj))       <= h-obj is the <syntax> object for h
;;     (let ((g g-obj))     <= g-obj is the <syntax> object for h
;;       (lambda (form) ...)     <= expander for f
;;
;; When f makes a reference to a macro not in its local environment,
;; then the global environment should be used. But since we have modules,
;; the global environment is not unique, so the expander is compiled in
;; the module where the macro was defined.
;;
;;
;; 4. LOCAL MACROS USING GLOBAL MACROS
;;
;; If a global macro has been defined, then it is available as the value
;; of a global variable, *in a module*. So, since a local macro must
;; have access to that global macro, we computed the expander calling
;; eval in it, *on that module*.
;;
;; Caveat: it is possible to change the content of the global macro
;; after the local macro has been defined, but before it has been
;; used.
;;
;;
;; 5. WE DO NOT KEEP TRACK OF GLOBAL/LOCAL DISTINCTION
;;
;; It's not necessary.
;;
;; 6. NAME REWRITING, HYGIENE ETC
;;
;; We DO NOT yet deal with those issues here. They can be dealt with
;; separatelty later, maybe with the help of an ALIAS compiler macro.
;; 

;; FIXME: used "<syntax>" instead of "syntax" because it's the way other
;; types are defined, but then it's necessary to define alternative names
;; for the accessors...
;;
(define-struct <syntax>
  type                       ; syntax-rules? syntax-case? other?
  name                       ; may be useful
  expander                   ; source
  compiled-expander          ; compiled with environment
  environment                ; the environment representation as used in the compiler
  module)                    ; module where the macro was defined

(define syntax-type               <syntax>-type)
(define syntax-name               <syntax>-name)
(define syntax-expander           <syntax>-expander)
(define syntax-compiled-expander  <syntax>-compiled-expander)
(define syntax-environment        <syntax>-environment)
(define syntax-module             <syntax>-module)



;; Writing a macro will show something like this:
;; 
;; #[syntax f in module stklos, of type syntax-rules]
;;
;; NOTE: it is probably not possible to have a representation of macros that can
;; be read back, because the environment of the macro is part of it. Same for
;; closures.
;;
(struct-type-change-writer! <syntax>
                            (lambda (s port)
                              (display "#[syntax " port)
                              (display (struct-ref s 'name) port)
                              (when (module? (struct-ref s 'module))
                                (display " in module " port)
                                (display (module-name (struct-ref s 'module)) port))
                              (display ", of type " port)
                              (display (struct-ref s 'type) port)
                              (display "]" port)))


;; %%macroexpand  will expand the CAR of a form if it is a macro.
;;
;; If repeat is #f only ONE expansion is performed.
;; If repeat is #t then the car will be expanded repeatedly until it's
;; not a macro anymore.
;;
;; This is used INTERNALLY by the compiler for local macros!
;; (internally, because it requires env, which is the internal
;;  representation of the environment used by the compiler).
;;
(define (%%macroexpand form env repeat)
  (if (and (list? form)
           (not (null? form)))

      (let ((name (car form)))
        (let ((obj (find-symbol-in-env name env)))
          (cond ((and (pair? obj)
                      (<syntax>? (cdr obj)))
                 
                 ;; we have found a LOCAL macro use! apply the expander:
                 (let ((result (apply (syntax-compiled-expander (cdr obj))
                                      (cdr form))))
                   (if repeat
                       (%%macroexpand result env repeat)
                       result)))
                
                ((and (symbol? name)
                      (<syntax>? (symbol-value name (current-module) #f)))
                 ;; The car of the form was not found in the lexical environment, but
                 ;; is bound to a <syntax> structure in the current module, so it is a
                 ;; GLOBAL macro being used. We use it to expand the form!
                 (let ((s (symbol-value name (current-module) #f)))
                   (let ((result (apply (syntax-compiled-expander s)
                                        (cdr form))))
                     (if repeat
                         (%%macroexpand result env repeat)
                         result))))
                
                 
                (else
                  ;; car of the form was not the name of a macro, so
                  ;; we leave it along - return the form unchanged:
                  form))))

      ;; form was either '() or not a list, so we just
      ;; return it unchanged:
      form))

;; EXAMPLE:
;; (%%macroexpand '(f)
;;                (list (list (cons 'f (make-<syntax> (lambda (form) -2)))))
;;                #f)
;;  => -2

;; EXAMPLE:
;; (let ((f (make-<syntax> (lambda (form)
;;                             ;; (f x) -> (+ 1 x)
;;                             (list '+ 1 (cadr form))))))
;;   (let ((env (list (list (cons 'f f)))))
;;     (format #t "~a~%" (%%macroexpand '(g 2) env #f))
;;     (format #t "~a~%" (%%macroexpand 'f env #f))
;;     (format #t "~a~%" (%%macroexpand '(f -10) env #f))
;;     (format #t "~a~%" (%%macroexpand #(f 10) env #f))))
;; (g 2)
;; f
;; (+ 1 -10)
;; #(f 10)


;; %macroexpand-1  will expand the CAR of a form if it is a macro.
;; Only ONE expansion is performed.
;;
;; This is EXPORTED to the user, and can be used with GLOBAL macros.
;;
#|
<doc EXT %macroexpand-1
 * (%macroexpand-1 form)
 *
 * This procedure will take a Scheme form and, if it is a list and
 * its |car| is the name of a global macro in the current module,
 * expand its car.
 * 
 * Only one expansion is performed.
doc>
|#
(define (%macroexpand-1 form)
  (if (and (list? form)
           (not (null? form)))
      
      (let ((first (car form)))
        
        (if (and (symbol? first)
                 (<syntax>? (symbol-value first (current-module) #f)))
            ;; just apply the transformer and return the result:
            (apply (struct-ref (symbol-value first (current-module) 'x)
                               'compiled-expander)
                   form)
            
            ;; not a macro, return unchanged
            form))
      
      ;; not even a list, return unchanged
      form))


;;;
;;; LET-SYNTAX FOR MACROS WITH LEXICAL SCOPE
;;;

#|
<doc %let-syntax EXT-SYNTAX
 * (%define-syntax ( (name expander) ... )
 *
 * Defines a local macro. The macro will be included in the current
 * lexical scope, and scope rules will be valid for its name, but
 * it will NOT be hygienic:
 *
 * @lisp
 * (let ((f ...))
 *   (%define-syntax ((f ...))
 *      (f)))
 * @end lisp
 *
 * In the above example, |f| refers to the macro |f|, and not the
 * variable |f|;
 *
 * @lisp
 * (%define-syntax ((f ...))
 *   (let ((f ...))
 *      (f)))
 * @end lisp
 *
 * In the above example, |f| refers to the variable |f|, and not the
 * macro |f|.
 *
 * Local macros defined this way shadow and are shadowed by other bindings
 * in the environment (including variables).
 * However, although variable names are availabe, their bindings (and values)
 * are not available when the macro is expanded, so the expansion of a macro
 * cannot count on the value of a variable (or procedure) which is only available
 * at runtime.
doc>
|#
(define (compile-%let-syntax e env tail?)
  (when (not (= (length e) 3))
    (error "bad let binding (length of form is not three)"))
  (let ((body (caddr e)))
    (if (null? (cadr e))
        (compile-body (cddr e) env e tail?)
        (let Loop ((bindings (cadr e)) (new-env '()))
          (if (not (null? bindings))
              (let ((b      (car bindings)))
                (let ((name     (car b))
                      (expander (cadr b)))
                  
                  (let ((macro-in-env (cons name (make-<syntax> 'lambda
                                                                name
                                                                expander
                                                                (eval expander
                                                                      (current-module))
                                                                env))))
                    
                    (Loop (cdr bindings) (cons macro-in-env new-env)))))
              
              (begin
                (compile body (cons new-env env) body tail?)))))))



;;;; ----------------------------------------------------------------------
;;;;
;;;; END of support for lexically-scoped macros
;;;;
;;;; ----------------------------------------------------------------------



;; ----------------------------------------------------------------------
;; Debbugging support
;; ----------------------------------------------------------------------
;;= (export %compiler-debug)
;;=
;;= (define %compiler-debug (make-parameter #f))
;;=
;;= (define (dprintf . args)
;;=   (when  (%compiler-debug) (apply eprintf args)))
;;=

;; ----------------------------------------------------------------------
;;      Compiler parameters ...
;; ----------------------------------------------------------------------
(define compiler:time-display                   (make-parameter #t))
(define compiler:gen-line-number                (make-parameter #f))
(define compiler:warn-use-undefined             (make-parameter #f))
(define compiler:warn-use-undefined-postpone    (make-parameter #t))
(define compiler:show-assembly-code             (make-parameter #f))
(define compiler:generate-signature             (make-parameter #f))

(define compiler:inline-common-functions
  (let ((inlined *inline-symbols*))
    (make-parameter #t
                    (lambda (v)
                      (set! *inline-symbols* (if v inlined '()))
                      (not (null? *inline-symbols*))))))

(define (new-label)
  (let ((lab *code-labels*))
    (set! *code-labels* (+ *code-labels* 1))
    lab))

(define %compiler-new-label new-label)  ;; public name of new-label

(define (emit . args)
  (set! *code-instr* (cons args *code-instr*)))

(define (emit-label lab)
  (set! *code-instr* (cons lab *code-instr*)))


; ======================================================================
;
;                               CONSTANTS
;
; ======================================================================

(define (fetch-constant c)
  (let ((x (memq c *code-constants*)))
    (unless x
      ;; This constant was not in the table; add it.
      (set! x (list c))
      (set! *code-constants* (append! *code-constants* x)))
    (- (length *code-constants*) (length x))))

(define small-integer-constant?
  (let ((min-int (- (expt 2 15)))
        (max-int (- (expt 2 15) 1)))
    (lambda (v)
      (and (integer? v)
           (exact? v)
           (<= min-int v max-int)))))

(define (compile-constant v env tail?)
  (cond
    ((eq? v #t)                        (emit 'IM-TRUE))
    ((eq? v #f)                        (emit 'IM-FALSE))
    ((eq? v '())                       (emit 'IM-NIL))
    ((eq? v -1)                        (emit 'IM-MINUS1))
    ((eq? v 0)                         (emit 'IM-ZERO))
    ((eq? v 1)                         (emit 'IM-ONE))
    ((eq? v (void))                    (emit 'IM-VOID))
    ((small-integer-constant? v)       (emit 'SMALL-INT v))
    (else                              (emit 'CONSTANT (fetch-constant v)))))


#|
<doc syntax quote
 * (quote <datum>)
 * '<datum>
 *
 * The quoting mechanism is identical to R5RS, except that keywords
 * constants  evaluate "to themselves" as numerical constants, string
 * constants, character constants, and boolean constants
 * @lisp
 * '"abc"     =>  "abc"
 * "abc"      =>  "abc"
 * '145932    =>  145932
 * 145932     =>  145932
 * '#t        =>  #t
 * #t         =>  #t
 * :foo       =>  :foo
 * ':foo      =>  :foo
 * @end lisp
 * ,(bold "Note:") R5RS requires to quote constant lists and
 * constant vectors. This is not necessary with STklos.
doc>
|#
(define (compile-quote expr env tail?)
  (if (= (length expr) 2)
      (compile-constant (cadr expr) env tail?)
      (compiler-error 'quote expr "bad usage in ~S" expr)))




; ======================================================================
;
;                               DEFINE
;
; ======================================================================
(define *forward-globals* '())

(define (known-var? symbol)
  (or (symbol-bound? symbol)
      (memq symbol (compiler-known-globals))))


(define (compiler-warn-undef symbol epair)
  (compiler-warning (void) epair "reference to undefined symbol ~S" symbol))

(define (verify-global symbol epair)
  (unless (known-var? symbol)
    (cond
      ((compiler:warn-use-undefined-postpone)
       (set! *forward-globals* (cons (cons symbol epair) *forward-globals*)))
      ((compiler:warn-use-undefined)
       (compiler-warn-undef symbol epair)
       (register-new-global! symbol)))))        ; to avoid multiple warnings


(define (compiler-show-undefined-symbols)
  (for-each (lambda (x)
              (let ((symbol (car x))
                    (where  (cdr x)))
                (unless (known-var? symbol)
                  (compiler-warn-undef symbol where)
                  (register-new-global! symbol)))) ;; to avoid multiple warnings
            *forward-globals*)
  (set! *forward-globals* '()))



(define (define->lambda l)
  (if (> (length l) 2)
      (let ((bind (cadr l))
            (body (cddr l)))
        (if (pair? bind)
            (define->lambda `(define ,(car bind) (lambda ,(cdr bind) ,@body)))
            l))
      (begin
        (compiler-error 'define l "ill formed definition ~S" l)
        l)))

(define (compile-define args env tail?)
  (let* ((l   (define->lambda args))
         (who (cadr l)))
    (if (not (= (length l) 3))
        (compiler-error 'define args "bad definition")
        (if (null? env)
            (if (symbol? who)
                (begin
                  (register-new-global! who)
                  (compile (caddr l) '() args #f)
                  (emit 'DEFINE-SYMBOL (fetch-constant who)))
                (compiler-error 'define args "bad variable name ~S" who))
            (compiler-error 'define args "internal define forbidden here ~S" args)))))


;;;;
;;;; REFERENCES & ASSIGNMENT
;;;;


(define (compile-access name env epair ref)

  (define (make-word v1 v2)               ;; FIXME: Add control
    (+ (* v1 256) v2))


  (define (em i1 i2 . args)
    (apply emit (if ref i1 i2) args))

  (let loop ((lev 0) (env env))
    (if (null? env)
        
        ;; name is a global variable
        (begin
          (verify-global name epair)
          (em 'GLOBAL-REF 'GLOBAL-SET (fetch-constant name)))

        
        ;; name is a local variable:
        
        ;; Changed by jpellegrini (2021-07-25): if we're dealing with an environment
        ;; level that was introduced by %let-syntax, then we do NOT count it for variable
        ;; access (otherwise an extra level will be used and variable access will be
        ;; totally wrong when %let-syntax is used).
        (let loop2 ((idx 0) (l (car env)) (synt #f)) ; last arg means "is this a let-syntax level?"
          (cond
            ((null? l)
             (if synt
                 (loop lev (cdr env))          ; let-syntax level, don't increment lev
                 (loop (+ lev 1) (cdr env))))  ; ordinary variables level, increment lev

            ((pair? (car l))
             (when (eq? (caar l) name) compiler-error "syntax ~S used as value" name)
             (loop2 (+ idx 1) (cdr l) #t))
            
            ((eq? (car l) name)
             (if (zero? lev)
                 ;; variable in  innermost block
                 (case idx
                   ((0)  (em 'LOCAL-REF0 'LOCAL-SET0))
                   ((1)  (em 'LOCAL-REF1 'LOCAL-SET1))
                   ((2)  (em 'LOCAL-REF2 'LOCAL-SET2))
                   ((3)  (em 'LOCAL-REF3 'LOCAL-SET3))
                   ((4)  (em 'LOCAL-REF4 'LOCAL-SET4))
                   (else (em 'LOCAL-REF  'LOCAL-SET  idx)))
                 ;; local variable in a "between" block
                 (let ((arg (make-word lev idx)))
                   (if (small-integer-constant? arg)
                     (em 'DEEP-LOCAL-REF  'DEEP-LOCAL-SET (make-word lev idx))
                     (em 'DEEP-LOC-REF-FAR 'DEEP-LOC-SET-FAR ;; Use a FAR variants
                         (fetch-constant (cons lev idx)))))))
            (else   (loop2 (+ idx 1) (cdr l) synt)))))))


(define (compile-reference name env epair tail?)
  (compile-access name env epair #t))

(define (compile-set! args env tail?)
  (let ((len (length (cdr args))))
    (if (= len 2)
        (let ((var (cadr args))
              (val (caddr args)))
          (if (list? var)
              ;; This is a extended set! usage as in "(set! (f x y z) value)"
              (compile `((setter ,(car var)) ,@(cdr var) ,val) env args tail?)
              ;; R5RS usage
              (if (symbol? var)
                  (begin
                    (compile val env args #f)
                    (compile-access var env args #f))
                  (compiler-error 'set! args "~S is a bad symbol" var))))
        (compiler-error 'set! (cdr args) "bad assignment syntax in ~S" args))))

;;;;
;;;; IF
;;;;
(define (compile-if args env tail?)
  (let ((len (length (cdr args)))
        (l1  (new-label))
        (l2  (new-label)))
    (if (<= 2 len 3)
        (begin
          (compile (cadr args) env args #f)
          (emit 'JUMP-FALSE l1)
          (compile (caddr args) env args tail?)
          (emit 'GOTO l2)
          (emit-label l1)
          (if (= len 3)
              (compile (cadddr args) env args tail?)
              (emit 'IM-VOID))
          (emit-label l2))
        (compiler-error 'if args "bad syntax in ~S" args))))

;;
;; DEFINE-MACRO
;;
(define (compile-define-macro e env tail?)
  ;; Called for global macros.
  (if (null? env)
      (let ((l (define->lambda e)))
        (when (= (length l) 3)
          (let* ((l        (extended-lambda->lambda l))
                 (name     (cadr l))
                 (proc     (caddr l))
                 (form     (gensym 'form))
                 (e        (gensym '_))
                 (expander `(lambda (,form ,e) (apply ,proc (cdr ,form)))))
            ;; Install expander for further compilation
            (install-expander! name (eval expander) proc)
            ;; Compile code for installing expander (for byte-code files)
            ;; YES! we need both (install + compile)
            (compile expander '() e #f)
            (emit 'MAKE-EXPANDER (fetch-constant name)))))
      (compiler-error 'define-macro e "internal define-macro forbidden here ~S" e)))


(define (compile-internal-define-macro e env tail?)
  ;; This one is called when we find a define-macro while rewriting a body
  ;; (for internal defines -> letrec)
  (let ((l (define->lambda e)))
    (when (= (length l) 3)
      (let* ((l        (extended-lambda->lambda l))
             (name     (cadr l))
             (proc     (caddr l))
             (expander `(lambda (form e) (apply ,proc (cdr form)))))
        ;; Push expander for further compilation (shadowing global macro)
        (push-expander! name (eval expander))
        ;; return the name of the defined macro
        name))))

;;;;
;;;; WHEN/UNLESS
;;;;
(define-macro (when . args)
  (let ((len (length args)))
    (if (> len 1)
        `(if ,(car args) (begin ,@(cdr args)))
        (compiler-error 'when args "bad syntax in ~S" `(when ,@args)))))

(define-macro (unless . args)
  (let ((len (length args)))
    (if (> len 1)
        `(if (not ,(car args)) (begin ,@(cdr args)))
        (compiler-error 'unless args "bad syntax in ~S" `(unless ,@args)))))


;;;;
;;;; WHEN/UNLESS
;;;;
(define-macro (set! . args)
  `(%%set! ,@args))


#|

                                A N D

<doc syntax and
 * (and <test1> ...)
 *
 * The |<test>| expressions are evaluated from left to right, and the
 * value of the first expression that evaluates to a false value is
 * returned.  Any remaining expressions are not evaluated.  If all the
 * expressions evaluate to true values, the value of the last expression
 * is returned.  If there are no expressions then |%t| is returned.
 *
 * @lisp
 *   (and (= 2 2) (> 2 1))           =>  #t
 *   (and (= 2 2) (< 2 1))           =>  #f
 *   (and 1 2 'c '(f g))             =>  (f g)
 *   (and)                           =>  #t
 * @end lisp
doc>
|#
(define (compile-and args env tail?)
  (if (null? (cdr args))
      ;; Case (and) ==> #t
      (emit 'IM-TRUE)
      ;; General case
      ;; code for (and x1 x2 .. xn) is
      ;;      x1; jump-false l1; x2; jump-false l1; ... goto l2; l1: im-false; L2:
      (let ((lab1 (new-label))
            (lab2 (new-label)))
        (let Loop ((l (cdr args)))
          (cond ((null? l)           #f)
                ((null? (cdr l))     (compile (car l) env args tail?))
                (else                (compile (car l) env args #f)
                                     (emit 'JUMP-FALSE lab1)
                                     (Loop (cdr l)))))
        (emit 'GOTO lab2)
        (emit-label lab1)
        (emit 'IM-FALSE)
        (emit-label lab2))))

#|

                                O R
 *
<doc syntax or
 * (or <test1> ...)
 *
 * The |<test>| expressions are evaluated from left to right, and the
 * value of the first expression that evaluates to a true value is
 * returned.  Any remaining expressions are not evaluated.  If all
 * expressions evaluate to false values, the value of the last expression
 * is returned.  If there are no expressions then |%f| is returned.
 *
 * @lisp
 *   (or (= 2 2) (> 2 1))            =>  #t
 *   (or (= 2 2) (< 2 1))            =>  #t
 *   (or #f #f #f)                   =>  #f
 *   (or (memq 'b '(a b c))
 *       (/ 3 0))                    =>  (b c)
 * @end lisp
doc>
|#
(define (compile-or args env tail?)
  ;; General case
  ;; code for (or x1 x2 .. xn) is
  ;;      x1; jump-true l1; x2; jump-true l1; ... ; im-false; L1:
  (let ((lab (new-label)))
    (let Loop ((l (cdr args)))
      (unless (null? l)
        (compile (car l) env args (and tail? (null? (cdr l))))
        (emit 'JUMP-TRUE lab)
        (Loop (cdr l))))
    (emit 'IM-FALSE)
    (emit-label lab)))


;;;;
;;;; BEGIN
;;;;
(define (compile-begin args env tail?)
  (let ((len (length (cdr args))))
    (case len
      ((0) ;; Body without form
           (emit 'IM-VOID))
      ((1) ;; A begin with only one sexpr in it
           (compile (cadr args) env args tail?))
      (else ;; General case
           (let Loop ((body (cdr args)))
             (if (null? (cdr body))
                 ;; last expression of the begin
                 (compile (car body) env args tail?)
                 ;; expression in the middle
                 (begin
                   (compile (car body) env args #f)
                   (Loop (cdr body)))))))))

;;;;
;;;; LAMBDA
;;;;
(define (compute-arity l)
  (let loop ((l l) (n 0))
    (cond
       ((null? l) n)
       ((pair? l) (loop (cdr l) (+ n 1)))
       (else      (- (- n) 1)))))

(define (extend-env env formals)
  (letrec ((aux (lambda (l res)
                  (cond
                     ((null? l) res)
                     ((pair? l) (aux (cdr l) (cons (car l) res)))
                     (else      (cons l res))))))
    (cons (aux formals '()) env)))


(define (extend-current-env env symbol)
  ;; Add just symbol to the current environment (used by let*)
  (cons (append (car env) (list symbol))
        (cdr env)))

;;  (define (valid-lambda? expr)
;;    (define (param-ok? l seen)
;;      (cond
;;       ((null? l)   #t)
;;       ((symbol? l) (if (memq l seen)
;;                    (compile-error "duplicate parameter ~S" l)
;;                    #t))
;;       ((pair? l)   (and (symbol? (car l))
;;                     (param-ok? (car l) seen)
;;                     (param-ok? (cdr l) (cons (car l) seen))))
;;       (else        (compile-error "bad procedure parameter ~S" l))))
;;
;;    ;; code of valid-lambda? starts here
;;
;;    (and (> (length expr) 2)
;;         (param-ok? (cadr expr) '())))
;;

(define (compile-body body env epair tail?)

  (define internal-macros '())

  (define (rewrite-body body)
    (let Loop ((l body) (defs '()))
      (let ((cur (cond
                   ((null? l)
                      (error "body is empty"))
                   ((and (pair? l) (pair? (car l)) (expander? (caar l)))
                      (%macro-expand* (car l)))
                   (else
                      (car l)))))
        (cond
          ((and (pair? cur) (eq? (car cur) 'begin))
            ;; Delete useless begin
            (Loop (append (cdr cur) (cdr l))
                  defs))
        ((and (pair? cur) (eq? (car cur) 'define))
           ;; This is an internal define
         (Loop (cdr l) (cons (cdr (define->lambda cur)) defs)))
        
        ((and (pair? cur) (eq? (car cur) '%define-syntax))
         ;; This is an internal %define-syntax
         ;; FIXME: make this work
         (Loop (cdr l) (cons (cdr (define->lambda cur)) defs)))
        
        ((and (pair? cur) (eq? (car cur) 'define-macro))
           ;; This is an internal define-macro. Add expander + skip expression
           (let ((name (compile-internal-define-macro cur env #f)))
             (set! internal-macros (cons name internal-macros))
             (Loop (cdr l) defs)))
        (else
           ;; We have parsed all the (starting) definitions
           (if (null? defs)
               `(begin ,@l)
               (let ((defs (reverse! defs)))
                 ;; Generate "similar" to a letrec*
                 `(let ,(map (lambda (x) (list (car x) #f)) defs)
                    ,@(map (lambda (x) `(set! ,@x)) defs)
                    ,@l))))))))

  ;; rewrite the body to transform internal define to letrec
  (compile (rewrite-body body) env epair tail?)

  ;; delete all the internal macros from the list of expanders
  (for-each delete-expander! internal-macros))


(define (compile-user-lambda formals body arity env)    ; i.e R5RS ones
  (let* ((env  (extend-env env formals))
         (lab  (new-label))
         (doc  (if (and (> (length body) 1) (string? (car body)))
                   (car body)
                   #f))
         (body (if doc (cdr body) body)))

    (emit 'CREATE-CLOSURE lab arity)
    (compile-body body env body #t)
    (emit 'RETURN)
    (emit-label lab)

    (when (compiler:generate-signature)
      ;; emit signature
      (emit 'FORMALS (fetch-constant formals)))

    (when doc
      ;; emit the docstring
      (emit 'DOCSTRG (fetch-constant doc)))))


;;; EXTENDED LAMBDAS
;;;
;;; This code is an adaptation of the contribution of Ian Wild <imw@acm.org>
;;; which provided Common Lisp style lambda lists for the original STk.
(define ext-lambda-key-get key-get)

(define (build-let* opt key rest-name user-visible-rest body)
  ;; Create a (LET*...) to do the actual bindings

  (define (pop x)
    (let ((pop-local-variable (gensym)))
      `(let ((,pop-local-variable (car ,x)))
         (set! ,x (cdr ,x))
         ,pop-local-variable)))


  (define (build-optional-let-header vars rest-name)
    (apply append
           (map (lambda (x)
                  (let ((var  (car x))
                        (init (cadr x))
                        (var? (caddr x)))
                    ;; if we have keywords, the end of optional
                    ;; happens when we encounter the end of the
                    ;; parameter list or the first keyword
                    (if key
                        ;; function accepts keywords
                        (cond
                          (var? `((,var? (and (pair? ,rest-name)
                                              (not (keyword? (car ,rest-name)))))
                                  (,var ,(if init
                                             `(if ,var? ,(pop rest-name) ,init)
                                             `(and ,var? ,(pop rest-name))))))
                          (init `((,var (if (or (null? ,rest-name)
                                                (keyword? (car ,rest-name)))
                                            ,init
                                            ,(pop rest-name)))))
                          (else `((,var (and (pair? ,rest-name)
                                             (not (keyword? (car ,rest-name)))
                                             ,(pop rest-name))))))
                        ;; function has optionals but no keywords
                        (cond
                          (var? `((,var? (pair? ,rest-name))
                                  (,var ,(if init
                                             `(if ,var? ,(pop rest-name) ,init)
                                             `(and ,var? ,(pop rest-name))))))
                          (init `((,var (if (null? ,rest-name)
                                            ,init
                                            ,(pop rest-name)))))
                          (else `((,var (and (pair? ,rest-name)
                                             ,(pop rest-name)))))))))
                  vars)))

   (define (constant? e)
     (cond
        ((symbol? e) #f)
        ((pair? e)   (memq (car e) '(quote lambda)))
        (else        #t)))

   (define (build-keyword-let-header vars rest-name)
     (apply append
            (map (lambda (x)
                   (let* ((var  (car x))
                          (init (cadr x))
                          (var? (caddr x))
                          (key  (make-keyword var)))
                     (cond
                        (var? (let ((g (gensym)))
                                `((,g (key-get ,rest-name ,key ',g))
                                  (,var? (not (eq? ,g ',g)))
                                  (,var ,(if init
                                             `(if ,var? ,g ,init)
                                             `(and ,var? ,g))))))
                        ((constant? init)
                            ;; if evaluating the initform is harmless, just
                            ;; call key-get with it as default
                            `((,var (key-get ,rest-name ,key ,init))))
                        (else
                             ;; only evaluate initform if get-keyword returns
                             ;; our newly gensym'ed symbol
                             (let ((g (gensym)))
                               `((,g (key-get ,rest-name ,key ',g))
                                 (,var (if (eq? ,g ',g) ,init ,g))))))))
                 vars)))


  (let ((error-check (if (or user-visible-rest key)
                         '()
                         `((if (pair? ,rest-name)
                               (error "too many optional parameters: ~a"
                                      ,rest-name)))))
        (vars (append (if opt (build-optional-let-header opt rest-name) '())
                      (if key (build-keyword-let-header key rest-name) '()))))
    `(let* (,@(if opt (build-optional-let-header opt rest-name) '())
            ,@(if key (build-keyword-let-header key rest-name) '()))
       ,@error-check
       (let () ,@body))))

(define (parse-parameter-list method? x)
  ;; Read the incoming lambda (or method) list, return a list of four lists,
  ;; the required, optional, keyword, and rest, in that order.
  ;; The last three elements can be #f if not present.
  ;; (Don't look too closely, this function isn't very nice.)
  (define required '())
  (define optional '())
  (define keywords '())
  (define rest     '())
  (define epair    x)


  (define (normalise-parameter-list x optional?)
    ;; Convert optional or keyword parameters to three-element lists:
    ;; (variable initform supplied-p), providing an  explicit #f
    ;; initform  if needed, and maybe another #f as supplied-p.
    (and (pair? x)
         (map (lambda (e)
                (cond
                  ((symbol? e)                  (list e #f #f))
                  ((and (pair? e)
                        (= (length e) 2)
                        (symbol? (car e)))      (append e (list #f)))
                  ((and (pair? e)
                        (= (length e) 3)
                        (symbol? (car e))
                        (symbol? (caddr e)))    e)
                  (else (compiler-error 'lambda epair "illegal ~a parameter: ~a"
                                        (if optional? "optional" "keyword") e)
                        (list (gensym) #f #f))))
              x)))

  (define (collect-sequence)
    (let loop ((seq '()) (still-left x))
      (if (or (null? still-left) (memq (car still-left) '(:optional :key :rest)))
          (begin
            (set! x still-left)
            (reverse seq))
          (loop (cons (car still-left) seq) (cdr still-left)))))

  (define (collect-titled-sequence title)
    (if (and (not (null? x)) (eq? (car x) title))
        (begin
          (set! x (cdr x))
          (collect-sequence))
        #f))

  (define (check-formals l seen)
    (unless (null? l)
      (let ((param (car l)))
        (cond
           ((symbol? param)
                    (if (memq param seen)
                        (compiler-error (void) epair "duplicate parameter ~S" param)
                        (check-formals (cdr l) (cons param seen))))
           ((and method? (list? param) (= (length param) 2))
                    (if (symbol? (cadr param))
                        (and (check-formals (list (car param)) seen)
                             (check-formals (cdr l) (cons (car param) seen)))
                        (compiler-error (void) epair "bad class name ~S" param)))
           (else    (compiler-error (void) epair
                                     "bad procedure parameter ~S" param))))))


  ;; If the original lambda list is *not* a proper list, i.e. a symbol
  ;; or a dotted list, add in the implied :rest
  (unless (list? x)
    (set! x (if (pair? x)
                (let* ((new-x (list-copy x))
                       (last  (last-pair new-x)))
                  (set-cdr! last (list :rest (cdr last)))
                  new-x)
                (list :rest x))))

  (set! required (collect-sequence))
  (set! optional (normalise-parameter-list (collect-titled-sequence :optional) #t))
  (set! rest     (collect-titled-sequence :rest))
  (set! keywords (normalise-parameter-list (collect-titled-sequence :key) #f))

  ;; Do some checks on the arguments
  ;; 1. no un-analyzed parameter
  (unless (null? x)
    (compiler-error 'lambda epair "illegal lambda list ending with ~a" x))

  ;; 2. Rest is a symbol (collect returns a list)
  (when rest
    (unless (and (= (length rest) 1) (symbol? (car rest)))
      (compiler-error 'lambda epair "rest parameter must be a single symbol"))
    (set! rest (car rest)))

  ;; 3. Every formal is a symbol and there is no duplicate
  (check-formals (append (if optional (map car optional) '())
                         (if keywords (map car keywords) '())
                         (if rest     (list rest)        '())
                         required)
                 '())
  ;; OK, let's go
  (list required optional keywords rest))


(define (rewrite-params-and-body method? formals body)
  ;; Rewrite the extended form as an ordinary (though headless) lambda form.
  ;; In a spurious attempt at efficiency, no LET* is generated
  ;; unless at least one of :optional and :key is used.
  (let* ((params (parse-parameter-list method? formals))
         (req    (car params))
         (opt    (cadr params))
         (key    (caddr params))
         (rest   (cadddr params)))
    (if (or opt key)
        ;; We have a :optional or a :key keyword
        (let ((rest-name (or rest (gensym))))
          (if (null? req)                                       ; FIXME: simpl
              (set! req rest-name)
              (set-cdr! (last-pair req) rest-name))
          `(,req  ,(build-let* opt key rest-name rest body)))
        ;; "Normal" lambda
        (begin (if rest
                   (if (null? req)
                       (set! req rest)
                       (set-cdr! (last-pair req) rest)))
               `(,req  ,@body)))))

(define (extended-lambda->lambda el)    ;; STklos lambda => R5RS lambda
  (if (> (length el) 2)
      (let* ((method? (eq? (car el) 'method))
             (formals (cadr el))
             (body    (cddr el))
             (doc     (and (> (length body) 1) (string? (car body)) (car body)))
             (new     (rewrite-params-and-body method?
                                               formals
                                               (if doc (cdr body) body))))
        (if doc
            `(lambda ,(car new)
               ,doc
               ,@(cdr new))
            `(lambda ,@new)))
      (compiler-error 'lambda el "bad definition ~S" el)))


(define (compile-lambda args env tail?)
  (let* ((r5rs-lambda (extended-lambda->lambda args))
         (formals     (cadr r5rs-lambda))
         (body        (cddr r5rs-lambda))
         (arity       (compute-arity formals)))
    (compile-user-lambda formals body arity env)))

;;;;
;;;; APPLICATION
;;;;

(define (compile-args actuals env)
  (unless (null? actuals)
    (compile (%%macroexpand (car actuals) env #t) env actuals #f)
    (emit 'PUSH)
    (compile-args (cdr actuals) env)))


(define (compile-var-args actuals number-of-fix env)
  ;; for a (a b . c), replace (1 2 3 4 5) by (1 2 (list 3 4 5))
  (let loop ((n number-of-fix) (f '()) (rest actuals))
    (if (zero? n)
        (compile-args `(,@(reverse f) (list ,@rest)) env)
        (loop (- n 1) (cons (car rest) f) (cdr rest)))))


(define %maybe-generate-line-information
  ;; keep the last generated file name to avoid to produce a new file
  ;; name (which is probably long) at each line information generation.
  (let ((%last-generated-file-name #f))
    (lambda (epair)
      (when (and (compiler:gen-line-number) (%epair? epair))
        ;; Generate a line number for the call
        (let ((file (%epair-file epair))
              (line (%epair-line epair)))
          (unless (equal? file %last-generated-file-name)
            (set! %last-generated-file-name file))
          ;; the parameter constant of instruction should be short
          (when (small-integer-constant? line)
            (compile-constant %last-generated-file-name '() #f)
            (emit 'PUSH)
            (emit 'CALL-LOCATION line)))))))


(define (generate-PREPARE-CALL epair)
  (emit 'PREPARE-CALL)
  (%maybe-generate-line-information epair))


(define (compile-normal-call fct actuals len env epair tail?)
  (generate-PREPARE-CALL epair)
  (compile-args actuals env)
  (compile fct env actuals #f)
  (emit (if tail? 'TAIL-INVOKE  'INVOKE)
        (length actuals)))

(define can-be-inlined?
  (let ((STklos (find-module 'STklos)))
    (lambda (fct env)
      ;; Avoid to use *inline-table* on all symbols (assoc is too expensive here)
      (if (and (memq fct *inline-symbols*)
               (not (find-symbol-in-env fct env)))
          (let ((f (assoc fct *inline-table*)))
            (and f (eq? (symbol-value* fct STklos) (cdr f))))
          (memq fct *always-inlined*)))))


(define (compile-primitive-call fct actuals len env epair tail?)
  (let ((comp  (lambda (mnemo expr)
                 (compile expr env epair #f)
                 (emit mnemo)))
        (comp1 (lambda (mnemo)
                 (if (= len 1)
                     (begin
                       (compile (car actuals) env epair #f)
                       (emit mnemo))
                     (compiler-error fct epair "1 argument required (~A provided)"
                                    len))))
        (comp2 (lambda (mnemo)
                 (if (= len 2)
                     (begin
                       (compile (car actuals) env epair #f)
                       (emit 'PUSH)
                       (compile (cadr actuals) env epair #f)
                       (emit mnemo))
                     (compiler-error fct epair "2 arguments required (~A provided)"
                                     len))))
        (oper1 (lambda (mnemo a)
                 (compile a env epair #f)
                 (emit mnemo)))
        (oper2 (lambda (mnemo a b)
                 (compile a env epair #f)
                 (emit mnemo b)))
        (komp2 (lambda (mnemo a b)
                 (compile a env epair #f)
                 (emit 'PUSH)
                 (compile b env epair #f)
                 (emit mnemo)))
        (comp3 (lambda (mnemo)
                 (if (= len 3)
                     (begin
                       (compile (car actuals) env epair #f)
                       (emit 'PUSH)
                       (compile (cadr actuals) env epair #f)
                       (emit 'PUSH)
                       (compile (caddr actuals) env epair #f)
                       (emit mnemo))
                     (compiler-error fct epair "3 arguments required (~A provided)"
                                     len)))))
    (case fct
      ;; Always inlined functions
      ((%%set-current-module)
              (if (= len 1)
                  (comp1 'SET-CUR-MOD)
                  (compiler-error '%%set-current-module epair
                                   "1 arg. only (~S)" len)))
      ((%%execute-handler)
              (comp3 'EXEC-HANDLER))

      ;; User functions
      ((void) (emit 'IM-VOID))
      ((+)  (case len
              ((0)  (emit 'IM-ZERO))
              ((1)  (if (number? (car actuals))
                        (compile (car actuals) env epair tail?)
                        (compile-normal-call fct actuals len env epair #f)))
              ((2)  (let ((a (car actuals))
                          (b (cadr actuals)))
                      (cond
                        ((and (number? a) (number? b))
                         (compile-constant (+ a b) env #f))
                        ((small-integer-constant? a)
                         (if (= a 1)
                             (oper1 'IN-INCR b)
                             (oper2 'IN-SINT-ADD2 b a)))
                        ((small-integer-constant? b)
                         (if (= b 1)
                             (oper1 'IN-INCR a)
                             (oper2 'IN-SINT-ADD2 a b)))
                        (else
                          (comp2 'IN-ADD2)))))
              (else (compile-normal-call fct actuals len env epair #f))))
      ((-)  (case len
                ((0)  (compiler-error '- epair "needs at least one argument"))
                ((1)  (if (number? (car actuals))
                          (compile-constant (- (car actuals)) env #f)
                          (compile-normal-call fct actuals len env epair #f)))
                ((2)  (let ((a (car actuals))
                            (b (cadr actuals)))
                        (cond
                          ((and (number? a) (number? b))
                           (compile-constant (- a b) env tail?))
                          ((small-integer-constant? a)
                           (oper2 'IN-SINT-SUB2 b a))
                          ((eq? b 1)
                           (oper1 'IN-DECR a))
                          ((and (number? b)
                                (small-integer-constant? (- b)))
                           (oper2 'IN-SINT-ADD2 a (- b)))
                          (else
                           (comp2 'IN-SUB2)))))
                (else (compile-normal-call fct actuals len env epair #f))))
      ((*)    (case len
                ((0)  (emit 'IM-ONE))
                ((1)  (if (number? (car actuals))
                        (compile (car actuals) env epair tail?)
                        (compile-normal-call fct actuals len env epair #f)))
                ((2)  (let ((a (car actuals))
                            (b (cadr actuals)))
                        (cond
                          ((and (number? a) (number? b))
                           (compile-constant (* a b) env tail?))
                          ((small-integer-constant? a)
                           (oper2 'IN-SINT-MUL2 b a))
                          ((small-integer-constant? b)
                           (oper2 'IN-SINT-MUL2 a b))
                          (else
                           (comp2 'IN-MUL2)))))
                (else (compile-normal-call fct actuals len env epair #f))))
      ((/)    (case len
                ((0)   (compiler-error '/ epair "needs at least one argument"))
                ((1)   (if (number? (car actuals))
                          (compile-constant (/ 1 (car actuals)) env #f)
                          (compile-normal-call fct actuals len env epair #f)))
                ((2)  (let ((a (car actuals))
                            (b (cadr actuals)))
                        (cond
                          ((and (number? a) (number? b))
                           (compile-constant (/ a b) env tail?))
                          ((small-integer-constant? b)
                           (oper2 'IN-SINT-DIV2 a b))
                          (else
                           (comp2 'IN-DIV2)))))
                (else  (compile-normal-call fct actuals len env epair #f))))
      ((fx+ fx- fx* fxquotient)
                (case len
                  ((2) (let ((a (car actuals))
                             (b (cadr actuals)))
                         (cond
                           ((and (fixnum? a) (fixnum? b))
                            (compile-constant (case fct
                                                ((fx+) (fx+ a b))
                                                ((fx-) (fx- a b))
                                                ((fx*) (fx* a b))
                                                (else  (fxquotient a b)))
                                              env
                                              tail?))
                           ((and (small-integer-constant? a)
                                 (memq fct '(fx+ fx*))) ; commutative only
                            (oper2 (if (eq? fct 'fx+)
                                       'IN-SINT-FXADD2
                                       'IN-SINT-FXMUL2)
                                   b a))
                           ((small-integer-constant? b)
                            (oper2 (case fct
                                     ((fx+) 'IN-SINT-FXADD2)
                                     ((fx-) 'IN-SINT-FXSUB2)
                                     ((fx*) 'IN-SINT-FXMUL2)
                                     (else  'IN-SINT-FXDIV2))
                                   a b))
                           (else
                            (comp2 (case fct
                                     ((fx+) 'IN-FXADD2)
                                     ((fx-) 'IN-FXSUB2)
                                     ((fx*) 'IN-FXMUL2)
                                     (else  'IN-FXDIV2)))))))
                  (else
                   (compile-normal-call fct actuals len env epair #f))))

      ((= < > <= >=)
                (case len
                ((O)   (compiler-error fct epair
                                        "needs at least one argument" fct))
                ((2)   (comp2 (case fct
                                ((=)  'IN-NUMEQ)
                                ((<)  'IN-NUMLT)
                                ((>)  'IN-NUMGT)
                                ((<=) 'IN-NUMLE)
                                ((>=) 'IN-NUMGE))))
                (else  (compile-normal-call fct actuals len env epair #f))))

      ((fx=? fx<? fx>? fx<=? fx>=?)
                (case len
                ((O)   (compiler-error fct epair
                                        "needs at least one argument" fct))
                ((2)   (comp2 (case fct
                                ((fx=?)  'IN-FXEQ)
                                ((fx<?)  'IN-FXLT)
                                ((fx>?)  'IN-FXGT)
                                ((fx<=?) 'IN-FXLE)
                                ((fx>=?) 'IN-FXGE))))
                (else  (compile-normal-call fct actuals len env epair #f))))

      ((cons)   (comp2 'IN-CONS))
      ((car)    (comp1 'IN-CAR))
      ((cdr)    (comp1 'IN-CDR))
      ((null?)  (comp1 'IN-NULLP))
      ((not)    (comp1 'IN-NOT))
      ((list)   (compile-args actuals env)
                (emit 'IN-LIST len))
;;//      ((apply)  (case len
;;//              ((0)  (compile-error "no argument given to apply"))
;;//              ((1)  (compile-primitive-call fct (list (car actuals) '())
;;//                                            (+ len 1) env tail?))
;;//              (else (emit 'PREPARE-CALL)
;;//                    (compile-args (cdr actuals) env)
;;//                    (compile (car actuals) env #f)
;;//                    (emit 'IN-APPLY (- len 1) (if tail? 1 0)))))
      ((vector-ref)     (comp2 'IN-VREF))
      ((vector-set!)    (comp3 'IN-VSET))
      ((string-ref)     (comp2 'IN-SREF))
      ((string-set!)    (comp3 'IN-SSET))
      ((eq?)            (comp2 'IN-EQ))
      ((eqv?)           (comp2 'IN-EQV))
      ((equal?)         (comp2 'IN-EQUAL))
      (else             (panic "unimplemented inline primitive ~S" fct)))))



(define (compile-lambda-call fct actuals len env epair tail?)
  ;; Compilation of ( [LAMBDA(.)...] ..... )
  (let* ((fct     (extended-lambda->lambda fct))
         (formals (cadr fct))
         (body    (cddr fct))
         (arity   (compute-arity formals)))
    (if (or (= arity len)
            (and (negative? arity) (>= len (- (- arity) 1))))
        (let ((kind    (if tail? 'ENTER-TAIL-LET 'ENTER-LET))
              (new-env (extend-env env formals)))
          (generate-PREPARE-CALL epair)
          (if (negative? arity)
              (begin
                (compile-var-args actuals (- (- arity) 1) env)
                (emit kind (- arity)))
              (begin
                (compile-args actuals env)
                (emit kind len)))
          (compile-body body new-env epair tail?)
          (emit (if tail? 'RETURN 'LEAVE-LET)))
        (compiler-error 'lambda epair "bad number of parameters ~S" actuals))))


(define (compile-call args env tail?)
  (let* ((fct     (car args))
         (actuals (cdr args))
         (len     (length actuals)))
    (if (and (pair? fct) (or (eq? (car fct) 'lambda)
                          (eq? (car fct) '|Î»|)))
        ;; fct is (lambda (...) ...)
        ;;    if fct is not an epair, it is probably because it has been
        ;;    built programmatically. Anyway its body is probably an epair
        (let ((ep (cond
                    ((%epair? fct) fct)
                    ((>= (length fct) 3) (cddr fct))
                    (else fct))))
          (compile-lambda-call fct actuals len env ep tail?))
        (if (can-be-inlined? fct env)
            (compile-primitive-call fct actuals len env args tail?)
            (compile-normal-call    fct actuals len env args tail?)))))

;;;;
;;;; LET / LET* / LETREC
;;;;
(define (valid-let-bindings? bindings unique?)
  (letrec
      ((aux (lambda (l seen)
              (cond
               ((null? l) #t)
               ((pair? l) (let ((b (car l)))
                            (if (and (list? b)
                                     (= (length b) 2)
                                     (symbol? (car b)))
                                (if (and unique? (memq (car b) seen))
                                    (compiler-error 'let bindings
                                                     "duplicate binding ~S" (car b))
                                    (aux (cdr l) (cons (car b) seen)))
                                (compiler-error 'let bindings
                                                 "malformed binding ~S" b))))
               (else #f)))))
    (aux bindings '())))

;;
;; LETREC
;;

(define (compile-letrec args env tail?)
  (let ((len (length args)))
    (if (< len 3)
        (compiler-error 'letrec args "ill formed letrec ~S" args)
        (let ((bindings (cadr args))
              (body     (cddr args)))
          (if (null? bindings)
              (compile-body body env body tail?)
              (when (valid-let-bindings? bindings #t)
                (let ((tmps (map (lambda (_) (gensym)) bindings)))
                  (compile `(let ,(map (lambda (x) (list (car x) #f)) bindings)
                              (let ,(map (lambda (x y) (list x (cadr y)))
                                         tmps bindings)
                                ,@(map (lambda (x y) `(set! ,(car y) ,x))
                                       tmps bindings))
                              (let () ,@body))
                           env args tail?))))))))

;;
;; LET (& named let)
;;

(define (compile-named-let name bindings body len args env tail?)
  (if (< len 4)
      (compiler-error 'let args "ill formed named let ~S" args)
      (when (valid-let-bindings? bindings #t)
        (compile `((letrec ((,name (lambda ,(map car bindings) ,@body)))
                       ,name)
                   ,@(map cadr bindings))
                 env
                 args
                 tail?))))


(define (compile-let args env tail?)
  (let ((len (length args)))
    (if (< len 3)
        (compiler-error 'let args "ill formed let ~S" args)
        (let ((bindings (cadr args))
              (body     (cddr args)))
          (if (symbol? bindings)
              ;; Transform named let in letrec
              (compile-named-let bindings (car body) (cdr body) len args env tail?)
              (when (valid-let-bindings? bindings #t)
                (if (null? bindings)
                    (compile-body body env args tail?)
                    (compile `((lambda ,(map car bindings) ,@body)
                               ,@(map cadr bindings))
                             env args tail?))))))))

;;
;; LET*
;;

;; Here is a simple version (inefficient) of compile-let*
;;
;;    (define (compile-let* args env tail?)
;;      (let ((len (length args)))
;;        (if (< len 3)
;;      (compiler-error 'let* args "ill formed let* ~S" args)
;;      (let ((bindings (cadr args))
;;            (body     (cddr args)))
;;        (when (valid-let-bindings? bindings #f)
;;          (compile (if (<= (length bindings) 1)
;;                       `(let ,bindings ,@body)
;;                       `(let (,(car bindings))
;;                          (let* ,(cdr bindings)
;;                            ,@body)))
;;                   env args tail?))))))
;;

(define (compile-let* args env tail?)
  ;; This is a little bit tricky
  ;; We have something like
  ;; (let ((a E1) (b E2)) ...) =>
  ;;              (let ((a #f) (b #f))          [1]
  ;;                (set! a E1) (set! b E2)     [2]
  ;;                 ...)                       [3]
  ;;
  ;; For [1], we have 2 special instructions which reserve space on the stack
  ;; For [2], this is a little bit more complicate since E1 must be evaluated
  ;; in an environment without a, E2 must be evaluated in an environment with
  ;; a and without b
  ;; [3] must be evaluated in an environment where a and b are defined;
  ;;
  ;; If there are multiple definition of the same variable, it is multi-allocated
  ;; but only one slot will be used. Not a big deal, in general
  (let ((len (length args)))
    (if (< len 3)
        (compiler-error 'let* args "ill formed let* ~S" args)
        (let ((bindings (cadr args))
              (body     (cddr args)))
          (when (valid-let-bindings? bindings #f)
            (if (<= (length bindings) 1)
                (compile-let `(let ,bindings ,@body) env tail?)
                (begin
                  (emit (if tail? 'ENTER-TAIL-LET-STAR 'ENTER-LET-STAR)
                        (length bindings))
                  (let Loop ((l bindings)
                             (locals '()))
                    (if (null? l)
                        ;; Compile body
                        (let ((new-env (extend-env env locals)))
                          (compile-body body new-env body tail?)
                          (emit (if tail? 'RETURN 'LEAVE-LET)))
                        ;; Compile an assignment
                        (let* ((var (caar l))
                               (val (cadar l))
                               (loc (cons var locals)))
                          (compile val (extend-env env locals) args #f)
                          (compile-access var (extend-env env loc) args #f)
                          (Loop (cdr l)
                                loc)))))))))))

;;
;; COND
;;
(define (rewrite-cond-clauses c)
  (cond
   ((null? c)                 (void))
   ((not (pair? (car c)))     (compiler-error 'cond c "invalid clause ~S" (car c)))
   ((eq? (caar c) 'else)      (if (null? (cdr c))
                                  `(begin ,@(cdar c))
                                  (compiler-error 'cond
                                                   c
                                                   "else not in last clause ~S"
                                                   c)))
   ((and (pair? (cdar c)) (eq? (cadar c) '=>))
                              (if (and (list? (car c)) (= (length (car c)) 3))
                                  (let ((test-var (gensym)))
                                    `(let ((,test-var ,(caar c)))
                                       (if ,test-var
                                           (,(caddar c) ,test-var)
                                           ,(rewrite-cond-clauses (cdr c)))))
                                  (compiler-error 'cond
                                                   c
                                                   "bad '=>' clause syntax ~S"
                                                   (car c))))
   ((null? (cdar c))          (let ((test-var (gensym)))
                                `(let ((,test-var ,(caar c)))
                                   (or ,test-var
                                       ,(rewrite-cond-clauses (cdr c))))))
   (else                      `(if ,(caar c)
                                   (begin ,@(cdar c))
                                   ,(rewrite-cond-clauses (cdr c))))))

(define (compile-cond e env tail?)
  (let ((new-form (rewrite-cond-clauses (cdr e))))
    (compile new-form env e tail?)))

;;
;; CASE
;;

(define (rewrite-case-clauses key clauses)
  ;; Some controls on the case form
  (let ((all-values '()))
    (for-each (lambda (clause)
                (if (pair? clause)
                    (cond
                      ((eq? (car clause) 'else)
                           'ok)
                      ((pair? (car clause))
                           ;; OK but verify that there are no duplicates
                           (for-each (lambda (x)
                                       (if (memv x all-values)
                                           (compiler-error
                                               'case clause
                                               "duplicate case value ~S in ~S"
                                               x clause)))
                                     (car clause))
                           (set! all-values (append (car clause) all-values)))
                      (else
                           (compiler-error 'case clause
                                           "ill formed case clause ~S" clause)))
                    (compiler-error 'case clauses
                                    "invalid clause syntax in ~S" clause)))
              clauses))

  ;; Generate equivalent cond form
  `(cond ,@(map (lambda (clause)
                  ;; We are not sure it is a well formed clause since
                  ;; previous checks may not call error (file compilation)
                  (if (pair? clause)
                      (let* ((case   (car clause))
                             (imply? (and (pair? (cdr clause))
                                          (eqv? (cadr clause) '=>)))
                             (exprs  (if imply? (cddr clause) (cdr clause)))
                             (len    (length exprs)))
                        (if (eq? case 'else)
                            ;; else clause
                            (cond
                              ((and imply? (= len 1))     ;; (else => f)
                               `(else (,(car exprs) ,key)))
                              (imply?                     ;; (else => f ...)
                               (compiler-error 'case
                                               '=>
                                               "ill formed else clause ~S"
                                               `(else => ,@exprs)))
                               (else
                                `(else ,@exprs)))
                            ;; normal clause
                            (cond
                              ((and imply? (= len 1))     ;; ((x y) => f)
                               (if (= (length case) 1)
                                    `((eqv? ,key ',(car case)) (,(car exprs) ,key))
                                    `((memv ,key ',case)       (,(car exprs) ,key))))
                              (imply?                     ;; (else => ....)
                               (compiler-error 'case
                                               '=>
                                               "ill formed clause ~S"
                                               `(=> ,@exprs)))
                              (else
                               (if (= (length case) 1)
                                   `((eqv? ,key ',(car case)) ,@exprs)
                                   `((memv ,key ',case) ,@exprs))))))))
                clauses)))

(define (compile-case e env tail?)
  (if (> (length e) 2)
      (let* ((key     (cadr e))
             (clauses (cddr e))
             (new-form (if (pair? key)
                           (let ((newkey (gensym)))
                             `(let ((,newkey ,key))
                                ,(rewrite-case-clauses newkey clauses)))
                           (rewrite-case-clauses key clauses))))
        (compile new-form env e tail?))
      (compiler-error 'case e "no key given")))

;;
;; DO
;;
(define (rewrite-do inits test body)
  (let ((loop-name (gensym)))
    `(letrec ((,loop-name
       (lambda ,(map car inits)
         (if ,(car test)
             (begin ,@(if (null? (cdr test))
                          (list (void))
                          (cdr test)))
             (begin ,@body
                    (,loop-name ,@(map (lambda (init)
                                         (if (< (length init) 2)
                                             (compiler-error 'do
                                                              init
                                                              "bad binding ~S"
                                                              init)
                                             (if (null? (cddr init))
                                                 (car init)
                                                 (caddr init))))
                                       inits)))))))
       (,loop-name ,@(map cadr inits)))))


(define (compile-do e env tail?)
  (if (>= (length e) 3)
      (compile (rewrite-do (cadr e) (caddr e) (cdddr e))
               env
               e
               #f)
      (compiler-error 'do e "bad syntax")))

;;
;; QUASIQUOTE
;;

(define (backquotify e level)
  (cond
    ((pair? e)
       (cond
         ((eq? (car e) 'quasiquote)
               (list 'list ''quasiquote
                     (backquotify (cadr e) (+ level 1))))
         ((eq? (car e) 'unquote)
               (if (<= level 0)
                   (cadr e)
                   (list 'list ''unquote
                         (backquotify (cadr e) (- level 1)))))
         ((eq? (car e) 'unquote-splicing)
              (if (<= level 0)
                  (list 'cons
                        (backquotify (car e) level)
                        (backquotify (cdr e) level))
                  (list 'list ''unquote-splicing
                        (backquotify (cadr e) (- level 1)))))
         ((and (<= level 0) (pair? (car e)) (eq? (caar e) 'unquote-splicing))
              (if (null? (cdr e))
                  (cadar e)
                  (list 'append (cadar e)
                        (backquotify (cdr e) level))))
         (else
              (list 'cons
                    (backquotify (car e) level)
                    (backquotify (cdr e) level)))))
    ((vector? e)
       (list 'list->vector (backquotify (vector->list e) level)))
    ((symbol? e)
       (list 'quote e))
    (else
       e)))

(define (compile-quasiquote e env tail?)
  (if (= (length e) 2)
      (compile (backquotify (cadr e) 0) env e tail?)
      (compiler-error 'quasiquote e "bad syntax")))


;;
;; WITH-HANDLER
;;
(define (compile-with-handler e env tail?)
  (if (> (length e) 2)
      (let ((handler (cadr e))
            (body    (cddr e))
            (lab     (new-label)))
        (compile handler env e #f)
        (emit 'PUSH-HANDLER lab)
        (compile `(begin ,@body) env body #f)
        (emit 'POP-HANDLER)
        (emit-label lab))
      (compiler-error 'with-handler e "bad syntax")))


;;
;; INCLUDE
;;

#|
<doc EXT-SYNTAX include
 * (include <string1> <string2> ...)
 *
 * TODO
doc>
|#
(define (%include-file name)
  (let ((port (open-input-file name))
        (old  *compiler-port*))
    (with-handler (lambda (c) (set! *compiler-port* old) (raise c))
                  (set! *compiler-port* port)

                  (do ((expr (%read port) (%read port)))
                      ((eof-object? expr))
                    (compile expr '() expr #f))

                  (set! *compiler-port* old))
    (close-port port)))


(define (compile-include e env tail)
  (unless (every string? (cdr e))
    (compiler-error 'include e "bad include directive ~S" e))
  (for-each %include-file (cdr e)))

(define (compile-include-ci e env tail)
  (unless (every string? (cdr e))
    (compiler-error 'include-ci e "bad include directive ~S" e))
  (parameterize ((read-case-sensitive #f))
    (for-each %include-file (cdr e))))

;;
;; Autoloads management
;;
(define (compiler-maybe-do-autoload symb)
  (let ((file (autoload-file symb)))
    (when file
      ;; Do the autoload
      (let ((old-code *code-instr*)
            (old-cst  *code-constants*))
        (remove-autoload! symb)
        (require file)
        (set! *code-instr* old-code)
        (set! *code-constants* old-cst)))))

;;;;======================================================================
;;;;
;;;;            Special Calls
;;;;
;;;;======================================================================

;;;;
;;;; Utilities for REQUIRE / REQUIRE-FOR-SYNTAX
;;;;
(define (find-file-informations file lib-only? eventually-compile?)

  (define (compile-and-find-infos path)
    (let ((tmp (create-temp-file)))
      (compile-file path tmp)
      (let ((infos (%file-informations tmp)))
        (remove-file tmp)
        (set! infos (key-set! infos :nature 'source))
        infos)))

  (let ((path (find-path file
                         (if lib-only?
                             (list (make-path (%library-prefix)
                                              "share" "stklos"
                                              (version)))
                             (load-path)))))
    (if path
        (let ((infos (%file-informations path)))
          (if (and eventually-compile?
                   (eq? (key-get infos :nature 'unknown) 'source))
              ;; We have a source file (i.e. no info, compile it to have them)
              (parameterize ((compiler:time-display #f))
                 (compile-and-find-infos path))
              infos))
        '())))


(define (import-file-informations infos)
  (when (pair? infos)
    ;; Register all the global symbols of the file
    (for-each register-new-global! (key-get infos :globals '()))
    ;; Install the expanders of the required file
    (for-each (lambda (x)
                (let* ((name     (car x))
                       (proc     (cdr x))
                       (expander `(lambda (form e) (apply ,proc (cdr form)))))
                  (install-expander! name (eval expander) proc)))
              (key-get infos :expanders '()))))


(define (%grab-file-information str)
  (let ((info (find-file-informations str #f #f)))
    (import-file-informations info)))

;;;;
;;;; REQUIRE
;;;;
(define (compile-require e env tail)
  ;; Require is not really special (it is in fact compiled as a normal call)
  ;; We just try to add the globals of the file to the list of known
  ;; globals. This is very empiric, but it avoids to add too much false
  ;; warning when compiling a file using another one.
  (when (and (= (length e) 3)
             (string? (cadr e))
             (boolean? (caddr e)))
    (let ((infos (find-file-informations (cadr e) (caddr e) #f)))
      (import-file-informations infos)))

  (compile-normal-call (car e) (cdr e) (length e) env e tail))

;;;;
;;;; PUBLISH-SYNTAX
;;;;
(define (compile-%%pubsyntax e env tail)
  (for-each (lambda (x)
              (if (symbol? x)
                  (expander-published-add! x)
                  (error '%%publish-syntax "bad symbol ~S" x)))
            (cdr e)))

;;;;
;;;; REQUIRE-FOR-SYNTAX
;;;;
(define (compile-require4syntax e env tail)
   (if  (and (= (length e) 2)
             (string? (cadr e)))
     (with-handler
         (lambda (c) (eprintf "*** Exception while required-for-syntax ~S\n" e)
                     (raise c))
         (let ((infos (find-file-informations (cadr e) (load-path) #t)))
           (import-file-informations infos)
           (void)))
     (error 'require-for-syntax "bad form ~S" e)))


#;(define (compile-require4syntax e env tail)
  ;; No code is produced here, we only load the file for the compiler
  (with-handler
     (lambda (c)
       (eprintf "*** Exception while evaluation of required syntax ~S\n" e)
       (raise c))
     (require (cadr e))))


;;;;
;;;; WHEN-COMPILE
;;;;
(define (compile-when-compile e env tail)
  (with-handler (lambda (c)
                  (eprintf "*** Exception on when-compile form of ~S\n" e)
                  (raise c))
     (eval `(begin ,@(cdr e) (void)))))

(define-macro (when-compile . body)
  `(begin
     (%%when-compile ,@body)
     (void)))

(define-macro (when-load-and-compile . body)
  `(begin
     (%%when-compile ,@body)
     ,@body
     (void)))

(define (compile-%%label e env tail)
  (if (= (length e) 2)
      (emit-label (cadr e))
      (compiler-error '%%label e "bad usage ~S" e)))

(define (compile-%%goto e env tail)
  (if (= (length e) 2)
      (emit 'GOTO (cadr e))
      (compiler-error '%%goto e "bad usage ~S" e)))


(define (compile-%%source-pos e env tail)
  (compile (if (%epair? e)
               `(cons ,(%epair-file e) ,(%epair-line e))
               #f)
           '()
           e
           #f))

;;;;======================================================================
;;;;
;;;;            The bytecode compiler
;;;;
;;;;======================================================================
(define (compile e env epair tail?)
  (let ((e (%%macroexpand e env #t))) ;; expand macros first!
    (cond
     ;; ---- We have a pair
     ((pair? e)
      (let ((first (car e)))
        (compiler-maybe-do-autoload first)
        (if (and (symbol? first)
                 (not (symbol-in-env? first env))
                 (expander? first))
            ;; ---- Use of primitive macro (define-macro)
            (compile (macro-expand e) env epair tail?)
            
            ;; ---- special-form? function call?
            (case first
              ((if)                 (compile-if             e env tail?))
              ((define)             (compile-define         e env tail?))
              ((begin)              (compile-begin          e env tail?))
              ((lambda Î»)                (compile-lambda         e env tail?))
              ((let %let)           (compile-let            e env tail?))
              ((let*)               (compile-let*           e env tail?))
              ((letrec)             (compile-letrec         e env tail?))
              ((and)                (compile-and            e env tail?))
              ((or)                 (compile-or             e env tail?))
              ((cond)               (compile-cond           e env tail?))
              ((case)               (compile-case           e env tail?))
              ((do)                 (compile-do             e env tail?))
              ((quote)              (compile-quote          e env tail?))
              ((quasiquote)         (compile-quasiquote     e env tail?))
              ((with-handler)       (compile-with-handler   e env tail?))
              ((define-macro)       (compile-define-macro   e env tail?))
              ((%%set!)             (compile-set!           e env tail?))

              ;; Special calls
              ((%%require)          (compile-require        e env tail?))
              ((%%require4syntax)   (compile-require4syntax e env tail?))
              ((%%when-compile)     (compile-when-compile   e env tail?))
              ((%%include)          (compile-include        e env tail?))
              ((%%include-ci)       (compile-include-ci     e env tail?))
              ((%%source-pos)       (compile-%%source-pos   e env tail?))
              ((%%label)            (compile-%%label        e env tail?))
              ((%%goto)             (compile-%%goto         e env tail?))
              ((%%publish-syntax)   (compile-%%pubsyntax    e env tail?))
              
              ;; Standard call
              (else                 (compile-call           e env tail?))))))
     
     ;; ---- We have a symbol
     ((symbol? e)
      (compiler-maybe-do-autoload e)
      (compile-reference e env epair tail?))

     ;; Self evaluating object
     (else
      (compile-constant  e env tail?)))))


;=============================================================================
;
; Eval
;
;=============================================================================

(define (eval e :optional env)

  (define (parse-expression e)
    (compile e '() e #f)
    (emit 'END-OF-CODE)
    (assemble (reverse! *code-instr*)))

  (fluid-let ((*code-instr*     '())
              (*code-constants* '()))
    (let ((code (parse-expression e)))
      ;;(disassemble-code code (current-error-port))
      (%execute code (list->vector *code-constants*) (or env (current-module))))))


(define-macro (%compile-time-define . symbs)
  ;; This macro permits to add the given symbols in the list of defined symbols
  ;; to avoid the "undefined symbol" warning messages
  `(when-compile
     ,@(map (lambda(x) `(define ,x #void)) symbs)))


;; ======================================================================
(select-module STklos)
(import STKLOS-COMPILER)
(define eval (in-module STKLOS-COMPILER eval))

#|
<doc %define-syntax EXT-SYNTAX
 * (%define-syntax name expander)
 *
 * Defines a global macro which is not hygienic, but enters the same identifier
 * discipline as variable identifiers (although global, these macros are part of
 * the lexically-scoped macro system).
 *
 * @lisp
 * (%define-syntax f (lambda form -1))
 *
 * (let ((a ...))
 *   (%let-syntax ((b ...))
 *     (f)))
 * @end lisp
 *
 * In the above example, the result is |1|, because the macro name was not found in
 * the local environment (which contained |a| and |b|), but it was found in the
 * "global" environment (the current module).
 *
 * Although local macros cannot have their values used and printed, global macros
 * must be defined and have their bindings available before they can be used, so
 * one can inspect them:
 *
 * @lisp
 * (describe f)
 * #[syntax f in module stklos, of type syntax-rules]
 * Slots are: 
 *   type = lambda
 *   name = f
 *   expander = (lambda form -1)
 *   compiled-expander = #[closure 7f03b1887500]
 *   environment = ()
 *   module = #[module stklos]
 * @end lisp
 *
 * These are always instances of the structure |<syntax>|, defined in the module
 * |STKLOS-COMPILER|. In fact, another (cumbersome) way to create a macro like this
 * is to create an instance of such structure:
 *
 * @lisp
 * (define f ((in-module STKLOS-COMPILER make-<syntax>)
 *            'lambda
 *            'f
 *            '(lambda form -1)
 *            (eval '(lambda form -1))
 *            '()
 *            (current-module)))
 * @end lisp
 *
 * When the compiler looks at a form, it will first check if its |car| is
 * bound in the environment that was used when the compiler was called,
 * see if it is an object of this type, and it it is, the form will be
 * expanded using the |compiled-expander| field.
doc>
|#
(define-macro %define-syntax
  (lambda (name . e)
    (let ((expander (car e)))
      (let ((compiled-expander (eval expander)))
        `(define ,name ((in-module STKLOS-COMPILER make-<syntax>)
                        'lambda
                        ',name
                        ',expander
                        (eval ',expander (find-module ',(module-name (current-module))))
                        ()
                        (current-module)))))))


;;)
; LocalWords:  initform autoload Autoloads
