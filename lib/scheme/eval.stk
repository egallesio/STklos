;;;;
;;;;
;;;; eval.stk         -- The (scheme eval) R7RS library
;;;;
;;;; Copyright Â© 2021 Erick Gallesio - I3S-CNRS/Polytech Nice-Sophia <eg@unice.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date:  8-Oct-2021 11:15
;;;; Last file update:  8-Oct-2021 11:20 (eg)
;;;;

(define-module scheme/eval
  (export environment)
  (%module-define-and-export eval))

#|
<doc environment
 * (environment [name] lib1 lib2 ...)
 *
 * This procedure returns a specifier for the environment that
 * results by starting with an empty environment and then
 * importing each lib (list or symbol), considered as an import
 * set, into it. The bindings of the environment represented by
 * the specifier, as is the environment itself.
 *
 * In STklos,
 * - each |lib| argument can be a list (specifying an R7RS
 *   library) or a symbol (specifying a module).
 * - the return environment is an R7RS library (which can be
 *   passed to |eval|).
 * - if |name| is a string, it will be set as the new environment
 *   (library) name.
doc>
|#
(define (environment . args)

  (define (check-module-names args)
    (for-each (lambda (arg)
                (unless (or (symbol? arg) (list? arg))
                  (error "bad library or module name ~S" arg)))
              args))

  ;; Given a list of library or module names, return a list of
  ;; modules.
  (define (get-modules-from-names args)
    (map (lambda (arg)
           (let ((m (find-module arg #f)))
             (if m m (error "bad library or module ~S" arg))))
         (map %library-name->symbol args)))

  ;; The user can include a name as first argument
  (let ((name (if (and (pair? args) (string? (car args)))
                  (let ((n (string->symbol (car args))))
                    (set! args (cdr args))
                    n)
                  (gensym "unnamed-module-"))))

    ;; Null environment?
    (if (null? args)
        (find-module 'NULL-MODULE)
        
        (begin
          (check-module-names args)
          
          (let ((new-imported-modules (get-modules-from-names args)))
            
            ;; We create an R7RS library. Not a STklos module, since it would
            ;; then import more than we'd like.
            ;; FIXME: is eval a good idea here?
            (eval `(define-library ,name))
            (let ((new (eval `(find-module (quote ,(string->symbol (symbol->string name)))))))
              (let ((new-exported-symbols
                     
                     (let loop ((exp-list '())
                                (new-imported-modules new-imported-modules))
                       
                       (let* ((mod (car new-imported-modules))
                              (mod-exported (map car (module-exports mod))))
                           
                         ;; Append here is not efficient, but... How many
                         ;; modules and exported symbols will one include here?
                         (let ((new-exported
                                (append mod-exported exp-list)))
                           
                           ;; define the symbol in the module
                           (for-each (lambda (sym)
                                       (%symbol-define sym (symbol-value sym mod) new))
                                     mod-exported)
                             (if (null? (cdr new-imported-modules))
                                 new-exported
                                 (loop new-exported
                                       (cdr new-imported-modules))))))))
                
                ;; The module is populated! We can now set its exported
                ;; symbols and imported modules. (Setting the imported modules
                ;; is relevant, because the standard says it should behave
                ;; "starting with an empty environment and then importing each
                ;; list, considered as an import set, into it" -- which would
                ;; set the import list of the module).
                (%module-exports-set! new new-exported-symbols)
                (%module-imports-set! new new-imported-modules)

                (module-lock! new)  ;; immutability required by the standard

                new)))))))
    


(provide "scheme/eval")

