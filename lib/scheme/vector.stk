;;;;
;;;;
;;;; vector.stk         -- Implementation of (scheme vector) aka SRFI-133
;;;;
;;;; Copyright Â© 2021 Jeronimo Pellegrini - j_p@aleph0.info
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;; This file is a derivative work from the sample implementation of
;;;; this SRFI by Taylor Campbel, Will Clinger and John Cowan. It is
;;;; Copyrighted as

;;;;; Taylor Campbell wrote this code; he places it in the public domain.
;;;;; Will Clinger [wdc] made some corrections, also in the public domain.
;;;;; John Cowan modified this code for SRFI 133; his changes are also in
;;;;; the public domain.  However, in jurisdictions where it is not possible
;;;;; to dedicate something to the public domain, the entire implementation
;;;;; is made available under the same license as SRFI 133.
;;;;;
;;;;; License of the SRFI:
;;;;;
;;;;; Copyright (C) Taylor Campbell (2003). All rights reserved.
;;;;;
;;;;; Permission is hereby granted, free of charge, to any person obtaining
;;;;; a copy of this software and associated documentation
;;;;; files (the "Software"), to deal in the Software without restriction,
;;;;; including without limitation the rights to use, copy, modify, merge,
;;;;; publish, distribute, sublicense, and/or sell copies of the Software,
;;;;; and to permit persons to whom the Software is furnished to do so,
;;;;; subject to the following conditions:
;;;;;
;;;;; The above copyright notice and this permission notice shall be
;;;;; included in all copies or substantial portions of the Software.
;;;;;
;;;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;;;;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
;;;;; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
;;;;; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
;;;;; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

;;;;           Author: Jeronimo Pellegrini [j_p@aleph0.info]
;;;;    Creation date: 16-Jul-2020 10:20
;;;;

(select-module scheme/vector)

;;;
;;; NOTE: when an exported symbol is already defined in STklos, we
;;; actually define it inside the module, as in
;;;
;;; (define vector-fill! (symbol-value 'vector-fill! scheme))
;;;
;;; because otherwise SRFI-133 would require the SCHEME (or STklos)
;;; module in order to work. Also, if someone changed the binding of
;;; vector-fill!, for example, in module STklos, and SRFI-133 counts on
;;; its original binding, then SRFI-133 will not behave as intended.
;;;
;;; --jpellegrini
;;;
;;; Now, instead of typing the entire the define with symbol-value line,
;;; we make a little convenience macro:

(define-syntax from-scheme
  (syntax-rules ()
    ((_ name)
     (define name (symbol-value (quote name) scheme)))))

(define scheme (find-module 'SCHEME))



;; Now we do "(from-scheme vector-fill!)", and the binding is imported.

;; Also, we need to explicitly export the bindings!

(export vector-copy
        vector-append
        vector-map
        vector-for-each
        vector-fill!
        vector-copy!
        vector->list
        list->vector
        vector->string)



;; Pseudo-define the primitives defined in C to avoid compiler warnings
(%compile-time-define check-index vector-parse-start+end %smallest-length
                      %vector-copy! %vector-reverse-copy! %vector-reverse!
                      %vector-fold1 %vector-fold2+ %vector-map1!
                      %vector-map2+! vector-empty?)


  ;; Constructors
(export vector-unfold vector-unfold-right vector-reverse-copy
          vector-concatenate vector-append-subvectors)
;; Predicates
  (export vector-empty? vector=)
  ;; Iteration
  (export vector-fold vector-fold-right vector-map!
          vector-count vector-cumulate)
  ;; Searching
  (export vector-index vector-index-right vector-skip vector-skip-right
          vector-binary-search vector-any vector-every vector-partition)
  ;; Mutators
  (export vector-swap! vector-reverse!
          vector-reverse-copy! vector-unfold! vector-unfold-right!)
  ;; Conversion
  (export reverse-vector->list reverse-list->vector)

;; Maybe implement in C in the future:
;; vector-empty?          -- DONE
;; vector-index           -- DONE
;; vector-parse-start+end -- DONE
;; %vector-reverse!       -- DONE
;; %vector-fold1          -- DONE
;; %vector-fold2+         -- DONE
;; %vector-map1!          -- DONE
;; %vector-map2+!         -- DONE


;;; --------------------
;;; Error checking

;;; Error signalling (not checking) is done in a way that tries to be
;;; as helpful to the person who gets the debugging prompt as possible.
;;; That said, error _checking_ tries to be as unredundant as possible.

;;; I don't use any sort of general condition mechanism; I use simply
;;; SRFI 23's ERROR, even in cases where it might be better to use such
;;; a general condition mechanism.  Fix that when porting this to a
;;; Scheme implementation that has its own condition system.

;;; In argument checks, upon receiving an invalid argument, the checker
;;; procedure recursively calls itself, but in one of the arguments to
;;; itself is a call to ERROR; this mechanism is used in the hopes that
;;; the user may be thrown into a debugger prompt, proceed with another
;;; value, and let it be checked again.

;;; Type checking is pretty basic, but easily factored out and replaced
;;; with whatever your implementation's preferred type checking method
;;; is.  I doubt there will be many other methods of index checking,
;;; though the index checkers might be better implemented natively.

;;; (CHECK-TYPE <type-predicate?> <value> <callee>) -> value
;;;   Ensure that VALUE satisfies TYPE-PREDICATE?; if not, signal an
;;;   error stating that VALUE did not satisfy TYPE-PREDICATE?, showing
;;;   that this happened while calling CALLEE.  Return VALUE if no
;;;   error was signalled.


;;; Not the best LET*-OPTIONALS, but not the worst, either.  Use Olin's
;;; if it's available to you.
(define-syntax let*-optionals
  (syntax-rules ()
    ((let*-optionals (?x ...) ((?var ?default) ...) ?body1 ?body2 ...)
     (let ((args (?x ...)))
       (let*-optionals args ((?var ?default) ...) ?body1 ?body2 ...)))
    ((let*-optionals ?args ((?var ?default) ...) ?body1 ?body2 ...)
     (let*-optionals:aux ?args ?args ((?var ?default) ...)
       ?body1 ?body2 ...))))

(define-syntax let*-optionals:aux
  (syntax-rules ()
    ((aux ?orig-args-var ?args-var () ?body1 ?body2 ...)
     (if (null? ?args-var)
         (let () ?body1 ?body2 ...)
         (error "too many arguments" (length ?orig-args-var)
                ?orig-args-var)))
    ((aux ?orig-args-var ?args-var
         ((?var ?default) ?more ...)
       ?body1 ?body2 ...)
     (if (null? ?args-var)
         (let* ((?var ?default) ?more ...) ?body1 ?body2 ...)
         (let ((?var (car ?args-var))
               (new-args (cdr ?args-var)))
           (let*-optionals:aux ?orig-args-var new-args
               (?more ...)
             ?body1 ?body2 ...))))))

(define (nonneg-int? x)
  (and (integer? x)
       (not (negative? x))))

(define (between? x y z)
  (and (<  x y)
       (<= y z)))

(define (unspecified-value) (if #f #f))

;++ This should be implemented more efficiently.  It shouldn't cons a
;++ closure, and the cons cells used in the loops when using this could
;++ be reused.
(define (vectors-ref vectors i)
  (map (lambda (v) (vector-ref v i)) vectors))

(define (check-type pred? value callee)
  (if (pred? value)
      value
      ;; Recur: when (or if) the user gets a debugger prompt, he can
      ;; proceed where the call to ERROR was with the correct value.
      (check-type pred?
                  (error callee "erroneous value"
                         (list pred? value))
                  callee)))

;;; (CHECK-INDEX <vector> <index> <callee>) -> index ; implemented as primitive
;;; (CHECK-INDICES <vector>
;;;                <start> <start-name>
;;;                <end> <end-name>
;;;                <caller>) -> [start end]          ; implemented as primitive
;;; (VECTOR-PARSE-START+END <vector> <arguments>
;;;                         <start-name> <end-name>
;;;                         <callee>) -> [start end] ; implemented as primitive

(define-syntax let-vector-start+end
  (syntax-rules ()
    ((let-vector-start+end ?callee ?vec ?args (?start ?end)
       ?body1 ?body2 ...)
     (let ((?vec (check-type vector? ?vec ?callee)))
       (receive (?start ?end)
                (vector-parse-start+end ?vec ?args '?start '?end
                                        ?callee)
         ?body1 ?body2 ...)))))


;;; (%SMALLEST-LENGTH <vector-list> <default-length> <callee>)         ; implemented as primitive
;;; (%VECTOR-COPY! <target> <tstart> <source> <sstart> <send>)         ; implemented as primitive
;;; (%VECTOR-REVERSE-COPY! <target> <tstart> <source> <sstart> <send>) ; implemented as primitive
;;; (%VECTOR-REVERSE! <vector> <start> <end>)                          ; implemented as primitive
;;; (%VECTOR-FOLD1 <kons> <knil> <vector>)                             ; implemented as primitive
;;; (%VECTOR-FOLD2+ <kons> <knil> <vector> ...) -> knil'               ; implemented as primitive
;;; (%VECTOR-MAP1! <f> <target> <length> <vector>) -> target           ; implemented as primitive
;;; (%VECTOR-MAP2+! <f> <target> <vectors> <len>) -> target            ; implemented as primitive


;;;;;;;;;;;;;;;;;;;;;;;; ***** vector-lib ***** ;;;;;;;;;;;;;;;;;;;;;;;

;;; --------------------
;;; Constructors

;;; (VECTOR-UNFOLD <f> <length> <initial-seed> ...) -> vector
;;;     (F <index> <seed> ...) -> [elt seed' ...]
;;;   The fundamental vector constructor.  Creates a vector whose
;;;   length is LENGTH and iterates across each index K between 0 and
;;;   LENGTH, applying F at each iteration to the current index and the
;;;   current seeds to receive N+1 values: first, the element to put in
;;;   the Kth slot and then N new seeds for the next iteration.
(define (vector-unfold f length . initial-seeds)
  (define vec (make-vector length))
  (apply vector-unfold! f vec 0 length initial-seeds)
  vec)

;;; (VECTOR-UNFOLD! <vec> <start> <end> <f> <initial-seed> ...) -> vector
;;;     (F <index> <seed> ...) -> [elt seed' ...]
;;;   Like VECTOR-UNFOLD, but unfolds onto an existing vector starting
;;;   at <start> up to but not including <end>.
(define vector-unfold!
  (letrec ((tabulate!                   ; Special zero-seed case.
            (lambda (f vec i len)
              (cond ((< i len)
                     (vector-set! vec i (f i))
                     (tabulate! f vec (+ i 1) len)))))
           (unfold1!                    ; Fast path for one seed.
            (lambda (f vec i len seed)
              (if (< i len)
                  (receive (elt new-seed)
                           (f i seed)
                    (vector-set! vec i elt)
                    (unfold1! f vec (+ i 1) len new-seed)))))
           (unfold2+!                   ; Slower variant for N seeds.
            (lambda (f vec i len seeds)
              (if (< i len)
                  (receive (elt . new-seeds)
                           (apply f i seeds)
                    (vector-set! vec i elt)
                    (unfold2+! f vec (+ i 1) len new-seeds))))))
    (lambda (f vec start end . initial-seeds)
      (let ((f     (check-type procedure?  f   'vector-unfold!))
            (start (check-type nonneg-int? start 'vector-unfold!))
            (end   (check-type nonneg-int? end 'vector-unfold!)))
        (let ()
          (cond ((null? initial-seeds)
                 (tabulate! f vec start end))
                ((null? (cdr initial-seeds))
                 (unfold1! f vec start end (car initial-seeds)))
                (else
                 (unfold2+! f vec start end initial-seeds))))))))

;;; (VECTOR-UNFOLD-RIGHT <f> <length> <initial-seed> ...) -> vector
;;;     (F <seed> ...) -> [seed' ...]
;;;   Like VECTOR-UNFOLD, but it generates elements from LENGTH to 0
;;;   (still exclusive with  LENGTH and inclusive with 0), not 0 to
;;;   LENGTH as with VECTOR-UNFOLD.
(define (vector-unfold-right f len . initial-seeds)
  (define vec (make-vector len))
  (apply vector-unfold-right! f vec 0 len initial-seeds)
  vec)

;;; (VECTOR-UNFOLD-RIGHT! <vec> <start> <end> <f> <initial-seed> ...) -> vector
;;;   Like VECTOR-UNFOLD-RIGHT, but unfolds onto an existing vector.
(define (vector-unfold-right! f vec start end . initial-seeds)
  (letrec ((tabulate!
            (lambda (f vec i)
              (cond ((>= i start)
                     (vector-set! vec i (f i))
                     (tabulate! f vec (- i 1))))))
           (unfold1!
            (lambda (f vec i seed)
              (if (>= i start)
                  (receive (elt new-seed)
                           (f i seed)
                    (vector-set! vec i elt)
                    (unfold1! f vec (- i 1) new-seed)))))
           (unfold2+!
            (lambda (f vec i seeds)
              (if (>= i start)
                  (receive (elt . new-seeds)
                           (apply f i seeds)
                    (vector-set! vec i elt)
                    (unfold2+! f vec (- i 1) new-seeds))))))
      (let ((f     (check-type procedure?  f     'vector-unfold-right!))
            (start (check-type nonneg-int? start 'vector-unfold-right!))
            (end   (check-type nonneg-int? end   'vector-unfold-right!)))
        (let ((i (- end 1)))
          (cond ((null? initial-seeds)
                 (tabulate! f vec i))
                ((null? (cdr initial-seeds))
                 (unfold1!  f vec i (car initial-seeds)))
                (else
                 (unfold2+! f vec i initial-seeds)))))))

;;;; ALREADY IN STklos:
;;; (VECTOR-COPY <vector> [<start> <end> <fill>]) -> vector
;;;   Create a newly allocated vector containing the elements from the
;;;   range [START,END) in VECTOR.  START defaults to 0; END defaults
;;;   to the length of VECTOR.  END may be greater than the length of
;;;   VECTOR, in which case the vector is enlarged; if FILL is passed,
;;;   the new locations from which there is no respective element in
;;;   VECTOR are filled with FILL.

(from-scheme vector-copy)


;;; (VECTOR-REVERSE-COPY <vector> [<start> <end>]) -> vector
;;;   Create a newly allocated vector whose elements are the reversed
;;;   sequence of elements between START and END in VECTOR.  START's
;;;   default is 0; END's default is the length of VECTOR.
(define (vector-reverse-copy vec . maybe-start+end)
  (let-vector-start+end 'vector-reverse-copy vec maybe-start+end
                        (start end)
    (let ((new (make-vector (- end start))))
      (%vector-reverse-copy! new 0 vec start end)
      new)))

;;; (VECTOR-CONCATENATE <vector-list>) -> vector
;;;   Concatenate the vectors in VECTOR-LIST.  This is equivalent to
;;;     (apply vector-append VECTOR-LIST)
;;;   but VECTOR-APPEND tends to be implemented in terms of
;;;   VECTOR-CONCATENATE, and some Schemes bork when the list to apply
;;;   a function to is too long.
;;;
;;; CHANGED to use STklos' embeddeed vector-append, written in C:
(define (vector-concatenate vector-list)
  (apply vector-append vector-list))

;;;; ALREADY IN STklos:
;;; (VECTOR-APPEND <vector> ...) -> vector
;;;   Append VECTOR ... into a newly allocated vector and return that
;;;   new vector.

(from-scheme vector-append)


;;; (VECTOR-APPEND-SUBVECTORS <arg> ...) -> vector
;;;   Like VECTOR-APPEND but appends subvectors specified by
;;;   <vector> <start> <end> argument triples.
(define (vector-append-subvectors . args)
  ;; GATHER-ARGS returns three values: vectors, starts, ends
  (define (gather-args args)
    (let loop ((args args) (vecs '()) (starts '()) (ends '()))
      (if (null? args)
         (values (reverse vecs) (reverse starts) (reverse ends))
         (loop (cdddr args)
               (cons (car args) vecs)
               (cons (cadr args) starts)
               (cons (caddr args) ends)))))
  ;; TOTAL-LENGTH computes the length of all subvectors
  (define (total-length starts ends)
    (let loop ((count 0) (starts starts) (ends ends))
      (if (null? starts)
        count
        (let ((start (car starts)) (end (car ends)))
          (loop (+ count (- end start))
                (cdr starts)
                (cdr ends))))))
 ;; COPY-EACH! copies each subvector into a result vector
  (define (copy-each! result vecs starts ends)
    (let loop ((at 0) (vecs vecs) (starts starts) (ends ends))
      (if (null? vecs)
        result
        (let ((vec (car vecs)) (start (car starts)) (end (car ends)))
          (%vector-copy! result at vec start end)
          (loop (+ at (- end start))
                (cdr vecs)
                (cdr starts)
                (cdr ends))))))
  ;; put them all together, they spell VECTOR-APPEND-SUBVECTORS
  (receive (vecs starts ends) (gather-args args)
    (define result (make-vector (total-length starts ends)))
    (copy-each! result vecs starts ends)))

;;; --------------------
;;; Predicates

;;; (VECTOR-EMPTY? <vector>) -> boolean ; implemented as primitive

;;; (VECTOR= <elt=?> <vector> ...) -> boolean
;;;     (ELT=? <value> <value>) -> boolean
;;;   Determine vector equality generalized across element comparators.
;;;   Vectors A and B are equal iff their lengths are the same and for
;;;   each respective elements E_a and E_b (elt=? E_a E_b) returns a
;;;   true value.  ELT=? is always applied to two arguments.
;;;
;;;   If the number of vector arguments is zero or one, then #T is
;;;   automatically returned.  If there are N vector arguments,
;;;   VECTOR_1 VECTOR_2 ... VECTOR_N, then VECTOR_1 & VECTOR_2 are
;;;   compared; if they are equal, the vectors VECTOR_2 ... VECTOR_N
;;;   are compared.  The precise order in which ELT=? is applied is not
;;;   specified.
(define (vector= elt=? . vectors)
  (let ((elt=? (check-type procedure? elt=? 'vector=)))
    (cond ((null? vectors)
           #t)
          ((null? (cdr vectors))
           (check-type vector? (car vectors) 'vector=)
           #t)
          (else
           (let loop ((vecs vectors))
             (let ((vec1 (check-type vector? (car vecs) 'vector=))
                   (vec2+ (cdr vecs)))
               (or (null? vec2+)
                   (and (binary-vector= elt=? vec1 (car vec2+))
                        (loop vec2+)))))))))

(define (binary-vector= elt=? vector-a vector-b)
  (let ((length-a (vector-length vector-a))
        (length-b (vector-length vector-b)))
    (and (= length-a length-b)
         (let loop ((i 0))
           (cond
             ((= i length-a) #t)
             ((elt=?
                (vector-ref vector-a i)
                (vector-ref vector-b i))
              (loop (+ i 1)))
             (else #f))))))

;;; --------------------
;;; Selectors



;;; --------------------
;;; Iteration

;;; (VECTOR-FOLD <kons> <initial-knil> <vector> ...) -> knil
;;;     (KONS <knil> <elt> ...) -> knil' ; N vectors -> N+1 args
;;;   The fundamental vector iterator.  KONS is iterated over each
;;;   index in all of the vectors in parallel, stopping at the end of
;;;   the shortest; KONS is applied to an argument list of (list I
;;;   STATE (vector-ref VEC I) ...), where STATE is the current state
;;;   value -- the state value begins with KNIL and becomes whatever
;;;   KONS returned at the respective iteration --, and I is the
;;;   current index in the iteration.  The iteration is strictly left-
;;;   to-right.
;;;     (vector-fold KONS KNIL (vector E_1 E_2 ... E_N))
;;;       <=>
;;;     (KONS (... (KONS (KONS KNIL E_1) E_2) ... E_N-1) E_N)
(define (vector-fold kons knil vec . vectors)
  (let ((kons (check-type procedure? kons 'vector-fold))
        (vec  (check-type vector?    vec  'vector-fold)))
    (if (null? vectors)
        (%vector-fold1 kons knil (vector-length vec) vec)
        (%vector-fold2+ kons knil
                        (%smallest-length vectors
                                          (vector-length vec)
                                          'vector-fold)
                        (cons vec vectors)))))

;;; (VECTOR-FOLD-RIGHT <kons> <initial-knil> <vector> ...) -> knil
;;;     (KONS <knil> <elt> ...) -> knil' ; N vectors => N+1 args
;;;   The fundamental vector recursor.  Iterates in parallel across
;;;   VECTOR ... right to left, applying KONS to the elements and the
;;;   current state value; the state value becomes what KONS returns
;;;   at each next iteration.  KNIL is the initial state value.
;;;     (vector-fold-right KONS KNIL (vector E_1 E_2 ... E_N))
;;;       <=>
;;;     (KONS (... (KONS (KONS KNIL E_N) E_N-1) ... E_2) E_1)
;;;
;;; Not implemented in terms of a more primitive operations that might
;;; called %VECTOR-FOLD-RIGHT due to the fact that it wouldn't be very
;;; useful elsewhere.
(define vector-fold-right
  (letrec ((loop1 (lambda (kons knil vec i)
                    (if (negative? i)
                        knil
                        (loop1 kons (kons knil (vector-ref vec i))
                               vec
                               (- i 1)))))
           (loop2+ (lambda (kons knil vectors i)
                     (if (negative? i)
                         knil
                         (loop2+ kons
                                 (apply kons knil
                                        (vectors-ref vectors i))
                                 vectors
                                 (- i 1))))))
    (lambda (kons knil vec . vectors)
      (let ((kons (check-type procedure? kons 'vector-fold-right))
            (vec  (check-type vector?    vec  'vector-fold-right)))
        (if (null? vectors)
            (loop1  kons knil vec (- (vector-length vec) 1))
            (loop2+ kons knil (cons vec vectors)
                    (- (%smallest-length vectors
                                         (vector-length vec)
                                         'vector-fold-right)
                       1)))))))

;;;; ALREADY IN STklos:
;;; (VECTOR-MAP <f> <vector> ...) -> vector
;;;     (F <elt> ...) -> value ; N vectors -> N args
;;;   Constructs a new vector of the shortest length of the vector
;;;   arguments.  Each element at index I of the new vector is mapped
;;;   from the old vectors by (F I (vector-ref VECTOR I) ...).  The
;;;   dynamic order of application of F is unspecified.

(from-scheme vector-map)


;;; (VECTOR-MAP! <f> <vector> ...) -> unspecified
;;;     (F <elt> ...) -> element' ; N vectors -> N args
;;;   Similar to VECTOR-MAP, but rather than mapping the new elements
;;;   into a new vector, the new mapped elements are destructively
;;;   inserted into the first vector.  Again, the dynamic order of
;;;   application of F is unspecified, so it is dangerous for F to
;;;   manipulate the first VECTOR.
(define (vector-map! f vec . vectors)
  (let ((f   (check-type procedure? f   'vector-map!))
        (vec (check-type vector?    vec 'vector-map!)))
    (if (null? vectors)
        (%vector-map1!  f vec vec (vector-length vec))
        (%vector-map2+! f vec (cons vec vectors)
                        (%smallest-length vectors
                                          (vector-length vec)
                                          'vector-map!)))
    (unspecified-value)))

;;;; ALREADY IN STklos:
;;; (VECTOR-FOR-EACH <f> <vector> ...) -> unspecified
;;;     (F <elt> ...) ; N vectors -> N args
;;;   Simple vector iterator: applies F to each index in the range [0,
;;;   LENGTH), where LENGTH is the length of the smallest vector
;;;   argument passed, and the respective element at that index.  In
;;;   contrast with VECTOR-MAP, F is reliably applied to each
;;;   subsequent elements, starting at index 0 from left to right, in
;;;   the vectors.

(from-scheme vector-for-each)


;;; (VECTOR-COUNT <predicate?> <vector> ...)
;;;       -> exact, nonnegative integer
;;;     (PREDICATE? <value> ...) ; N vectors -> N args
;;;   PREDICATE? is applied element-wise to the elements of VECTOR ...,
;;;   and a count is tallied of the number of elements for which a
;;;   true value is produced by PREDICATE?.  This count is returned.
(define (vector-count pred? vec . vectors)
  (let ((pred? (check-type procedure? pred? 'vector-count))
        (vec   (check-type vector?    vec   'vector-count)))
    (if (null? vectors)
        (%vector-fold1 (lambda (count elt)
                         (if (pred? elt)
                             (+ count 1)
                             count))
                       0
                       (vector-length vec)
                       vec)
        (%vector-fold2+ (lambda (count . elts)
                          (if (apply pred? elts)
                              (+ count 1)
                              count))
                        0
                        (%smallest-length vectors
                                          (vector-length vec)
                                          'vector-count)
                        (cons vec vectors)))))

;;; (VECTOR-CUMULATE <f> <knil> <vector>)
;;;       -> vector
;;;   Returns a <new>ly allocated vector <new> with the same length as
;;;   <vec>. Each element <i> of <new> is set to the result of invoking <f> on
;;;   <new>[i-1] and <vec>[i], except that for the first call on <f>, the first
;;;   argument is <knil>. The <new> vector is returned.
(define (vector-cumulate f knil vec)
  (let* ((len (vector-length vec))
         (result (make-vector len)))
    (let loop ((i 0) (left knil))
      (if (= i len)
        result
        (let* ((right (vector-ref vec i)) (r (f left right)))
          (vector-set! result i r)
          (loop (+ i 1) r))))))

;;; --------------------
;;; Searching

;;; (VECTOR-INDEX <predicate?> <vector> ...)
;;;       -> exact, nonnegative integer or #F
;;;     (PREDICATE? <elt> ...) -> boolean ; N vectors -> N args
;;;   Search left-to-right across VECTOR ... in parallel, returning the
;;;   index of the first set of values VALUE ... such that (PREDICATE?
;;;   VALUE ...) returns a true value; if no such set of elements is
;;;   reached, return #F.
(define (vector-index pred? vec . vectors)
  (vector-index/skip pred? vec vectors vector-index))

;;; (VECTOR-SKIP <predicate?> <vector> ...)
;;;       -> exact, nonnegative integer or #F
;;;     (PREDICATE? <elt> ...) -> boolean ; N vectors -> N args
;;;   (vector-index (lambda elts (not (apply PREDICATE? elts)))
;;;                 VECTOR ...)
;;;   Like VECTOR-INDEX, but find the index of the first set of values
;;;   that do _not_ satisfy PREDICATE?.
(define (vector-skip pred? vec . vectors)
  (vector-index/skip (lambda elts (not (apply pred? elts)))
                     vec vectors
                     vector-skip))

;;; Auxiliary for VECTOR-INDEX & VECTOR-SKIP
(define vector-index/skip
  (letrec ((loop1  (lambda (pred? vec len i)
                     (cond ((= i len) #f)
                           ((pred? (vector-ref vec i)) i)
                           (else (loop1 pred? vec len (+ i 1))))))
           (loop2+ (lambda (pred? vectors len i)
                     (cond ((= i len) #f)
                           ((apply pred? (vectors-ref vectors i)) i)
                           (else (loop2+ pred? vectors len
                                         (+ i 1)))))))
    (lambda (pred? vec vectors callee)
      (let ((pred? (check-type procedure? pred? callee))
            (vec   (check-type vector?    vec   callee)))
        (if (null? vectors)
            (loop1 pred? vec (vector-length vec) 0)
            (loop2+ pred? (cons vec vectors)
                    (%smallest-length vectors
                                      (vector-length vec)
                                      callee)
                    0))))))

;;; (VECTOR-INDEX-RIGHT <predicate?> <vector> ...)
;;;       -> exact, nonnegative integer or #F
;;;     (PREDICATE? <elt> ...) -> boolean ; N vectors -> N args
;;;   Right-to-left variant of VECTOR-INDEX.
(define (vector-index-right pred? vec . vectors)
  (vector-index/skip-right pred? vec vectors vector-index-right))


;;; (VECTOR-SKIP-RIGHT <predicate?> <vector> ...)
;;;       -> exact, nonnegative integer or #F
;;;     (PREDICATE? <elt> ...) -> boolean ; N vectors -> N args
;;;   Right-to-left variant of VECTOR-SKIP.
(define (vector-skip-right pred? vec . vectors)
  (vector-index/skip-right (lambda elts (not (apply pred? elts)))
                           vec vectors
                           vector-index-right))

(define vector-index/skip-right
  (letrec ((loop1  (lambda (pred? vec i)
                     (cond ((negative? i) #f)
                           ((pred? (vector-ref vec i)) i)
                           (else (loop1 pred? vec (- i 1))))))
           (loop2+ (lambda (pred? vectors i)
                     (cond ((negative? i) #f)
                           ((apply pred? (vectors-ref vectors i)) i)
                           (else (loop2+ pred? vectors (- i 1)))))))
    (lambda (pred? vec vectors callee)
      (let ((pred? (check-type procedure? pred? callee))
            (vec   (check-type vector?    vec   callee)))
        (if (null? vectors)
            (loop1 pred? vec (- (vector-length vec) 1))
            (loop2+ pred? (cons vec vectors)
                    (- (%smallest-length vectors
                                         (vector-length vec)
                                         callee)
                       1)))))))

;;; (VECTOR-BINARY-SEARCH <vector> <value> <cmp> [<start> <end>])
;;;       -> exact, nonnegative integer or #F
;;;     (CMP <value1> <value2>) -> integer
;;;       positive -> VALUE1 > VALUE2
;;;       zero     -> VALUE1 = VALUE2
;;;       negative -> VALUE1 < VALUE2
;;;   Perform a binary search through VECTOR for VALUE, comparing each
;;;   element to VALUE with CMP.
(define (vector-binary-search vec value cmp . maybe-start+end)
  (let ((cmp (check-type procedure? cmp 'vector-binary-search)))
    (let-vector-start+end 'vector-binary-search vec maybe-start+end
                          (start end)
      (let loop ((start start) (end end) (j #f))
        (let ((i (quotient (+ start end) 2)))
          (if (or (= start end) (and j (= i j)))
              #f
              (let ((comparison
                     (check-type integer?
                                 (cmp (vector-ref vec i) value)
                                 `(,cmp for vector-binary-search))))
                (cond ((zero?     comparison) i)
                      ((positive? comparison) (loop start i i))
                      (else                   (loop i end i))))))))))

;;; (VECTOR-ANY <pred?> <vector> ...) -> value
;;;   Apply PRED? to each parallel element in each VECTOR ...; if PRED?
;;;   should ever return a true value, immediately stop and return that
;;;   value; otherwise, when the shortest vector runs out, return #F.
;;;   The iteration and order of application of PRED? across elements
;;;   is of the vectors is strictly left-to-right.
(define vector-any
  (letrec ((loop1 (lambda (pred? vec i len len-1)
                    (and (not (= i len))
                         (if (= i len-1)
                             (pred? (vector-ref vec i))
                             (or (pred? (vector-ref vec i))
                                 (loop1 pred? vec (+ i 1)
                                        len len-1))))))
           (loop2+ (lambda (pred? vectors i len len-1)
                     (and (not (= i len))
                          (if (= i len-1)
                              (apply pred? (vectors-ref vectors i))
                              (or (apply pred? (vectors-ref vectors i))
                                  (loop2+ pred? vectors (+ i 1)
                                         len len-1)))))))
    (lambda (pred? vec . vectors)
      (let ((pred? (check-type procedure? pred? 'vector-any))
            (vec   (check-type vector?    vec   'vector-any)))
        (if (null? vectors)
            (let ((len (vector-length vec)))
              (loop1 pred? vec 0 len (- len 1)))
            (let ((len (%smallest-length vectors
                                         (vector-length vec)
                                         'vector-any)))
              (loop2+ pred? (cons vec vectors) 0 len (- len 1))))))))

;;; (VECTOR-EVERY <pred?> <vector> ...) -> value
;;;   Apply PRED? to each parallel value in each VECTOR ...; if PRED?
;;;   should ever return #F, immediately stop and return #F; otherwise,
;;;   if PRED? should return a true value for each element, stopping at
;;;   the end of the shortest vector, return the last value that PRED?
;;;   returned.  In the case that there is an empty vector, return #T.
;;;   The iteration and order of application of PRED? across elements
;;;   is of the vectors is strictly left-to-right.
(define vector-every
  (letrec ((loop1 (lambda (pred? vec i len len-1)
                    (or (= i len)
                        (if (= i len-1)
                            (pred? (vector-ref vec i))
                            (and (pred? (vector-ref vec i))
                                 (loop1 pred? vec (+ i 1)
                                        len len-1))))))
           (loop2+ (lambda (pred? vectors i len len-1)
                     (or (= i len)
                         (if (= i len-1)
                             (apply pred? (vectors-ref vectors i))
                             (and (apply pred? (vectors-ref vectors i))
                                  (loop2+ pred? vectors (+ i 1)
                                          len len-1)))))))
    (lambda (pred? vec . vectors)
      (let ((pred? (check-type procedure? pred? 'vector-every))
            (vec   (check-type vector?    vec   'vector-every)))
        (if (null? vectors)
            (let ((len (vector-length vec)))
              (loop1 pred? vec 0 len (- len 1)))
            (let ((len (%smallest-length vectors
                                         (vector-length vec)
                                         'vector-every)))
              (loop2+ pred? (cons vec vectors) 0 len (- len 1))))))))


;;; (VECTOR-PARTITION <pred?> <vector>) -> vector
;;;   A vector the same size as <vec> is newly allocated and filled with
;;;   all the elements of <vec> that satisfy <pred?> in their original
;;;   order followed by all the elements that do not satisfy <pred?>,
;;;   also in their original order.

;;;   Two values are returned, the newly allocated vector and the index
;;;   of the leftmost element that does not satisfy <pred?>.
(define (vector-partition pred? vec)
  (let* ((len (vector-length vec))
         (cnt (vector-count pred? vec))
         (result (make-vector len)))
    (let loop ((i 0) (yes 0) (no cnt))
      (if (= i len)
        (values result cnt)
        (let ((elem (vector-ref vec i)))
          (if (pred? elem)
            (begin
              (vector-set! result yes elem)
              (loop (+ i 1) (+ yes 1) no))
            (begin
              (vector-set! result no elem)
              (loop (+ i 1) yes (+ no 1)))))))))

;;; --------------------
;;; Mutators

;;; (VECTOR-SWAP! <vector> <index1> <index2>) -> unspecified
;;;   Swap the values in the locations at INDEX1 and INDEX2.
(define (vector-swap! vec i j)
  (let ((vec (check-type vector? vec 'vector-swap!)))
    (let ((i (check-index vec i 'vector-swap!))
          (j (check-index vec j 'vector-swap!)))
      (let ((x (vector-ref vec i)))
        (vector-set! vec i (vector-ref vec j))
        (vector-set! vec j x)))))

;;;; ALREADY IN STklos:
;;; (VECTOR-FILL! <vector> <value> [<start> <end>]) -> unspecified
;;;   [R5RS+] Fill the locations in VECTOR between START, whose default
;;;   is 0, and END, whose default is the length of VECTOR, with VALUE.
;;;
;;; This one can probably be made really fast natively.

(from-scheme vector-fill!)

;;;; ALREADY IN STklos:
;;; (VECTOR-COPY! <target> <tstart> <source> [<sstart> <send>])
;;;       -> unspecified
;;;   Copy the values in the locations in [SSTART,SEND) from SOURCE to
;;;   to TARGET, starting at TSTART in TARGET.
;;; [wdc] Corrected to allow 0 <= sstart <= send <= (vector-length source).

(from-scheme vector-copy!)

;;; (VECTOR-REVERSE-COPY! <target> <tstart> <source> [<sstart> <send>])
;;; [wdc] Corrected to allow 0 <= sstart <= send <= (vector-length source).
(define (vector-reverse-copy! target tstart source . maybe-sstart+send)
  (define (doit! sstart send source-length)
    (let ((tstart (check-type nonneg-int? tstart 'vector-reverse-copy!))
          (sstart (check-type nonneg-int? sstart 'vector-reverse-copy!))
          (send   (check-type nonneg-int? send 'vector-reverse-copy!)))
      (cond ((and (<= 0 sstart send source-length)
                  (<= (+ tstart (- send sstart)) (vector-length target)))
             (%vector-reverse-copy! target tstart source sstart send))
            (else
             (error 'vector-reverse-copy!
                    "illegal arguments"
                    `(while calling ,vector-reverse-copy!)
                    `(target was ,target)
                    `(target-length was ,(vector-length target))
                    `(tstart was ,tstart)
                    `(source was ,source)
                    `(source-length was ,source-length)
                    `(sstart was ,sstart)
                    `(send   was ,send))))))
  (let ((n (vector-length source)))
    (cond ((null? maybe-sstart+send)
           (doit! 0 n n))
          ((null? (cdr maybe-sstart+send))
           (doit! (car maybe-sstart+send) n n))
          ((null? (cddr maybe-sstart+send))
           (doit! (car maybe-sstart+send) (cadr maybe-sstart+send) n))
          (else
           (error "too many arguments"
                  vector-reverse-copy!
                  (cddr maybe-sstart+send))))))


;;; (VECTOR-REVERSE! <vector> [<start> <end>]) -> unspecified
;;;   Destructively reverse the contents of the sequence of locations
;;;   in VECTOR between START, whose default is 0, and END, whose
;;;   default is the length of VECTOR.
(define (vector-reverse! vec . start+end)
  (let-vector-start+end 'vector-reverse! vec start+end
                        (start end)
    (%vector-reverse! vec start end)))


;;; --------------------
;;; Conversion


;;;; ALREADY IN STklos:
;;; (VECTOR->LIST <vector> [<start> <end>]) -> list
;;;   [R5RS+] Produce a list containing the elements in the locations
;;;   between START, whose default is 0, and END, whose default is the
;;;   length of VECTOR, from VECTOR.

(from-scheme vector->list)


;;; (REVERSE-VECTOR->LIST <vector> [<start> <end>]) -> list
;;;   Produce a list containing the elements in the locations between
;;;   START, whose default is 0, and END, whose default is the length
;;;   of VECTOR, from VECTOR, in reverse order.
(define (reverse-vector->list vec . maybe-start+end)
  (let-vector-start+end 'reverse-vector->list vec maybe-start+end (start end)
    (do ((i start (+ i 1))
         (result '() (cons (vector-ref vec i) result)))
        ((= i end) result))))


;;;; ALREADY IN STklos:
;;; (LIST->VECTOR <list> [<start> <end>]) -> vector
;;;   [R5RS+] Produce a vector containing the elements in LIST, which
;;;   must be a proper list, between START, whose default is 0, & END,
;;;   whose default is the length of LIST.  It is suggested that if the
;;;   length of LIST is known in advance, the START and END arguments
;;;   be passed, so that LIST->VECTOR need not call LENGTH to determine
;;;   the length.
;;;
;;; This implementation diverges on circular lists, unless LENGTH fails
;;; and causes - to fail as well.  Given a LENGTH* that computes the
;;; length of a list's cycle, this wouldn't diverge, and would work
;;; great for circular lists.

(from-scheme list->vector)


;;; (REVERSE-LIST->VECTOR <list> [<start> <end>]) -> vector
;;;   Produce a vector containing the elements in LIST, which must be a
;;;   proper list, between START, whose default is 0, and END, whose
;;;   default is the length of LIST, in reverse order.  It is suggested
;;;   that if the length of LIST is known in advance, the START and END
;;;   arguments be passed, so that REVERSE-LIST->VECTOR need not call
;;;   LENGTH to determine the the length.
;;;
;;; This also diverges on circular lists unless, again, LENGTH returns
;;; something that makes - bork.
(define (reverse-list->vector lst . maybe-start+end)
  (let*-optionals maybe-start+end
      ((start 0)
       (end (length lst)))              ; Ugh -- LENGTH
    (let ((start (check-type nonneg-int? start 'reverse-list->vector))
          (end   (check-type nonneg-int? end   'reverse-list->vector)))
      ((lambda (f)
         (vector-unfold-right f (- end start) (list-tail lst start)))
       (lambda (index l)
         (cond ((null? l)
                (error 'reverse-list->vector
                       "list too short"
                       `(list was ,lst)
                       `(attempted end was ,end)))
               ((pair? l)
                (values (car l) (cdr l)))
               (else

                (error 'reverse-list->vector
                       "erroneous value"
                       (list list? lst)))))))))

;;;; ALREADY IN STklos:
;;; (VECTOR->STRING <vector> [<start> <end>]) -> string
;;;   Produce a string containing the elements in the locations
;;;   between START, whose default is 0, and END, whose default is the
;;;   length of VECTOR, from VECTOR.

(from-scheme vector->string)


;;; (STRING->VECTOR <string> [<start> <end>]) -> vector
;;;   Produce a vector containing the elements in STRING
;;;   between START, whose default is 0, & END,
;;;   whose default is the length of STRING, from STRING.
(define (string->vector str . maybe-start+end)
  (let* ((len (string-length str))
         (start (if (null? maybe-start+end) 0 (car maybe-start+end)))
         (end (if (null? maybe-start+end)
                  len
                  (if (null? (cdr maybe-start+end)) len (cadr maybe-start+end))))
         (size (- end start)))
    (define result (make-vector size))
    (let loop ((at 0) (i start))
      (if (= i end)
        result
        (begin
          (vector-set! result at (string-ref str i))
          (loop (+ at 1) (+ i 1)))))))

;; END of module scheme/vector

;;; ======================================================================

(provide "scheme/vector")
