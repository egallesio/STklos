;;;;
;;;; 160/u8.stk         -- SRFI-160: Homogeneous numeric vector libraries
;;;;                                  (u8 sublibrary)
;;;;
;;;; Copyright Â© 2021 Jeronimo Pellegrini <j_p@aleph0.info>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Jeronimo Pellegrini [j_p@aleph0.info]
;;;;    Creation date: 17-Jun-2022 15:54
;;;;

(define-module scheme/vector/u8

  (import (srfi 4)
          (srfi 128)
          (scheme vector base))
  (export
   ;; Constructors
   make-u8vector   ;; BASE
   u8vector        ;; BASE
   u8vector-unfold
   u8vector-unfold-right
   u8vector-copy
   u8vector-reverse-copy
   u8vector-append
   u8vector-concatenate
   u8vector-append-subvectors

   ;; Predicates
   u8?              ;; BASE
   u8vector?        ;; BASE
   u8vector-empty?
   u8vector=

   ;; Selectors
   u8vector-ref     ;; BASE
   u8vector-length  ;; BASE

   ;; Iteration
   u8vector-take
   u8vector-take-right
   u8vector-drop
   u8vector-drop-right
   u8vector-segment
   u8vector-fold
   u8vector-fold-right
   u8vector-map
   u8vector-map!
   u8vector-for-each
   u8vector-count
   u8vector-cumulate

   ;; Searching
   u8vector-take-while
   u8vector-take-while-right
   u8vector-drop-while
   u8vector-drop-while-right
   u8vector-index
   u8vector-index-right
   u8vector-skip
   u8vector-skip-right
   u8vector-any
   u8vector-every
   u8vector-partition
   u8vector-filter
   u8vector-remove

   ;; Mutators
   u8vector-set!            ;; BASE
   u8vector-swap!
   u8vector-fill!
   u8vector-reverse!
   u8vector-copy!
   u8vector-reverse-copy!
   u8vector-unfold!
   u8vector-unfold-right!

   ;; Conversion
   u8vector->list           ;; BASE
   reverse-u8vector->list
   list->u8vector           ;; BASE
   reverse-list->u8vector
   u8vector->vector
   vector->u8vector

   ;; Generators
   make-u8vector-generator

   ;; Comparators
   u8vector-comparator

   ;; Output
   write-u8vector)


;; A case of "macros for performance"... Not the best thing to do, we could
;; actually have done a more sofisticated job in generating the output from
;; the template, but this keeps it simple.
;; The macro (uvector-tag) will expand to u8 in the template.
;; However, in the generated file, the u8 will be replaed by the tag name.
;; So the macro will expand to the VALUE of the tag, which is the
;; fastest thing we can do. Not even access to a global will be done, the
;; correct constant will be pushed onto the stack.
;;
;;  (%s32vector-something (uvector-tag) args)
;; EXPANDS into
;;  (u8vector-something 4 args)
;; and NOT into
;;  (%u8vector-something s32 args)

(define-macro (uvector-tag)
  (let ((s8   0)
        (u8   1)
        (s16  2)
        (u16  3)
        (s32  4)
        (u32  5)
        (s64  6)
        (u64  7)
        (f32  8)
        (f64  9)
        (c64  10)
        (c128 11))
    u8))

;; We'll be accessing the base module to get some procedures from it:
(define base (find-module 'scheme/vector/base))

;; These are implemented in C, and used here to build the actual procedures:
(define %uvector-unfold            (symbol-value '%uvector-unfold base))
(define %uvector-copy              (symbol-value '%uvector-copy base))
(define %uvector-append-subvectors (symbol-value '%uvector-append-subvectors base))
(define %uvector-empty?            (symbol-value '%uvector-empty? base))
(define %uvector=                  (symbol-value '%uvector= base))
(define %uvector-iterate           (symbol-value '%uvector-iterate base))
(define %uvector-segment           (symbol-value '%uvector-segment base))

;;;
;;; Constructors OK
;;;

;; make-vector OK
;; vector      OK

(define (u8vector-unfold f len seed)
  (%uvector-unfold (uvector-tag) f #f len seed #f))

(define (u8vector-unfold-right f len seed)
  (%uvector-unfold (uvector-tag) f #f len seed #t))

(define (u8vector-copy v :optional (start 0) (end (u8vector-length v)))
  (%uvector-copy (uvector-tag) #f 0 v start end #f))

(define (u8vector-reverse-copy v :optional (start 0) (end (u8vector-length v)))
  (%uvector-copy (uvector-tag) #f 0 v start end #t))

(define (u8vector-append . vecs)
  (%uvector-append-subvectors (uvector-tag) #f vecs))

(define (u8vector-concatenate vecs)
  (%uvector-append-subvectors (uvector-tag) #f vecs))

(define (u8vector-append-subvectors . vecs)
  (%uvector-append-subvectors (uvector-tag) #t vecs))

;;;
;;; Predicates OK
;;;

(define (u8vector-empty? v) (%uvector-empty? (uvector-tag) v))

(define (u8vector= . args) (%uvector= (uvector-tag) args))

;;;
;;; Selectors OK
;;;

;; vector-ref    OK
;; vector-length OK

;; Iteration OK

(define (u8vector-take v n) (u8vector-copy v 0 n))
(define (u8vector-take-right v n)
  (u8vector-copy v (- (u8vector-length v) n))) ; FIXME: optimize?

(define (u8vector-drop v n)       (u8vector-copy v n))
(define (u8vector-drop-right v n)
  (%uvector-copy (uvector-tag) #f 0 v 0 (- (u8vector-length v) n) #f)) ; FIXME: optimize?

(define (u8vector-segment v n) (%uvector-segment (uvector-tag) v n))

(define (u8vector-fold kons knil v1 . v2)
  (%uvector-iterate (uvector-tag) kons (cons v1 v2)
   #f   ;; do NOT mutate
   10   ;; operation (10 = fold)
   #f   ;; NOT from-right
   knil ;; seed
   ))

(define (u8vector-fold-right kons knil v1 . v2)
  (%uvector-iterate (uvector-tag) kons (cons v1 v2)
   #f   ;; do NOT mutate
   10   ;; operation (10 = fold)
   #t   ;; YES from-right
   knil ;; seed
   ))

(define (u8vector-map proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   0  ;; operation (0 = map)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-map! proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #t ;; DO mutate
   0  ;; operation (0 = map)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-for-each proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   9  ;; operation (9 = for-each)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-count proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   5  ;; operation (5 = count)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-cumulate kons knil v1)
  (%uvector-iterate (uvector-tag) kons (list v1)
   #f   ;; do NOT mutate
   11   ;; operation (11 = cumulate)
   #f   ;; NOT from-right
   knil ;; seed
   ))

;;;
;;; Searching OK
;;;

(define (u8vector-take-while pred? vec)
  (u8vector-take vec (u8vector-skip pred? vec)))

(define (u8vector-take-while-right pred? vec)
  (u8vector-drop vec (+ 1 (u8vector-skip-right pred? vec))))

(define (u8vector-drop-while pred? vec)
  (u8vector-drop vec (u8vector-skip pred? vec)))

(define (u8vector-drop-while-right pred? vec)
  (u8vector-take vec (+ 1 (u8vector-skip-right pred? vec))))


(define (u8vector-index proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   3  ;; operation (3 = index)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-index-right proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   3  ;; operation (3 = index)
   #t ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-skip proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   4  ;; operation (4 = skip)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-skip-right proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   4  ;; operation (4 = skip)
   #t ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-any proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   1  ;; operation (1 = any)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-every proc v1 . vs)
  (%uvector-iterate (uvector-tag) proc (cons v1 vs)
   #f ;; do NOT mutate
   2  ;; operation (2 = every)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-partition proc v1)
  (%uvector-iterate (uvector-tag) proc (list v1)
   #f ;; do NOT mutate
   6  ;; operation (6 = partition)
   #f ;; NOT from-right
   #f ;; NO seed
   ))

(define (u8vector-filter proc v1)
  (%uvector-iterate (uvector-tag) proc (list v1)
   #f ;; do NOT mutate
   7  ;; operation (7 = filter)
   #f ;; NOT from-right
   #f ;; NO seed
   ))
(define (u8vector-remove proc v1)
  (%uvector-iterate (uvector-tag) proc (list v1)
   #f ;; do NOT mutate
   8  ;; operation (8 = remove)
   #f ;; NOT from-right
   #f ;; NO seed
   ))


;;;
;;; Mutators OK
;;;

;; vector-set! OK

;; FIXME:
;; vector-fill! and vector-swap! do not depend on vector type,
;; but vector-fill! does some type checking for each element
;; written. Maybe this could be optimized...
(define u8vector-swap! (symbol-value '%uvector-swap!         base))
(define u8vector-fill! (symbol-value '%uvector-fill!         base))

(define (u8vector-reverse! v :optional (start 0) (end (u8vector-length v)))
  (%uvector-copy (uvector-tag) v start v start end #t)
  #void)

(define (u8vector-copy! to at from :optional (start 0) (end (u8vector-length from)))
  (%uvector-copy (uvector-tag) to at from start end #f)
  #void)

(define (u8vector-reverse-copy! to at from :optional (start 0) (end (u8vector-length from)))
  (%uvector-copy (uvector-tag) to at from start end #t)
  #void)

(define (u8vector-unfold! f v start end seed)
  (%uvector-unfold (uvector-tag) f v start end seed #f)
  #void)

(define (u8vector-unfold-right! f v start end seed)
  (%uvector-unfold (uvector-tag) f v start end seed #t)
  #void)

;;;
;;; Conversion OK
;;;

(define (vector->u8vector v :optional (start 0) (end (vector-length v)))
  (let* ((w (make-u8vector (- end start))))
    (do ((i start (+ i 1)))
        ((= i end))
      (u8vector-set! w (- i start) (vector-ref v i)))
    w))

(define (u8vector->vector v :optional (start 0) (end (u8vector-length v)))
  (let* ((w (make-vector (- end start))))
    (do ((i start (+ i 1)))
        ((= i end))
      (vector-set! w (- i start) (u8vector-ref v i)))
    w))


(define (u8vector->list v :optional (start 0) (end (u8vector-length v)))
  (let ((v (u8vector-copy v start end)))
    (let loop ((i (fx- (u8vector-length v) 1))
               (lst '()))
      (if (fx< i 0)
          lst
          (loop (fx- i 1) (cons (u8vector-ref v i) lst))))))


(define (reverse-list->u8vector lst)
  (u8vector-reverse-copy (list->u8vector lst)))

(define (reverse-u8vector->list v :optional (start 0) (end (u8vector-length v)))
  (u8vector->list (u8vector-reverse-copy v start end)))

;;;
;;; Generators OK
;;;

(define (make-u8vector-generator v :optional (start 0) (end (u8vector-length v)))
  (lambda () (if (fx>= start end)
            (eof-object)
            (let ((x (u8vector-ref v start)))
              (set! start (fx+ 1 start))
              x))))

;;;
;;; Comparators OK
;;;

;; Adapted from reference implementation in Chicken:
(define (u8vector< vec1 vec2)
     (let ((len1 (u8vector-length vec1))
           (len2 (u8vector-length vec2)))
       (cond
         ((fx< (u8vector-length vec1)
               (u8vector-length vec2))
          #t)
         ((fx> (u8vector-length vec1)
               (u8vector-length vec2))
          #f)
         (else
          (let loop ((i 0))
            (cond
              ((fx= i len1) #f)
              ((< (u8vector-ref vec1 i) (u8vector-ref vec2 i))
               #t)
              ((> (u8vector-ref vec1 i) (u8vector-ref vec2 i))
               #f)
              (else
               (loop (fx+ i 1)))))))))

(define u8vector-comparator
  (make-comparator u8vector? u8vector= u8vector< hash-table-hash))

;;;
;;; Output OK
;;;

(define (write-u8vector v :optional port)
  (unless ()
    (error))
  (if port
      (write v port)
      (write v)))

  )

(provide "scheme/vector/u8")
