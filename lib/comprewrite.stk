;;;;
;;;;
;;;; comprewrite.stk         -- Rewrite expressions in simpler ones
;;;;
;;;; Copyright Â© 2024 Erick Gallesio <eg@stklos.net>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@stklos.net]
;;;;    Creation date:  4-May-2024 18:09
;;;;

;;
;; Rewrite table management
;;
(define *all-rewriters* (%make-hash-table eq? hash-table-hash))

(define (find-rewriter symb)
  (hash-table-get *all-rewriters* symb #f))

(define (compiler:add-rewriter! symb proc)
  ;; A rewriter must take 3 parameters
  ;;    - expr  (the expression to simplify/rewrite)
  ;;    - len   (the length of the expression)
  ;;    - env   (the environment)
  ;; It returns a (possibly) simplified expression
  (hash-table-set! *all-rewriters* symb proc))

;;
;; rewrite an expression
;;
(define (const-expr? expr)    ;; is 'expr' a constant expression?
  (and (not (symbol? expr))
       (or (not (pair? expr))
           (eq? (car expr) 'quote))))

(define (const-value expr)    ;; return the value of a constant expression
  (if (pair? expr)
      (cadr expr)
      expr))

(define (rewrite-expression e env)
  (let Loop ((save e))
    (when (pair? e)
      (let ((s     (car e))
            (optim (find-rewriter (car e))))
        (when (and optim (not (find-symbol-in-env s env)))
          ;; We have a rewriter and symbol is not defined in current
          ;; environment
          (set! e (optim e (length e) env))
          (unless (equal? e save)
            ;; (%debug "Rewrite ~s => ~s" save e)
            (Loop e))))))
  ;; Return the (eventually modified) value of e
  e)


;;; ======================================================================
;;;
;;; Rewriting Rules
;;;
;;; ======================================================================
(compiler:add-rewriter!            ;; 'IF' rewriter
 'if
 (lambda (expr len env)
   (if (<= 3 len 4)
       (let ((Cond (rewrite-expression (cadr expr) env))
             (Then (caddr expr))
             (Else (if (null? (cdddr expr))
                       #void
                       (cadddr expr))))
         (if (const-expr? Cond)
             (if (const-value Cond)
                 (rewrite-expression Then env)
                 (rewrite-expression Else env))
             expr))
       expr)))


(compiler:add-rewriter!            ;; 'NOT' rewriter
 'not
 (lambda (expr len env)
   (if (= len 2)
       (let ((val (rewrite-expression (cadr expr) env)))
         (if (const-expr? val)
             (not (const-value val))
             expr))
       expr)))


(compiler:add-rewriter!            ;; 'BEGIN' rewriter
 'begin
 (lambda (expr _len env) ;; _len unused here
   (let Loop ((e   (cdr expr))
              (res (list 'begin)))
     (cond
      ((null? e)          ;; end of the list
       (reverse! res))

      ((null? (cdr e))    ;; last expression is always left as is
       (Loop '() (cons (rewrite-expression (car e) env) res)))

      (else               ;; if first expression is not a pair, skip it
       (Loop (cdr e)
             (if (or (pair? (car e))     ;; a call
                     (eq? (car e) '=>))  ;; a => in a cond (SRF 61)
                 (cons (rewrite-expression (car e) env) res)
                 res)))))))

(compiler:add-rewriter!            ;; 'EOF-OBJECT' rewriter
 'eof-object
 (lambda (expr len env)
   (if (= len 1)
       #eof
       expr)))


;; FIXME: Verify that CAR and CDR rewriters preserve eq?-ness in code constants
;; (or suppress them)
(compiler:add-rewriter!            ;; 'CAR' rewriter
 'car
 (lambda (expr len env)
   (if (= len 2)
       (let ((v (rewrite-expression (cadr expr) env)))
         (if (const-expr? v)
             (let ((val (const-value v)))
               (if (pair? val)
                   ;; quote added here to permit further rewrites (car (car ...))
                   (list 'quote (car val))
                   expr))
             expr))
       expr)))


(compiler:add-rewriter!            ;; 'CDR' rewriter
 'cdr
 (lambda (expr len env)
   (if (= len 2)
       (let ((v (rewrite-expression (cadr expr) env)))
         (if (const-expr? v)
             (let ((val (const-value v)))
               (if (pair? val)
                   ;; quote added here to permit further rewrites (cdr (car ...))
                   (list 'quote (cdr val))
                   expr))
             expr))
       expr)))


;; deep-find checks if a symbol is refrenced anywhere inside a structure.
;;
;; (deep-find 'x '(a b c (d e (f x g) h) i)) => #t
(define (deep-find elt lst)
  (cond ((null? lst)                     #f)
        ((eq? elt lst)                   #t)
        ((pair? lst)
         (or (deep-find elt (car lst))
             (deep-find elt (cdr lst))))
        (else #f)))


;;; LET rewriter:
;;
;; The procedures internal-shadow?, external-shadow? and deep-find are
;; used by the join-lets procedure which, in turn, is used by the let
;; rewriter.

;; (internal-shadow? bindings) will check if the bindings would
;; LET their own variable definition if truned into a LET*.
;; For example:
;;
;; (let ((a 10)
;;       (b 20)
;;       (c (+ 1 a))  ;; Oops, this is NOT the "a" begin defined in this LET...
;;
;; What we have above is internal shadowing, which this procedure detects.
;;
;; If we turned the above LET into LET*, it would be wrong:
;; (let* ((a 10)
;;        (b 20)
;;        (c (+ 1 a))  ;; Now this "a" refers to the "a" being defined in these
;;                     ;; bindings, and this is not correct!
;;
;; (internal-shadow? '( (a 1) (b 3) (c (+ a 2)) )) => #t
;; (internal-shadow? '( (a 1) (b 3) (c (+ f 2)) )) => #f
(define (internal-shadow? bindings)
  (let ((vars  (map car bindings))
        (exprs (map cdr bindings)))
    (let Loop ((V vars)
               (E exprs))
      (cond ((null? V)             #f)
            ((deep-find (car V) E) #t)
            (else                  (Loop (cdr V) (cdr E)))))))

;; (external-shadow? bindings2 bindings1) will check if bindings2
;; will shadow any variable in bindings1.
(define (external-shadow? bindings2 bindings1)
  (let ((vars1 (map car bindings1))
        (vars2 (map car bindings2)))
    (let Loop ((vars1 vars1))
      (cond ((null? vars1)            #f)
            ((memq (car vars1) vars2) #t)
            (else                     (Loop (cdr vars1)))))))

;; (join-lets expr) will join nested LETs into a single
;; LET-star (let*). this is faster since we avoid going
;; into several "ENTER-LET" and "PREPARE-CALL" instructions.
;;
;; (join-lets '(let ((a 1))
;;               (let ((b 2))
;;                 (let ((c 3))
;;                   x)
;;                 y)))
;; =>
;; (let* ((a 1)
;;        (b 2)
;;        (c 3))
;;   x y)
;;
;; See that the bodies of the LETs are appended, reflecting the order
;; in which the expressions would be executed.
;;
;; Shadowing LETs are not optimized, as this can lead to wrong results.
(define (join-lets expression)
  ;; (let1 bindings1 (let2 bindings2 . body2) . body1)
  ;;
  ;; We know that (length expr) > 2, and:
  ;;
  ;; (list-ref expr 1)       = bindings1
  ;; (list-ref expr 2)       = (let2 bindings2 ...)
  ;; (cadr (list-ref expr 2) = bindings2
  ;; (cdddr expr)            = body1
  ;; (cddr (list-ref expr2)) = body2

  (define (%join expr)
    (if (and (pair? (list-ref expr 2))         ; body of LET1 is a list...
             (memq (car (list-ref expr 2))
                   '(let let*))                ; ...starting with LET or LET*
             (list? (cadr (list-ref expr 2)))) ; and LET2 is not a named let

        (let ((bindings1 (list-ref expr 1))
              (bindings2 (cadr (list-ref expr 2))))

          ;; No internal or external shadowing:
          (if (and (not (external-shadow? bindings2 bindings1))
                   (not (internal-shadow? bindings1))
                   (not (internal-shadow? bindings2)))

              (let* ((new-bindings (append bindings1 bindings2))
                     (body1 (cdddr expr))
                     (body2 (cddr (list-ref expr 2)))
                     (body (cond ((null? body2) body1)
                                 ((null? body1) body2)
                                 (else (append body2 body1)))))
                (%join (append (list 'let* new-bindings)
                               body)))
              expr))
        expr))

  (%join expression))


(compiler:add-rewriter!            ;; 'LET' rewriter
 'let
 ;; (let BINDINGS1 (let BINDINGS2 ...)) => (let* BINDINGS ...)
 (lambda (expr len env)
   (if (and (> len 2)              ; at least '(let bindings expr)'
            (list? (cadr expr)))   ; not named let
       ;; Don't include the code here; keep it in a 'join-lets'
       ;; separate procedure, so we can perhaps do other optimizations
       ;; here in the future without too much confusion.
       (join-lets expr)
       expr)))
