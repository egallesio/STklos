;;;;
;;;;
;;;; comprewrite.stk         -- Rewrite expressions in simpler ones
;;;;
;;;; Copyright Â© 2024 Erick Gallesio <eg@stklos.net>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@stklos.net]
;;;;    Creation date:  4-May-2024 18:09
;;;;

(export compiler:find-rewriter
        compiler:add-rewriter!
        compiler:const-expr?
        compiler:const-value
        compiler:rewrite-expression)

;;
;; Rewrite table management
;;
(define *all-rewriters* (%make-hash-table eq? hash-table-hash))

(define (compiler:find-rewriter symb)
  (hash-table-get *all-rewriters* symb #f))

(define (compiler:add-rewriter! symb proc)
  ;; A rewriter must take 3 parameters
  ;;    - expr  (the expression to simplify/rewrite)
  ;;    - len   (the length of the expression)
  ;;    - env   (the environment)
  ;; It returns a (possibly) simplified expression
  (hash-table-set! *all-rewriters* symb proc))

;;
;; rewrite an expression
;;
(define (const-expr? expr)    ;; is 'expr' a constant expression?
  (and (not (symbol? expr))
       (or (not (pair? expr))
           (eq? (car expr) 'quote))))

(define (const-value expr)    ;; return the value of a constant expression
  (if (pair? expr)
      (cadr expr)
      expr))

(define (rewrite-expression e env)  ;; try to rewrite(simplify) expression e
  (let Loop ((save e))
    (when (pair? e)
      (let ((s     (car e))
            (optim (compiler:find-rewriter (car e))))
        (when (and optim (not (find-symbol-in-env s env)))
          ;; We have a rewriter and symbol is not defined in current
          ;; environment
          (set! e (optim e (length e) env))
          (unless (equal? e save)
            ;; (%debug "Rewrite ~s => ~s" save e)
            (Loop e))))))
  ;; Return the (eventually modified) value of e
  e)

;; exported symbols of the previous functions
(define compiler:const-expr? const-expr?)
(define compiler:const-value const-value)
(define compiler:rewrite-expression rewrite-expression)


;;; ======================================================================
;;;
;;; Rewriting Rules
;;;
;;; ======================================================================
(compiler:add-rewriter!            ;; 'IF' rewriter
 'if
 ;; (if CONST then-expr else-expr)
 ;; ===> then-expr  (if CONST is #f)
 ;; ===> else-expr  (otherwise)
 (lambda (expr len env)
   (if (<= 3 len 4)
       (let ((Cond (rewrite-expression (cadr expr) env))
             (Then (caddr expr))
             (Else (if (null? (cdddr expr))
                       #void
                       (cadddr expr))))
         (if (const-expr? Cond)
             (if (const-value Cond)
                 (rewrite-expression Then env)
                 (rewrite-expression Else env))
             expr))
       expr)))


(compiler:add-rewriter!            ;; 'NOT' rewriter
 'not
 ;; (not CONST-A) ===> CONST-B
 ;;
 ;; where CONST-B is the boolean (not CONST-A)
 ;;
 ;; (inline not for constant)
 (lambda (expr len env)
   (if (= len 2)
       (let ((val (rewrite-expression (cadr expr) env)))
         (if (const-expr? val)
             (not (const-value val))
             expr))
       expr)))


(compiler:add-rewriter!            ;; 'BEGIN' rewriter
 'begin
 ;; (begin CONST (a...) CONST (b...) => CONST (c...) XCONST)
 ;; ===>
 ;; (begin (a...) (b...) => (c...) XCONST
 ;;
 ;; (remove constants, except the last one and the => symbol)
 (lambda (expr _len env) ;; _len unused here
   (let Loop ((e   (cdr expr))
              (res (list 'begin)))
     (cond
      ((null? e)          ;; end of the list
       (reverse! res))

      ((null? (cdr e))    ;; last expression is always left as is
       (Loop '() (cons (rewrite-expression (car e) env) res)))

      (else               ;; if first expression is not a pair, skip it
       (Loop (cdr e)
             (if (or (pair? (car e))     ;; a call
                     (eq? (car e) '=>))  ;; a => in a cond (SRF 61)
                 (cons (rewrite-expression (car e) env) res)
                 res)))))))

(compiler:add-rewriter!            ;; 'EOF-OBJECT' rewriter
 'eof-object
 ;; (eof-object) ===> #eof
 (lambda (expr len env)
   (if (= len 1)
       #eof
       expr)))


;; FIXME: Verify that CAR and CDR rewriters preserve eq?-ness in code constants
;; (or suppress them)
(compiler:add-rewriter!            ;; 'CAR' rewriter
 'car
 ;; (car (CONST-HEAD . CONST-TAIL)) ===> CONST-HEAD
 (lambda (expr len env)
   (if (= len 2)
       (let ((v (rewrite-expression (cadr expr) env)))
         (if (const-expr? v)
             (let ((val (const-value v)))
               (if (pair? val)
                   ;; quote added here to permit further rewrites (car (car ...))
                   (list 'quote (car val))
                   expr))
             expr))
       expr)))


(compiler:add-rewriter!            ;; 'CDR' rewriter
 'cdr
 ;; (cdr (CONST-HEAD . CONST-TAIL)) ===> CONST-TAIL
 (lambda (expr len env)
   (if (= len 2)
       (let ((v (rewrite-expression (cadr expr) env)))
         (if (const-expr? v)
             (let ((val (const-value v)))
               (if (pair? val)
                   ;; quote added here to permit further rewrites (cdr (car ...))
                   (list 'quote (cdr val))
                   expr))
             expr))
       expr)))


;;;
;;; LET rewriter:
;;;
;;
;; The procedures no-named-let?, no-srfi-5-let?, deep-find, internal-shadow?, and
;; external-shadow? are used by the join-lets procedure which, in turn, is used by
;; the let rewriter.


;; We repeatedely check if a form is a named LET, so here's the procedure to do so.
(define (no-named-let? form)
  ;; form = (LET A B ...)
  ;; (CADR form) = A
  (list? (cadr form)))

;; We do not optimize SRFI-5 LETs.
(define (no-srfi-5-let? form)
  ;; form = (LET A B ...)
  ;; (CADR form) = A
  ;; (CAADR form) = (CAR A)
  (or (not (pair? (cadr form))) ; named LET, not SRFI-5 LET
      (list? (caadr form))))    ; CAR of bindings is list, not SRFI-5 LET

;; deep-find checks if a symbol is refrenced anywhere inside a structure.
;;
;; (deep-find 'x '(a b c (d e (f x g) h) i)) => #t
(define (deep-find elt lst)
  (cond ((null? lst)                     #f)
        ((eq? elt lst)                   #t)
        ((pair? lst)
         (or (deep-find elt (car lst))
             (deep-find elt (cdr lst))))
        (else #f)))

;; (internal-shadow? bindings) will check if the bindings would
;; LET their own variable definition if turned into a LET*.
;; For example:
;;
;; (let ((a 10)
;;       (b 20)
;;       (c (+ 1 a))  ;; Oops, this is NOT the "a" begin defined in this LET...
;;
;; What we have above is internal shadowing, which this procedure detects.
;;
;; If we turned the above LET into LET*, it would be wrong:
;; (let* ((a 10)
;;        (b 20)
;;        (c (+ 1 a))  ;; Now this "a" refers to the "a" being defined in these
;;                     ;; bindings, and this is not correct!
;;
;; (internal-shadow? '( (a 1) (b 3) (c (+ a 2)) )) => #t
;; (internal-shadow? '( (a 1) (b 3) (c (+ f 2)) )) => #f
(define (internal-shadow? bindings)
  (let ((vars  (map car bindings))
        (exprs (map cdr bindings)))
    (let Loop ((V vars)
               (E exprs))
      (cond ((null? V)             #f)
            ((deep-find (car V) E) #t)
            (else                  (Loop (cdr V) (cdr E)))))))

;; (external-shadow? bindings2 bindings1) will check if bindings2
;; will shadow any variable in bindings1.
;;
;; (external-shadow? '((a 1) (b 2)) '((x 10) (y 20)) ) => #f
;; (external-shadow? '((a 1) (b 2)) '((x 10) (a 20)) ) => #t
(define (external-shadow? bindings2 bindings1)
  (let ((vars1 (map car bindings1))
        (vars2 (map car bindings2)))
    (let Loop ((vars1 vars1))
      (cond ((null? vars1)            #f)
            ((memq (car vars1) vars2) #t)
            (else                     (Loop (cdr vars1)))))))

;; (join-lets expr) will join nested LETs into a single
;; LET-star (let*). this is faster since we avoid going
;; into several "ENTER-LET" and "PREPARE-CALL" instructions.
;;
;; (join-lets '(let ((a 1))
;;               (let ((b 2))
;;                 (let ((c 3))
;;                   x))))
;; =>
;; (let* ((a 1)
;;        (b 2)
;;        (c 3))
;;   x)
;;
;; These are not optimized, as this can lead to wrong results:
;; - a LET that would shadow a variable in an outer let
;; - a LET that uses a symbol that it also defines:
;;   (LET ((a ...) (b ... a ...)) ...)
;; - SRFI-5 LETs
;; - named LETs
;; - LETs with non-empty body, except for the inner one.
;;
;; In particular, regarding the last one (outer LETs with non-empty
;; following body):
;;
;; (define b -1)
;;
;; (let ((a 10))
;;   (let ((b 5))
;;     1)
;;   b)    => -1
;;
;; If we rewrote this, then the result would be wrong (5 instead of -1).
;;
(define (join-lets expression)
  ;; (let1 bindings1 (let2 bindings2 . body2) . body1)
  ;;
  ;; We know that (length expr) > 2, and:
  ;;
  ;; (list-ref expr 1)       = bindings1
  ;; (list-ref expr 2)       = (let2 bindings2 ...)
  ;; (cadr (list-ref expr 2) = bindings2
  ;; (cdddr expr)            = body1
  ;; (cddr (list-ref expr2)) = body2

  (define (%join expr)
    (if (and (pair? (list-ref expr 2))         ; body of LET1 is a list...
             (memq (car (list-ref expr 2))
                   '(let let*))                ; ...starting with LET or LET*
             (no-named-let? (list-ref expr 2)) ; and LET2 is not a named let
             (no-srfi-5-let? expr))            ; no SRFI-5 LET

        (let ((bindings1 (list-ref expr 1))
              (bindings2 (cadr (list-ref expr 2)))
              (body1 (cdddr expr))
              (body2 (cddr (list-ref expr 2))))

          ;; No internal or external shadowing, and the body for the
          ;; external LET should be empty
          (if (and (not (external-shadow? bindings2 bindings1))
                   (not (internal-shadow? bindings1))
                   (not (internal-shadow? bindings2))
                   (not (null? body2))
                   (null? body1))

              (let* ((new-bindings (append bindings1 bindings2)))
                (%join (append (list 'let* new-bindings) body2)))
              expr))
        expr))

  (%join expression))

;; (maybe-let->let* expr) receives a LET form and turns it into a LET*.
;; This is only done if:
;; - It is not a named LET
;; - Single-binding LETs are not rewritten (it's not useful)
;; - Turning it into a LET* will not insert new shadowing, changing semantics
;;   (no internal shadowing).
;; - We don't rewrite SRFI-5 LETs
;;
;; This is rewritten:
;; (maybe-let->let* '(let ((a 1) (b 2)) b))      => (let* ((a 1) (b 2)) b)
;;
;; The following are not (named let; single binding; shadowing; SRFI 5, in
;; that order):
;; (maybe-let->let* '(let f ((a 1) (b 2)) body)) => (let f ((a 1) (b 2)) body)
;; (maybe-let->let* '(let ((a 1)) b))            => (let ((a 1)) b)
;; (maybe-let->let* '(let ((a 1) (b a)) b))      => (let ((a 1) (b a)) b)
;; (maybe-let->let* '(let (f (a) 2) (f 4)))      => (let (f (a) 2) (f 4))
(define (maybe-let->let* expr)
  (if (and (no-named-let? expr)                   ; no named LETs
           (no-srfi-5-let? expr)                  ; no SRFI-5 LET
           (> (length (cadr expr)) 1)             ; don't rewrite single-binding LET
           (not (internal-shadow? (cadr expr)))) ; no shadowing
      (cons 'let* (cdr expr))
      expr))

(compiler:add-rewriter!            ;; 'LET' rewriter
 'let
 ;; (let BINDINGS1 (let BINDINGS2 ...)) => (let* BINDINGS ...)
 (lambda (expr len env)
   (if (> len 2)              ; at least '(let bindings expr)'
       ;; Don't include the code here; keep it in a 'join-lets'
       ;; separate procedure, so we can use it for LET* also.
       ;;
       ;; Also -- LET does call maybe-let->let*; LET* doesn't.
       (join-lets (maybe-let->let* expr))
       expr)))

(compiler:add-rewriter!            ;; 'LET*' rewriter
 'let*
 ;; (let BINDINGS1 (let BINDINGS2 ...)) => (let* BINDINGS ...)
 (lambda (expr len env)
   (if (> len 2)              ; at least '(let bindings expr)'
       ;; Don't include the code here; keep it in a 'join-lets'
       ;; separate procedure, so we can use it for LET also.
       ;;
       ;; Also -- LET does call maybe-let->let*; LET* doesn't.
       (join-lets expr)
       expr)))
