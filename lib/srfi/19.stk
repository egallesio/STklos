;;;;
;;;; srfi-19.stk        -- SRFI-19 Implementation
;;;;
;;;; Copyright © 2002-2023 Erick Gallesio <eg@stklos.net>
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date:  2-Apr-2002 17:16 (eg)
;;;;
;;;;
;;;; This implementation is an adaptation of the reference implementation
;;;; given in the SRFI-19 document, and further adapted using part of the
;;;; Gauche Scheme implementation.
;;;;
;;;; The reference implementation is copyrighted as:
;;
;; SRFI-19: Time Data Types and Procedures.
;;
;; Copyright (C) Neodesic Corporation (2000). All Rights Reserved.
;;
;; This document and translations of it may be copied and furnished to others,
;; and derivative works that comment on or otherwise explain it or assist in its
;; implementation may be prepared, copied, published and distributed, in whole or
;; in part, without restriction of any kind, provided that the above copyright
;; notice and this paragraph are included on all such copies and derivative works.
;; However, this document itself may not be modified in any way, such as by
;; removing the copyright notice or references to the Scheme Request For
;; Implementation process or editors, except as needed for the purpose of
;; developing SRFIs in which case the procedures for copyrights defined in the SRFI
;; process must be followed, or as required to translate it into languages other
;; than English.
;;
;; The limited permissions granted above are perpetual and will not be revoked
;; by the authors their successors or assigns.
;;
;; This document and the information contained herein is provided on an "AS IS"
;; basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL WARRANTIES, EXPRESS OR
;; IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
;; INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
;; MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
;;;;
;;;;
;;;; Gauche Scheme is Copyrighted as:
;;
;; You can use, modify, and redistribute this software under
;; the revised BSD license.   See below for the actual copyright
;; holders and the exact terms of license for various parts
;; of the software.
;;
;; Copyright and condition of use of main portion of the source:
;; -----------------------------------------------------------------------------
;;
;;   Copyright (c) 2000-2022  Shiro Kawai  <shiro@acm.org>
;;
;;   Redistribution and use in source and binary forms, with or without
;;   modification, are permitted provided that the following conditions
;;   are met:
;;
;;    1. Redistributions of source code must retain the above copyright
;;       notice, this list of conditions and the following disclaimer.
;;
;;    2. Redistributions in binary form must reproduce the above copyright
;;       notice, this list of conditions and the following disclaimer in the
;;       documentation and/or other materials provided with the distribution.
;;
;;    3. Neither the name of the authors nor the names of its contributors
;;       may be used to endorse or promote products derived from this
;;       software without specific prior written permission.
;;
;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


(define-module srfi/19
  (import (except SCHEME current-date))
  (export (rename tm:make-date make-date)
          (rename tm:current-time current-time))
  (export time-tai time-utc time-monotonic time-thread
          time-process time-duration time-resolution
          make-time time? time-type time-second time-nanosecond
          set-time-type! set-time-second! set-time-nanosecond! copy-time
          time=? time<? time<=? time>? time>=?
          time-difference time-difference! add-duration add-duration!
          subtract-duration subtract-duration!
          date? date-nanosecond date-second date-minute
          date-hour date-day date-month date-year date-zone-offset
          date-year-day date-week-day date-week-number tm::current-date
          current-julian-day current-modified-julian-day
          date->julian-day date->modified-julian-day date->time-monotonic
          date->time-tai date->time-utc
          julian-day->date julian-day->time-monotonic
          julian-day->time-tai julian-day->time-utc
          modified-julian-day->date modified-julian-day->time-monotonic
          modified-julian-day->time-tai modified-julian-day->time-utc
          time-monotonic->date time-monotonic->julian-day
          time-monotonic->modified-julian-day
          time-monotonic->time-tai time-monotonic->time-tai!
          time-monotonic->time-utc time-monotonic->time-utc!
          time-utc->date time-utc->julian-day
          time-utc->modified-julian-day
          time-utc->time-monotonic time-utc->time-monotonic!
          time-utc->time-tai time-utc->time-tai!
          time-tai->date time-tai->julian-day
          time-tai->modified-julian-day
          time-tai->time-monotonic time-tai->time-monotonic!
          time-tai->time-utc time-tai->time-utc!
          date->string string->date

          ;; added by EG as an extension to SRFI-19
          date=?
          date<?
          date>?
          date<=?
          date>=?)

;; Save the original definition of current-time since it will be changed later
(define %stklos-current-time (symbol-value 'current-time (find-module 'SCHEME)))


;;;
;;; CONSANTS DEFINED BY THE SRFI
;;;
(define time-tai 'time-tai)
(define time-utc 'time-utc)
(define time-monotonic 'time-monotonic)
(define time-thread 'time-thread)
(define time-process 'time-process)
(define time-duration 'time-duration)


;;;
;;;-- LOCALE dependent constants
;;;

(define tm:locale-number-separator ".")

(define tm:locale-abbr-weekday-vector (vector "Sun" "Mon" "Tue" "Wed"
                                             "Thu" "Fri" "Sat"))
(define tm:locale-long-weekday-vector (vector "Sunday" "Monday"
                                             "Tuesday" "Wednesday"
                                             "Thursday" "Friday"
                                             "Saturday"))
;; note empty string in 0th place.
(define tm:locale-abbr-month-vector   (vector "" "Jan" "Feb" "Mar"
                                             "Apr" "May" "Jun" "Jul"
                                             "Aug" "Sep" "Oct" "Nov"
                                             "Dec"))
(define tm:locale-long-month-vector   (vector "" "January" "February"
                                             "March" "April" "May"
                                             "June" "July" "August"
                                             "September" "October"
                                             "November" "December"))

(define tm:locale-pm "PM")
(define tm:locale-am "AM")

;; See date->string
(define tm:locale-date-time-format "~a ~b ~d ~H:~M:~S~z ~Y")
(define tm:locale-short-date-format "~m/~d/~y")
(define tm:locale-time-format "~H:~M:~S")
(define tm:iso-8601-date-time-format "~Y-~m-~dT~H:~M:~S~z")


;;;
;;;
;;;

;;-- Miscellaneous Constants.
;;-- only the tm:tai-epoch-in-jd might need changing if
;;   a different epoch is used.

(define tm:nano 1000000000)
(define tm:sid  86400)    ; seconds in a day
(define tm:sihd 43200)    ; seconds in a half day
(define tm:tai-epoch-in-jd 4881175/2) ; julian day number for 'the epoch'


;;;
;;; ERROR SYSTEM
;;;

(define tm:time-error-types
  '(invalid-clock-type
    unsupported-clock-type
    incompatible-time-types
    not-duration
    dates-are-immutable
    bad-date-format-string
    bad-date-template-string
    invalid-month-specification
    ))

(define (tm:time-error caller type value)
  (if (member type tm:time-error-types)
      (if value
          (error caller "TIME-ERROR type ~S: ~S" type value)
          (error caller "TIME-ERROR type ~S" type))
      (error caller "TIME-ERROR unsupported error type ~S" type)))


;;;
;;; COPY-TIME
;;;

(define (copy-time time)
  (make-time (time-type time) (time-nanosecond time) (time-second time)))

;;;
;;; CURRENT-TIME VARIATIONS
;;;

#|
 Current Monotonic Time.

 TAI is monotonic, so we use it.

 RETURNS: time structure.

stklos> (describe (tm:current-time-monotonic))
#[struct %time 140482692540672] is an instance of the structure type %time.
Slots are:
     type = time-monotonic
     nanosecond = 220412254
     second = 1653363842
|#
(define (tm:current-time-monotonic)
  (let ((t (current-time 'time-tai)))
    (set-time-type! t time-monotonic)
    t))


#|
  UNIMPLEMENTED
|#
(define (tm:current-time-thread)
  (tm:time-error 'current-time 'unsupported-clock-type 'time-thread))




(define (clock-ms)
  (exact (floor (* (clock) 1000))))

#|
 FIXME: check
|#
(define (tm:current-time-ms-time time-type proc)
  (let ((current-ms (proc)))
    (make-time time-type
               (* (remainder current-ms tm:nano) tm:nano)
               (quotient current-ms tm:nano)
               )))

#|
 Current process time

 RETURNS: time structure.

 stklos> (describe  (tm:current-time-process))
 #[struct %time 140482688357408] is an instance of the structure type %time.
 Slots are:
      type = time-process
      nanosecond = 199902000000000
      second = 0
|#
(define (tm:current-time-process)
  (tm:current-time-ms-time time-process clock-ms))


#|
;; THIS DOCUMENTATION WOULD OVERRIDE THE ONE IN DATE.STK. REMOVED.
 * (current-time [type])
 *
 * Current time, of type time, which defaults to TIME-UTC.
 *
 * @lisp
 * (describe (current-time))
 *
 * #[struct %time 140482689969104] is an instance of the structure type %time.
 * Slots are:
 *      type = time-utc
 *      nanosecond = 833635568
 *      second = 1653363915
 *
 * (describe (current-time 'time-tai))
 *
 *  #[struct %time 140482689994944] is an instance of the structure type %time.
 * Slots are:
 *      type = time-tai
 *      nanosecond = 175448417
 *      second = 1653363957
 * @end lisp
 *
 * Available time types are |time-utc|, |time-tai|, |time-monotonic|
 * and |time-process|.

|#
(define (tm:current-time :optional (clock-type time-utc))
  (cond
    ((eq? clock-type time-tai) (current-time 'time-tai))
    ((eq? clock-type time-utc) (current-time)) ; default is UTC
    ((eq? clock-type time-monotonic) (tm:current-time-monotonic))
    ((eq? clock-type time-thread) (tm:current-time-thread))
    ((eq? clock-type time-process) (tm:current-time-process))
    (else (tm:time-error 'current-time 'invalid-clock-type clock-type))))




;;;
;;; TIME RESOLUTION
;;;


;; -- Time Resolution
;; This is the resolution of the clock in nanoseconds.
;; This will be implementation specific.

#|
<doc EXT time-resolution
 * (time-resolution [time-type])
 *
 * Clock resolution, in nanoseconds, of the system clock of type type
 * |time-type|, which defaults to |TIME-UTC|.
 *
 * @lisp
 * (time-resolution)              => 1000000
 * (time-resolution time-process) => 1000000
 * (time-resolution time-tai)     => 1000000
 * @end lisp
doc>
|#
(define (time-resolution :optional (clock-type time-utc))
  (cond
    ((eq? clock-type time-tai) 1000000)
    ((eq? clock-type time-utc) 1000000)
    ((eq? clock-type time-monotonic) 1000000)
    ;((eq? clock-type time-thread) 1000)
    ((eq? clock-type time-process) 1000000)
    (else (tm:time-error 'time-resolution 'invalid-clock-type clock-type))))

;;;
;;; TIME COMPARISONS
;;;


(define (tm:time-compare-check time1 time2 caller)
  (if (or (not (and (time? time1) (time? time2)))
          (not (eq? (time-type time1) (time-type time2))))
      (tm:time-error caller 'incompatible-time-types #f)
      #t))

#|
<doc time<=? time<? time=? time>=? time>?
 * (time<=? time1 time2)
 * (time<? time1 time2)
 * (time=? time1 time2)
 * (time>=? time1 time2)
 * (time>? time1 time2)
 *
 * These are SRFI-19 predicates used to compare times. They return:
 *
 * time<=? : `#t` if |time1| is before or at (less than or equal to) |time2|, `#f` otherwise.
 * time<? :  `#t` if |time1| is before (less than) |time2|, `#f` otherwise.
 * time=? :  `#t` if |time1| at (equal) |time2|, `#f` otherwise.
 * time>=? : `#t` if |time1| is at or after (greater than or equal to) |time2|, `#f` otherwise.
 * time>? :  `#t` if |time1| is after (greater than) |time2|, `#f` otherwise.
 *
 * An attempt to compare times of different will raise an error.
doc>
|#
(define (time=? time1 time2)
  (tm:time-compare-check time1 time2 'time=?)
  (and (= (time-second time1) (time-second time2))
       (= (time-nanosecond time1) (time-nanosecond time2))))

(define (time>? time1 time2)
  (tm:time-compare-check time1 time2 'time>?)
  (or (> (time-second time1) (time-second time2))
      (and (= (time-second time1) (time-second time2))
           (> (time-nanosecond time1) (time-nanosecond time2)))))

(define (time<? time1 time2)
  (tm:time-compare-check time1 time2 'time<?)
  (or (< (time-second time1) (time-second time2))
      (and (= (time-second time1) (time-second time2))
           (< (time-nanosecond time1) (time-nanosecond time2)))))

(define (time>=? time1 time2)
  (tm:time-compare-check time1 time2 'time>=?)
  (or (> (time-second time1) (time-second time2))
      (and (= (time-second time1) (time-second time2))
           (>= (time-nanosecond time1) (time-nanosecond time2)))))

(define (time<=? time1 time2)
  (tm:time-compare-check time1 time2 'time<=?)
  (or (< (time-second time1) (time-second time2))
      (and (= (time-second time1) (time-second time2))
           (<= (time-nanosecond time1) (time-nanosecond time2)))))

;;;
;;; TIME ARITHMETIC
;;;

(define (tm:time->nanoseconds time)
  (define (sign1 n)
    (if (negative? n) -1 1))
  (+ (* (time-second time) tm:nano)
     (time-nanosecond time)))

(define (tm:nanoseconds->time time-type nanoseconds)
  (make-time time-type
             (remainder nanoseconds tm:nano)
             (quotient nanoseconds tm:nano)))

(define (tm:nanoseconds->values nanoseconds)
  (values (abs (remainder nanoseconds tm:nano))
          (quotient nanoseconds tm:nano)))

(define (tm:time-difference time1 time2 time3)
  (if (or (not (and (time? time1) (time? time2)))
          (not (eq? (time-type time1) (time-type time2))))
      (tm:time-error 'time-difference 'incompatible-time-types #f)
      (let ( (sec-diff  (- (time-second time1)     (time-second time2)))
             (nsec-diff (- (time-nanosecond time1) (time-nanosecond time2))) )
        (set-time-type! time3 time-duration)
        (if (negative? nsec-diff)
            (begin
              (set-time-second! time3 (- sec-diff 1))
              (set-time-nanosecond! time3 (+ tm:nano nsec-diff)))
            (begin
              (set-time-second! time3 sec-diff)
              (set-time-nanosecond! time3 nsec-diff)))
        time3)))

#|
<doc EXT time-difference
 * (time-difference time1 time2)
 * (time-difference! time1 time2)
 *
 * These are SRFI-19 procdures return the time duration (as an object of type |time-duration|)
 * between |time1| and |time2|. It is an error if |time1| and |time2| are of different time types.
 *
 * |Time-Difference| creats a new time object, while |Time-Difference!| may use |time1| to
 * create the resulting object.
doc>
|#
(define (time-difference time1 time2)
  (tm:time-difference time1 time2 (make-time 'time-duration 0 0)))

(define (time-difference! time1 time2)
  (tm:time-difference time1 time2 time1))

(define (tm:add-duration time1 duration time3)
  (if (not (and (time? time1) (time? duration)))
      (tm:time-error 'add-duration 'incompatible-time-types #f))
  (if (not (eq? (time-type duration) time-duration))
      (tm:time-error 'add-duration 'not-duration duration)
      (let ( (sec-plus (+ (time-second time1) (time-second duration)))
             (nsec-plus (+ (time-nanosecond time1) (time-nanosecond duration))) )
        (let ((r (remainder nsec-plus tm:nano))
              (q (quotient nsec-plus tm:nano)))
                                        ; (set-time-type! time3 (time-type time1))
          (if (negative? r)
              (begin
                (set-time-second! time3 (+ sec-plus q -1))
                (set-time-nanosecond! time3 (+ tm:nano r)))
              (begin
                (set-time-second! time3 (+ sec-plus q))
                (set-time-nanosecond! time3 r)))
          time3))))

(define (add-duration time1 duration)
  (tm:add-duration time1 duration (make-time (time-type time1) 0 0)))

(define (add-duration! time1 duration)
  (tm:add-duration time1 duration time1))

(define (tm:subtract-duration time1 duration time3)
  (if (not (and (time? time1) (time? duration)))
      (tm:time-error 'add-duration 'incompatible-time-types #f))
  (if (not (eq? (time-type duration) time-duration))
      (tm:time-error 'add-duration 'not-duration duration)
      (let ( (sec-minus  (- (time-second time1) (time-second duration)))
             (nsec-minus (- (time-nanosecond time1) (time-nanosecond duration))) )
        (let ((r (remainder nsec-minus tm:nano))
              (q (quotient nsec-minus tm:nano)))
          (if (negative? r)
              (begin
                (set-time-second! time3 (- sec-minus q 1))
                (set-time-nanosecond! time3 (+ tm:nano r)))
              (begin
                (set-time-second! time3 (- sec-minus q))
                (set-time-nanosecond! time3 r)))
          time3))))

(define (subtract-duration time1 duration)
  (tm:subtract-duration time1 duration (make-time (time-type time1) 0 0)))

(define (subtract-duration! time1 duration)
  (tm:subtract-duration time1 duration time1))

;;;
;;; TIME CONVERSIONS
;;;

;; TAI <-> UTC are dealt with in date.stk, the rest is here

(define (time-monotonic->time-utc time-in)
  (if (not (eq? (time-type time-in) time-monotonic))
      (tm:time-error 'time-monotonic->time-utc 'incompatible-time-types time-in))
  (let ((ntime (copy-time time-in)))
    (set-time-type! ntime time-tai)
    (%time-tai->time-utc! ntime ntime 'time-monotonic->time-utc)))

(define (time-monotonic->time-utc! time-in)
  (if (not (eq? (time-type time-in) time-monotonic))
      (tm:time-error 'time-monotonic->time-utc! 'incompatible-time-types time-in))
  (let ((ntime (copy-time time-in)))
    (set-time-type! time-in time-tai)
    (%time-tai->time-utc! ntime ntime 'time-monotonic->time-utc)))

(define (time-monotonic->time-tai time-in)
  (if (not (eq? (time-type time-in) time-monotonic))
      (tm:time-error 'time-monotonic->time-tai  'incompatible-time-types time-in))
  (let ((ntime (copy-time time-in)))
    (set-time-type! ntime time-tai)
    ntime))

(define (time-monotonic->time-tai! time-in)
  (if (not (eq? (time-type time-in) time-monotonic))
      (tm:time-error 'time-monotonic->time-tai! 'incompatible-time-types time-in))
  (set-time-type! time-in time-tai)
  time-in)

(define (time-utc->time-monotonic time-in)
  (if (not (eq? (time-type time-in) time-utc))
      (tm:time-error 'time-utc->time-monotonic 'incompatible-time-types time-in))
  (let ((ntime (%time-utc->time-tai! time-in (make-time time-tai 0 0)
                                       'time-utc->time-monotonic)))
    (set-time-type! ntime time-monotonic)
    ntime))


(define (time-utc->time-monotonic! time-in)
  (if (not (eq? (time-type time-in) time-utc))
      (tm:time-error 'time-utc->time-monotonic! 'incompatible-time-types time-in))
  (let ((ntime (%time-utc->time-tai! time-in time-in
                                       'time-utc->time-monotonic!)))
    (set-time-type! ntime time-monotonic)
    ntime))


(define (time-tai->time-monotonic time-in)
  (if (not (eq? (time-type time-in) time-tai))
      (tm:time-error 'time-tai->time-monotonic 'incompatible-time-types time-in))
  (let ((ntime (copy-time time-in)))
    (set-time-type! ntime time-monotonic)
    ntime))

(define (time-tai->time-monotonic! time-in)
  (if (not (eq? (time-type time-in) time-tai))
      (tm:time-error 'time-tai->time-monotonic! 'incompatible-time-types time-in))
  (set-time-type! time-in time-monotonic)
  time-in)

;;;
;;; DATEs
;;;

(define tm:make-date (symbol-value 'make-date (find-module 'SCHEME)))

(define date-zone-offset date-tz)

;; redefine setters

(define (tm:set-date-nanosecond! d n)  (struct-set! d 'nanosecond n))
(define (tm:set-date-second! d s)      (struct-set! d 'second s))
(define (tm:set-date-minute! d m)      (struct-set! d 'minute m))
(define (tm:set-date-hour! d h)        (struct-set! d 'hour h))
(define (tm:set-date-day! d day)       (struct-set! d 'day day))
(define (tm:set-date-month! d m)       (struct-set! d 'month m))
(define (tm:set-date-year! d y)        (struct-set! d 'year y))
(define (tm:set-date-zone-offset! d z) (struct-set! d 'zone-offset z))

;; We don't define the set-date-*! mutators, since they are not exported
;; and not in the spec.
;; The reference implementation defines them only to issue errors, telling
;; the user that dates are immutable -- which I think is not necessary.
;; --jpellegrini




;; gives the julian day which starts at noon.
(define (tm:encode-julian-day-number day month year)
  (let* ((a (quotient (- 14 month) 12))
         (y (- (+ year 4800) a (if (negative? year) -1  0)))
         (m (- (+ month (* 12 a)) 3)))
    (+ day
       (quotient (+ (* 153 m) 2) 5)
       (* 365 y)
       (quotient y 4)
       (- (quotient y 100))
       (quotient y 400)
       -32045)))

(define (tm:split-real r)
  (if (integer? r) (values r 0)
      (let ((l (truncate r)))
        (values l (- r l)))))

;; gives the seconds/date/month/year
(define (tm:decode-julian-day-number jdn)
  (let* ((days (truncate jdn))
         (a (+ days 32044))
         (b (quotient (+ (* 4 a) 3) 146097))
         (c (- a (quotient (* 146097 b) 4)))
         (d (quotient (+ (* 4 c) 3) 1461))
         (e (- c (quotient (* 1461 d) 4)))
         (m (quotient (+ (* 5 e) 2) 153))
         (y (+ (* 100 b) d -4800 (quotient m 10))))
    (values ; seconds date month year
     (* (- jdn days) tm:sid)
     (+ e (- (quotient (+ (* 153 m) 2) 5)) 1)
     (+ m 3 (* -12 (quotient m 10)))
     (if (>= 0 y) (- y 1) y))
    ))



;;;
;;; TIME -> DATE
;;;


;; special thing -- ignores nanos
(define (tm:time->julian-day-number seconds tz-offset)
  (+ (/ (+ seconds
           tz-offset
           tm:sihd)
        tm:sid)
     tm:tai-epoch-in-jd))



(define (tm:find proc l)
  (if (null? l)
      #f
      (if (proc (car l))
          #t
          (tm:find proc (cdr l)))))

;; Checks if a TAI second is right before a leap second, which we
;; need to know in order to adjust dates.
(define (tm:tai-before-leap-second? second)
  (tm:find (lambda (x)
             (= second (- (+ (car x) (cdr x)) 1)))
           %leap-second-table))

(define (tm:time->date time tz-offset ttype)
  (when (not (eq? (time-type time) ttype))
      (tm:time-error 'time->date 'incompatible-time-types  time))
  (let* ( (offset (if (null? tz-offset)
                      (local-timezone-offset)
                      (car tz-offset))))
    (receive (secs date month year)
        (tm:decode-julian-day-number
         (tm:time->julian-day-number (time-second time) offset))
      (let* ( (hours    (quotient secs (* 60 60)))
              (rem      (remainder secs (* 60 60)))
              (minutes  (quotient rem 60))
              (seconds  (remainder rem 60)) )
        (tm:make-date (time-nanosecond time)
                      seconds
                      minutes
                      hours
                      date
                      month
                      year
                      offset)))))


(define (time-tai->date time . tz-offset)
  (if (tm:tai-before-leap-second? (time-second time))
      ;; if it's *right* before the leap, we need to pretend to subtract a second ...
      (let ((d (tm:time->date (subtract-duration! (time-tai->time-utc time)
                                                  (make-time time-duration 0 1))
                              tz-offset time-utc)))
        (tm:set-date-second! d 60)
        d)
        (tm:time->date (time-tai->time-utc time) tz-offset time-utc)))

(define (time-utc->date time . tz-offset)
  (tm:time->date time tz-offset time-utc))

;; again, time-monotonic is the same as time tai
;; we just use time-tai->date
(define (time-monotonic->date time . tz-offset)
  (if (null? tz-offset)
      (time-tai->date (time-monotonic->time-tai time))
      (time-tai->date (time-monotonic->time-tai time) (car tz-offset))))


;;;
;;; DATE -> TIME
;;;

(define (date->time-utc date)
  (let ( (nanosecond (date-nanosecond date))
         (second (date-second date))
         (minute (date-minute date))
         (hour (date-hour date))
         (day (date-day date))
         (month (date-month date))
         (year (date-year date))
         (offset (let ((o (date-zone-offset date))) (if (number? o) o 0))))
    (let ( (jdays (- (tm:encode-julian-day-number day month year)
                     tm:tai-epoch-in-jd)) )
      (make-time
       time-utc
       nanosecond
       (+ (* (- jdays 1/2) 24 60 60)
          (* hour 60 60)
          (* minute 60)
          second
          (- offset))
       ))))

(define (date->time-tai date)
  (time-utc->time-tai! (date->time-utc date)))

(define (date->time-monotonic date)
  (time-utc->time-monotonic! (date->time-utc date)))



(define (tm:leap-year? year)
  (or (= (modulo year 400) 0)
      (and (= (modulo year 4) 0) (not (= (modulo year 100) 0)))))

(define (leap-year? date)
  (tm:leap-year? (date-year date)))


;; tm:year-day fixed: adding wrong number of days.
(define  tm:month-assoc '((0 . 0) (1 . 31)  (2 . 59)   (3 . 90)   (4 . 120)
                          (5 . 151) (6 . 181)  (7 . 212)  (8 . 243)
                          (9 . 273) (10 . 304) (11 . 334)))

(define (tm:year-day day month year)
  (let ((days-pr (assoc (- month 1) tm:month-assoc)))
    (if (not days-pr)
        (tm:time-error 'date-year-day 'invalid-month-specification month))
    (if (and (tm:leap-year? year) (> month 2))
        (+ day (cdr days-pr) 1)
        (+ day (cdr days-pr)))))

(define (date-year-day date)
  (tm:year-day (date-day date) (date-month date) (date-year date)))

(define (tm:week-day day month year)
  (let* ((a (quotient (- 14 month) 12))
         (y (- year a))
         (m (+ month (* 12 a) -2)))
    (modulo (+ day y (quotient y 4) (- (quotient y 100))
               (quotient y 400) (quotient (* 31 m) 12))
            7)))

(define (date-week-day date)
  (tm:week-day (date-day date) (date-month date) (date-year date)))

(define (tm:days-before-first-week date day-of-week-starting-week)
    (let* ( (first-day (tm:make-date 0 0 0 0
                                  1
                                  1
                                  (date-year date)
                                  #f))
            (fdweek-day (date-week-day first-day))  )
      (modulo (- day-of-week-starting-week fdweek-day)
              7)))

(define (date-week-number date day-of-week-starting-week)
  (quotient (- (date-year-day date)
               (tm:days-before-first-week  date day-of-week-starting-week))
            7))

;; tm:date-week-number-iso is used for formatting the date with the ~V
;; directive. It is different from date-week-number.
;; The following implementation was taken from Gauche Scheme.
;; -- jpellegrini
;;
(define (tm:date-week-number-iso date)
  ;; The week with the year's first Thursday is week 01.
  (let* ((first-day-of-the-week (tm:week-day 1 1 (date-year date)))
         (offset (if (> first-day-of-the-week 4) 0 1))
         ;; -2: decrement one day to compensate 1-origin of date-year-day,
         ;; and decrement one more day for Sunday belongs to the previous week.
         (w (+ (floor-quotient (+ (date-year-day date) first-day-of-the-week -2)
                               7)
               offset)))
    (cond ((zero? w)
           ;; date belongs to the last week of the previous year
           (tm:date-week-number-iso (make-date 0 0 0 0 31 12
                                               (- (date-year date) 1) #f)))
          ((and (= w 53)
                (<= (tm:week-day 1 1 (+ (date-year date) 1)) 4))
           ;; date belongs to the first week of the next year
           1)
          (else w))))


;;;
;;; DATE CONVERSIONS
;;;

(define (tm::current-date :optional (tz-offset (local-timezone-offset)))
  (time-utc->date (current-time time-utc) tz-offset))


;; given a 'two digit' number, find the year within 50 years +/-
(define (tm:natural-year n)
  (let* ( (current-year (date-year (tm::current-date)))
          (current-century (* (quotient current-year 100) 100)) )
    (cond
     ((>= n 100) n)
     ((<  n 0) n)
     ((<=  (- (+ current-century n) current-year) 50)
      (+ current-century n))
     (else
      (+ (- current-century 100) n)))))


(define (date->julian-day date)
  (let ( (nanosecond (date-nanosecond date))
         (second (date-second date))
         (minute (date-minute date))
         (hour (date-hour date))
         (day (date-day date))
         (month (date-month date))
         (year (date-year date)) )
    (+ (tm:encode-julian-day-number day month year)
       (- 1/2)
       (+ (/ (+ (* hour 60 60)
                (* minute 60)
                second
                (/ nanosecond tm:nano))
             tm:sid)))))

(define (date->modified-julian-day date)
  (- (date->julian-day date)
     4800001/2))


(define (time-utc->julian-day time)
  (if (not (eq? (time-type time) time-utc))
      (tm:time-error 'time->date 'incompatible-time-types  time))
  (+ (/ (+ (time-second time) (/ (time-nanosecond time) tm:nano))
        tm:sid)
     tm:tai-epoch-in-jd))

(define (time-utc->modified-julian-day time)
  (- (time-utc->julian-day time)
       4800001/2))

(define (time-tai->julian-day time)
  (if (not (eq? (time-type time) time-tai))
      (tm:time-error 'time->date 'incompatible-time-types  time))
  (+ (/ (+ (- (time-second time)
              (%leap-second-delta (time-second time)))
           (/ (time-nanosecond time) tm:nano))
        tm:sid)
     tm:tai-epoch-in-jd))

(define (time-tai->modified-julian-day time)
  (- (time-tai->julian-day time)
     4800001/2))

;; this is the same as time-tai->julian-day
(define (time-monotonic->julian-day time)
  (if (not (eq? (time-type time) time-monotonic))
      (tm:time-error 'time->date 'incompatible-time-types  time))
  (+ (/ (+ (- (time-second time)
              (%leap-second-delta (time-second time)))
           (/ (time-nanosecond time) tm:nano))
        tm:sid)
     tm:tai-epoch-in-jd))


(define (time-monotonic->modified-julian-day time)
  (- (time-monotonic->julian-day time)
     4800001/2))


(define (julian-day->time-utc jdn)
 (let ( (secs (* tm:sid (- jdn tm:tai-epoch-in-jd))) )
    (receive (seconds parts)
             (tm:split-real secs)
             (make-time time-utc
                        (inexact->exact (truncate (* parts tm:nano)))
                        (inexact->exact seconds)
                        ))))

(define (julian-day->time-tai jdn)
  (time-utc->time-tai! (julian-day->time-utc jdn)))

(define (julian-day->time-monotonic jdn)
  (time-utc->time-monotonic! (julian-day->time-utc jdn)))

(define (julian-day->date jdn :optional (tz-offset (local-timezone-offset)))
  (time-utc->date (julian-day->time-utc jdn) tz-offset))

(define (modified-julian-day->date jdn :optional (tz-offset (local-timezone-offset)))
  (julian-day->date (+ jdn 4800001/2) tz-offset))

(define (modified-julian-day->time-utc jdn)
  (julian-day->time-utc (+ jdn 4800001/2)))

(define (modified-julian-day->time-tai jdn)
  (julian-day->time-tai (+ jdn 4800001/2)))

(define (modified-julian-day->time-monotonic jdn)
  (julian-day->time-monotonic (+ jdn 4800001/2)))

(define (current-julian-day)
  (time-utc->julian-day (current-time time-utc)))

(define (current-modified-julian-day)
  (time-utc->modified-julian-day (current-time time-utc)))

;;;
;;; DATE FORMATTING
;;;

;; returns a string rep. of number N, of minimum LENGTH,
;; padded with character PAD-WITH. If PAD-WITH if #f,
;; no padding is done, and it's as if number->string was used.
;; if string is longer than LENGTH, it's as if number->string was used.

(define (tm:padding n pad-with length)
  (let* ( (str (number->string n))
          (str-len (string-length str)) )
    (if (or (> str-len length)
                (not pad-with))
        str
        (let* ( (new-str (make-string length pad-with))
                (new-str-offset (- (string-length new-str)
                                   str-len)) )
          (do ((i 0 (+ i 1)))
              ((>= i (string-length str)))
                (string-set! new-str (+ new-str-offset i)
                             (string-ref str i)))
          new-str))))

(define (tm:last-n-digits i n)
  (abs (remainder i (expt 10 n))))

(define (tm:locale-abbr-weekday n)
  (vector-ref tm:locale-abbr-weekday-vector n))

(define (tm:locale-long-weekday n)
  (vector-ref tm:locale-long-weekday-vector n))

(define (tm:locale-abbr-month n)
  (vector-ref tm:locale-abbr-month-vector n))

(define (tm:locale-long-month n)
  (vector-ref tm:locale-long-month-vector n))

(define (tm:vector-find needle haystack comparator)
  (let ((len (vector-length haystack)))
    (define (tm:vector-find-int index)
      (cond
       ((>= index len) #f)
       ((comparator needle (vector-ref haystack index)) index)
       (else (tm:vector-find-int (+ index 1)))))
    (tm:vector-find-int 0)))

(define (tm:locale-abbr-weekday->index string)
  (tm:vector-find string tm:locale-abbr-weekday-vector string=?))

(define (tm:locale-long-weekday->index string)
  (tm:vector-find string tm:locale-long-weekday-vector string=?))

(define (tm:locale-abbr-month->index string)
  (tm:vector-find string tm:locale-abbr-month-vector string=?))

(define (tm:locale-long-month->index string)
  (tm:vector-find string tm:locale-long-month-vector string=?))



;; The formatting of dates as strings include a "~Z" parameter, which
;; uses a procedure `tm:locale-print-time-zone` that is supposed to
;; return the "name" of the time zone. A single time-zone may have
;; more than one name, as it will likely be meaningful in more than
;; one country. For example, GMT-03:00 exists in Argentina (Buenos Aires),
;; Suriname (Paramaribo) and Brazil (São Paulo). There is no simple
;; and portable way to return a single string with a zone time name.
;;
;; Most Schemes return an empty string:
;;
;; (date->string  (make-date 0 0 0 0 31 12 2020 10800) "~Z")
;;  =>
;;     Chicken       ""
;;     Gauche        ""
;;     Guile         "+03:00"
;;     Racket        ""
;;     Sagittarius   ""
;;     Ypsilon       ""
;;
;; We do the same as Guile.
(define (tm:time-zone-name date)
  (let ((offset (date-tz date)))
    (if (zero? offset)
        "Z"
        (let* ((hours   (abs (quotient  offset 3600)))
               (minutes (abs (quotient (remainder offset 3600) 60)))
               (signal  (if (negative? offset) #\- #\+))
               (str     (format #f "~a~2f:~2f" signal hours minutes)))
          (string-map (lambda (x) (if (eq? x #\space) #\0 x)) str)))))

(define (tm:locale-print-time-zone date port)
  (display (time-zone-name date) port))







;; Again, locale specific.
(define (tm:locale-am/pm hr)
  (if (> hr 11) tm:locale-pm tm:locale-am))

(define (tm:tz-printer offset port)
  (cond
   ((= offset 0) (display "Z" port))
   ((negative? offset) (display "-" port))
   (else (display "+" port)))
  (if (not (= offset 0))
      (let ( (hours   (abs (quotient offset (* 60 60))))
             (minutes (abs (quotient (remainder offset (* 60 60)) 60))) )
        (display (tm:padding hours #\0 2) port)
        (display (tm:padding minutes #\0 2) port))))

;; A table of output formatting directives.
;; the first time is the format char.
;; the second is a procedure that takes the date, a padding character
;; (which might be #f), and the output port.
;;
(define tm:directives
  (list
   (cons #\~ (lambda (date pad-with port) (display #\~ port)))

   (cons #\a (lambda (date pad-with port)
               (display (tm:locale-abbr-weekday (date-week-day date))
                        port)))
   (cons #\A (lambda (date pad-with port)
               (display (tm:locale-long-weekday (date-week-day date))
                        port)))
   (cons #\b (lambda (date pad-with port)
               (display (tm:locale-abbr-month (date-month date))
                        port)))
   (cons #\B (lambda (date pad-with port)
               (display (tm:locale-long-month (date-month date))
                        port)))
   (cons #\c (lambda (date pad-with port)
               (display (date->string date tm:locale-date-time-format) port)))
   (cons #\d (lambda (date pad-with port)
               (display (tm:padding (date-day date)
                                    #\0 2)
                            port)))
   (cons #\D (lambda (date pad-with port)
               (display (date->string date "~m/~d/~y") port)))
   (cons #\e (lambda (date pad-with port)
               (display (tm:padding (date-day date)
                                    #\Space 2)
                        port)))
   (cons #\f (lambda (date pad-with port)
               (if (> (date-nanosecond date)
                      tm:nano)
                   (display (tm:padding (+ (date-second date) 1)
                                        pad-with 2)
                            port)
                   (display (tm:padding (date-second date)
                                        pad-with 2)
                            port))
               (receive (i f)
                        (tm:split-real (/
                                        (date-nanosecond date)
                                        tm:nano 1.0))
                        (let* ((ns (number->string f))
                               (le (string-length ns)))
                          (if (> le 2)
                              (begin
                                (display tm:locale-number-separator port)
                                (display (substring ns 2 le) port)))))))
   (cons #\h (lambda (date pad-with port)
               (display (date->string date "~b") port)))
   (cons #\H (lambda (date pad-with port)
               (display (tm:padding (date-hour date)
                                    pad-with 2)
                        port)))
   (cons #\I (lambda (date pad-with port)
               (let ((hr (date-hour date)))
                 (if (> hr 12)
                     (display (tm:padding (- hr 12)
                                          pad-with 2)
                              port)
                     (display (tm:padding hr
                                          pad-with 2)
                              port)))))
   (cons #\j (lambda (date pad-with port)
               (display (tm:padding (date-year-day date)
                                    pad-with 3)
                        port)))
   (cons #\k (lambda (date pad-with port)
               (display (tm:padding (date-hour date)
                                    #\Space 2)
                            port)))
   (cons #\l (lambda (date pad-with port)
               (let ((hr (if (> (date-hour date) 12)
                             (- (date-hour date) 12) (date-hour date))))
                 (display (tm:padding hr  #\Space 2)
                          port))))
   (cons #\m (lambda (date pad-with port)
               (display (tm:padding (date-month date)
                                    pad-with 2)
                        port)))
   (cons #\M (lambda (date pad-with port)
               (display (tm:padding (date-minute date)
                                    pad-with 2)
                        port)))
   (cons #\n (lambda (date pad-with port)
               (newline port)))
   (cons #\N (lambda (date pad-with port)
               (display (tm:padding (date-nanosecond date)
                                    pad-with 7)
                        port)))
   (cons #\p (lambda (date pad-with port)
               (display (tm:locale-am/pm (date-hour date)) port)))
   (cons #\r (lambda (date pad-with port)
               (display (date->string date "~I:~M:~S ~p") port)))
   (cons #\s (lambda (date pad-with port)
               (display (time-second (date->time-utc date)) port)))
   (cons #\S (lambda (date pad-with port)
               (if (> (date-nanosecond date)
                      tm:nano)
               (display (tm:padding (+ (date-second date) 1)
                                    pad-with 2)
                        port)
               (display (tm:padding (date-second date)
                                    pad-with 2)
                        port))))
   (cons #\t (lambda (date pad-with port)
               (display #\Tab port)))
   (cons #\T (lambda (date pad-with port)
               (display (date->string date "~H:~M:~S") port)))
   (cons #\U (lambda (date pad-with port)
               (if (> (tm:days-before-first-week date 0) 0)
                   (display (tm:padding (+ (date-week-number date 0) 1)
                                        #\0 2) port)
                   (display (tm:padding (date-week-number date 0)
                                        #\0 2) port))))
   (cons #\V (lambda (date pad-with port)
               (display (tm:padding (tm:date-week-number-iso date)
                                    #\0 2) port)))
   (cons #\w (lambda (date pad-with port)
               (display (date-week-day date) port)))
   (cons #\x (lambda (date pad-with port)
               (display (date->string date tm:locale-short-date-format) port)))
   (cons #\X (lambda (date pad-with port)
               (display (date->string date tm:locale-time-format) port)))
   (cons #\W (lambda (date pad-with port)
               (if (> (tm:days-before-first-week date 1) 0)
                   (display (tm:padding (+ (date-week-number date 1) 1)
                                        #\0 2) port)
                   (display (tm:padding (date-week-number date 1)
                                        #\0 2) port))))
   (cons #\y (lambda (date pad-with port)
               (display (tm:padding (tm:last-n-digits
                                     (date-year date) 2)
                                    pad-with
                                    2)
                        port)))
   (cons #\Y (lambda (date pad-with port)
               (display (date-year date) port)))
   (cons #\z (lambda (date pad-with port)
               (tm:tz-printer (date-zone-offset date) port)))
   (cons #\Z (lambda (date pad-with port)
               (tm:locale-print-time-zone date port)))
   (cons #\1 (lambda (date pad-with port)
               (display (date->string date "~Y-~m-~d") port)))
   (cons #\2 (lambda (date pad-with port)
               (display (date->string date "~H:~M:~S~z") port)))
   (cons #\3 (lambda (date pad-with port)
               (display (date->string date "~H:~M:~S") port)))
   (cons #\4 (lambda (date pad-with port)
               (display (date->string date "~Y-~m-~dT~H:~M:~S~z") port)))
   (cons #\5 (lambda (date pad-with port)
               (display (date->string date "~Y-~m-~dT~H:~M:~S") port)))
   ))


(define (tm:get-formatter char)
  (let ( (associated (assoc char tm:directives)) )
    (if associated (cdr associated) #f)))

(define (tm:date-printer date index format-string str-len port)
  (if (>= index str-len)
      (values)
      (let ( (current-char (string-ref format-string index)) )
        (if (not (char=? current-char #\~))
            (begin
              (display current-char port)
              (tm:date-printer date (+ index 1) format-string str-len port))
            (if (= (+ index 1) str-len) ; bad format string.
                (tm:time-error 'tm:date-printer 'bad-date-format-string
                               format-string)
                  (let ( (pad-char? (string-ref format-string (+ index 1))) )
                    (cond
                     ((char=? pad-char? #\-)
                      (if (= (+ index 2) str-len) ; bad format string.
                          (tm:time-error 'tm:date-printer 'bad-date-format-string
                                         format-string)
                          (let ( (formatter (tm:get-formatter
                                             (string-ref format-string
                                                         (+ index 2)))) )
                            (if (not formatter)
                                (tm:time-error 'tm:date-printer 'bad-date-format-string
                                         format-string)
                                (begin
                                  (formatter date #f port)
                                  (tm:date-printer date (+ index 3)
                                                   format-string str-len port))))))

                      ((char=? pad-char? #\_)
                      (if (= (+ index 2) str-len) ; bad format string.
                          (tm:time-error 'tm:date-printer 'bad-date-format-string
                                         format-string)
                          (let ( (formatter (tm:get-formatter
                                             (string-ref format-string
                                                         (+ index 2)))) )
                            (if (not formatter)
                                (tm:time-error 'tm:date-printer 'bad-date-format-string
                                               format-string)
                                (begin
                                  (formatter date #\Space port)
                                  (tm:date-printer date (+ index 3)
                                                   format-string str-len port))))))
                      (else
                       (let ( (formatter (tm:get-formatter
                                             (string-ref format-string
                                                         (+ index 1)))) )
                            (if (not formatter)
                                (tm:time-error 'tm:date-printer 'bad-date-format-string
                                               format-string)
                                (begin
                                  (formatter date #\0 port)
                                  (tm:date-printer date (+ index 2)
                                                   format-string str-len port))))))))))))


(define (date->string date :optional (fmt-str "~c"))
  (let ( (str-port (open-output-string)))
    (tm:date-printer date 0 fmt-str (string-length fmt-str) str-port)
    (get-output-string str-port)))

;;;
;;; STRING->DATE
;;;

(define (tm:char->int ch)
    (cond
     ((char=? ch #\0) 0)
     ((char=? ch #\1) 1)
     ((char=? ch #\2) 2)
     ((char=? ch #\3) 3)
     ((char=? ch #\4) 4)
     ((char=? ch #\5) 5)
     ((char=? ch #\6) 6)
     ((char=? ch #\7) 7)
     ((char=? ch #\8) 8)
     ((char=? ch #\9) 9)
     (else (tm:time-error 'bad-date-template-string
                          (list "Non-integer character" ch)))))

;; read an integer upto n characters long on port; upto -> #f if any length
(define (tm:integer-reader upto port)
    (define (accum-int port accum nchars)
      (let ((ch (peek-char port)))
        (if (or (eof-object? ch)
                (not (char-numeric? ch))
                (and upto (>= nchars  upto )))
            accum
            (accum-int port (+ (* accum 10) (tm:char->int (read-char
                                                           port))) (+
                                                                    nchars 1)))))
    (accum-int port 0 0))

(define (tm:make-integer-reader upto)
  (lambda (port)
    (tm:integer-reader upto port)))

;; read *exactly* n characters and convert to integer; could be padded
(define (tm:integer-reader-exact n port)
  (let ( (padding-ok #t) )
    (define (accum-int port accum nchars)
      (let ((ch (peek-char port)))
        (cond
         ((>= nchars n) accum)
         ((eof-object? ch)
          (tm:time-error 'string->date 'bad-date-template-string
                         "Premature ending to integer read."))
         ((char-numeric? ch)
          (set! padding-ok #f)
          (accum-int port (+ (* accum 10) (tm:char->int (read-char
                                                           port)))
                     (+ nchars 1)))
         (padding-ok
          (read-char port) ; consume padding
          (accum-int port accum (+ nchars 1)))
         (else ; padding where it shouldn't be
          (tm:time-error 'string->date 'bad-date-template-string
                          "Non-numeric characters in integer read.")))))
    (accum-int port 0 0)))


(define (tm:make-integer-exact-reader n)
  (lambda (port)
    (tm:integer-reader-exact n port)))

(define (tm:zone-reader port)
  (let ( (offset 0)
         (positive? #f) )
    (let ( (ch (read-char port)) )
      (if (eof-object? ch)
          (tm:time-error 'string->date 'bad-date-template-string
                         (list "Invalid time zone +/-" ch)))
      (if (or (char=? ch #\Z) (char=? ch #\z))
          0
          (begin
            (cond
             ((char=? ch #\+) (set! positive? #t))
             ((char=? ch #\-) (set! positive? #f))
             (else
              (tm:time-error 'string->date 'bad-date-template-string
                         (list "Invalid time zone +/-" ch))))
            (let ((ch (read-char port)))
              (if (eof-object? ch)
                  (tm:time-error 'string->date 'bad-date-template-string
                                  (list "Invalid time zone number" ch)))
              (set! offset (* (tm:char->int ch)
                              10 60 60)))
            (let ((ch (read-char port)))
              (if (eof-object? ch)
                  (tm:time-error 'string->date 'bad-date-template-string
                                 (list "Invalid time zone number" ch)))
              (set! offset (+ offset (* (tm:char->int ch)
                                        60 60))))
            (let ((ch (read-char port)))
              (if (eof-object? ch)
                  (tm:time-error 'string->date 'bad-date-template-string
                                 (list "Invalid time zone number" ch)))
              (set! offset (+ offset (* (tm:char->int ch)
                                        10 60))))
            (let ((ch (read-char port)))
              (if (eof-object? ch)
                  (tm:time-error 'string->date 'bad-date-template-string
                                 (list "Invalid time zone number" ch)))
              (set! offset (+ offset (* (tm:char->int ch)
                                        60))))
            (if positive? offset (- offset)))))))

;; looking at a char, read the char string, run thru indexer, return index
(define (tm:locale-reader port indexer)
  (let ( (string-port (open-output-string)) )
    (define (read-char-string)
      (let ((ch (peek-char port)))
        (if (char-alphabetic? ch)
            (begin (write-char (read-char port) string-port)
                   (read-char-string))
            (get-output-string string-port))))
    (let* ( (str (read-char-string))
            (index (indexer str)) )
      (if index index (tm:time-error 'string->date
                                     'bad-date-template-string
                                     (list "Invalid string for " indexer))))))

(define (tm:make-locale-reader indexer)
  (lambda (port)
    (tm:locale-reader port indexer)))

(define (tm:make-char-id-reader char)
  (lambda (port)
    (if (char=? char (read-char port))
        char
        (tm:time-error 'string->date
                       'bad-date-template-string
                       "Invalid character match."))))

;; A List of formatted read directives.
;; Each entry is a list.
;; 1. the character directive;
;; a procedure, which takes a character as input & returns
;; 2. #t as soon as a character on the input port is acceptable
;; for input,
;; 3. a port reader procedure that knows how to read the current port
;; for a value. Its one parameter is the port.
;; 4. a action procedure, that takes the value (from 3.) and some
;; object (here, always the date) and (probably) side-effects it.
;; In some cases (e.g., ~A) the action is to do nothing

(define tm:read-directives
  (let ( (ireader4 (tm:make-integer-reader 4))
         (ireader2 (tm:make-integer-reader 2))
         (ireaderf (tm:make-integer-reader #f))
         (eireader2 (tm:make-integer-exact-reader 2))
         (eireader4 (tm:make-integer-exact-reader 4))
         (locale-reader-abbr-weekday (tm:make-locale-reader
                                      tm:locale-abbr-weekday->index))
         (locale-reader-long-weekday (tm:make-locale-reader
                                      tm:locale-long-weekday->index))
         (locale-reader-abbr-month   (tm:make-locale-reader
                                      tm:locale-abbr-month->index))
         (locale-reader-long-month   (tm:make-locale-reader
                                      tm:locale-long-month->index))
         (char-fail (lambda (ch) #t))
         (do-nothing (lambda (val object) (values)))
         )

  (list
   (list #\~ char-fail (tm:make-char-id-reader #\~) do-nothing)
   (list #\a char-alphabetic? locale-reader-abbr-weekday do-nothing)
   (list #\A char-alphabetic? locale-reader-long-weekday do-nothing)
   (list #\b char-alphabetic? locale-reader-abbr-month
         (lambda (val object)
           (tm:set-date-month! object val)))
   (list #\B char-alphabetic? locale-reader-long-month
         (lambda (val object)
           (tm:set-date-month! object val)))
   (list #\d char-numeric? ireader2 (lambda (val object)
                                               (tm:set-date-day!
                                                object val)))
   (list #\e char-fail eireader2 (lambda (val object)
                                               (tm:set-date-day! object val)))
   (list #\h char-alphabetic? locale-reader-abbr-month
         (lambda (val object)
           (tm:set-date-month! object val)))
   (list #\H char-numeric? ireader2 (lambda (val object)
                                                        (tm:set-date-hour! object val)))
   (list #\k char-fail eireader2 (lambda (val object)
                                               (tm:set-date-hour! object val)))
   (list #\m char-numeric? ireader2 (lambda (val object)
                                               (tm:set-date-month! object val)))
   (list #\M char-numeric? ireader2 (lambda (val object)
                                               (tm:set-date-minute!
                                                object val)))
   (list #\S char-numeric? ireader2 (lambda (val object)
                                                        (tm:set-date-second! object val)))
   (list #\y char-fail eireader2
         (lambda (val object)
           (tm:set-date-year! object (tm:natural-year val))))
   (list #\Y char-numeric? ireader4 (lambda (val object)
                                               (tm:set-date-year! object val)))
   (list #\z (lambda (c)
               (or (char=? c #\Z)
                   (char=? c #\z)
                   (char=? c #\+)
                   (char=? c #\-)))
         tm:zone-reader (lambda (val object)
                          (tm:set-date-zone-offset! object val)))
   )))

(define (tm:string->date date index format-string str-len port template-string)
  (define (skip-until port skipper)
    (let ((ch (peek-char port)))
      (if (eof-object? port)
          (tm:time-error 'string->date 'bad-date-format-string template-string)
          (if (not (skipper ch))
              (begin (read-char port) (skip-until port skipper))))))
  (if (>= index str-len)
      (begin
        (values))
      (let ( (current-char (string-ref format-string index)) )
        (if (not (char=? current-char #\~))
            (let ((port-char (read-char port)))
              (if (or (eof-object? port-char)
                      (not (char=? current-char port-char)))
                  (tm:time-error 'string->date 'bad-date-format-string template-string))
              (tm:string->date date (+ index 1) format-string str-len port template-string))
            ;; otherwise, it's an escape, we hope
            (if (> (+ index 1) str-len)
                (tm:time-error 'string->date 'bad-date-format-string template-string)
                (let* ( (format-char (string-ref format-string (+ index 1)))
                        (format-info (assoc format-char tm:read-directives)) )
                  (if (not format-info)
                      (tm:time-error 'string->date 'bad-date-format-string template-string)
                      (begin
                        (let ((skipper (cadr format-info))
                              (reader  (caddr format-info))
                              (actor   (cadddr format-info)))
                          (skip-until port skipper)
                          (let ((val (reader port)))
                            (if (eof-object? val)
                                (tm:time-error 'string->date 'bad-date-format-string template-string)
                                (actor val date)))
                          (tm:string->date date (+ index 2) format-string  str-len port template-string))))))))))

(define (string->date input-string template-string)
  (define (tm:date-ok? date)
    (and (date-nanosecond date)
         (date-second date)
         (date-minute date)
         (date-hour date)
         (date-day date)
         (date-month date)
         (date-year date)
         (date-zone-offset date)))
  (let ( (newdate (tm:make-date 0 0 0 0 #f #f #f (local-timezone-offset))) )
    (tm:string->date newdate
                     0
                     template-string
                     (string-length template-string)
                     (open-input-string input-string)
                     template-string)
    (if (tm:date-ok? newdate)
        newdate
        (tm:time-error 'string->date 'bad-date-format-string
                       (list "Incomplete date read. " newdate template-string)))))

;;
;; EG: Comparisons function on dates
;;
(define (%date-test compare?)
  (lambda (d1 d2)
    (unless (date? d1) (error "bad date ~s" d1))
    (unless (date? d2) (error "bad date ~s" d2))
    (compare? (date->time-tai d1)
              (date->time-tai d2))))

(define date=?  (%date-test time=?))
(define date<?  (%date-test time<?))
(define date>?  (%date-test time>?))
(define date<=? (%date-test time<=?))
(define date>=? (%date-test time>=?))

) ;; END of module srfi/19

(provide "srfi-19")
