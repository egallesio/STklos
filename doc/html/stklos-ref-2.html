<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
 <style type="text/css">
  <!--
  tt { font-family: monospace }
  code { font-family: monospace }
  -->
 </style>
<link href="doc-style.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id='doc-title'>
STklos Reference Manual<hr align="center" width="10%">2. Expressions</div>
<table cellpadding="3" cellspacing="0" width="100%"><tr>
<td align="left" valign="top" width="20%" bgcolor="#204875">
<table width="100%" border="0" cellpadding="2" cellspacing="4" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr><th align="center" colspan="2" bgcolor="#ACE919"><font color="darkolivegreen"><br />Contents<br /><br /></font></th></tr>
<tr class="navnorm"><td align="center"></td><td align="left"><a href="stklos-ref.html#-document-54050">*Top*</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">1&nbsp;</td><td align="left"><a href="stklos-ref-1.html#Introduction">Introduction</a></td></tr>
<tr class="navsel"><td width="8%" align="left" valign="top">2&nbsp;</td><td align="left"><a href="stklos-ref-2.html#Expressions">Expressions</a><br /><table cellspacing="1" cellpadding="1" width="100%">
<tbody>
 <tr><td valign="top" align="left">2.1</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Literal-expressions">Literal expressions</td></tr>
 <tr><td valign="top" align="left">2.2</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Procedures">Procedures</td></tr>
 <tr><td valign="top" align="left">2.3</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Assignments">Assignments</td></tr>
 <tr><td valign="top" align="left">2.4</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Conditionals">Conditionals</td></tr>
 <tr><td valign="top" align="left">2.5</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Binding-Constructs">Binding Constructs</td></tr>
 <tr><td valign="top" align="left">2.6</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Sequencing">Sequencing</td></tr>
 <tr><td valign="top" align="left">2.7</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Iterations">Iterations</td></tr>
 <tr><td valign="top" align="left">2.8</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Delayed-Evaluation">Delayed Evaluation</td></tr>
 <tr><td valign="top" align="left">2.9</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Quasiquotation">Quasiquotation</td></tr>
 <tr><td valign="top" align="left">2.10</td><td colspan="4" width="100%"><a href="stklos-ref-2.html#Macros">Macros</td></tr>
</tbody>
</table>
</td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">3&nbsp;</td><td align="left"><a href="stklos-ref-3.html#Program-structure">Program structure</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">4&nbsp;</td><td align="left"><a href="stklos-ref-4.html#Standard-Procedures">Standard Procedures</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">5&nbsp;</td><td align="left"><a href="stklos-ref-5.html#Regular-Expressions">Regular Expressions</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">6&nbsp;</td><td align="left"><a href="stklos-ref-6.html#Pattern-Matching">Pattern Matching</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">7&nbsp;</td><td align="left"><a href="stklos-ref-7.html#Exceptions-and-Conditions">Exceptions and Conditions</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">8&nbsp;</td><td align="left"><a href="stklos-ref-8.html#STklos-Object-System">STklos Object System</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">9&nbsp;</td><td align="left"><a href="stklos-ref-9.html#Threads--Mutexes-and-Condition-Variables">Threads, Mutexes and Condition Variables</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">10&nbsp;</td><td align="left"><a href="stklos-ref-10.html#Customizations">Customizations</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">11&nbsp;</td><td align="left"><a href="stklos-ref-11.html#The-ScmPkg-Package-System">The ScmPkg Package System</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">12&nbsp;</td><td align="left"><a href="stklos-ref-12.html#Foreign-Function-Interface">Foreign Function Interface</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">13&nbsp;</td><td align="left"><a href="stklos-ref-13.html#Using-the-SLIB-package">Using the SLIB package</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">14&nbsp;</td><td align="left"><a href="stklos-ref-14.html#SRFIs">SRFIs</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">15&nbsp;</td><td align="left"><a href="stklos-ref-15.html#Index">Index</a></td></tr>
<tr class="navnorm"><td width="8%" align="left" valign="top">&nbsp;</td><td align="left"><a href="stklos-ref-16.html#Bibliography">Bibliography</a></td></tr>
</tbody></table>
</td>
<td align="left" valign="top">
<div class="chapterbody"><p>This chapter describes the main forms available in <span style="font-variant: small-caps">STklos</span>. <span style="font-variant: small-caps">R<sup>5</sup>RS</span>
constructions are given
very succinctly here for reference. See [<a href="stklos-ref-16.html#R5RS">13</a>] for a complete
description.</p><div class="sectiondiv"><div class="sectiontitle"><a name="Literal-expressions"></a>
<h3 id="Literal-expressions">2.1 Literal expressions</h3>
</div>
<div class="sectionbody"><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="quote"></a><a name="--index-entry-5892"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(quote &lt;datum&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">'&lt;datum&gt;</font></strong></code><br /><br />The quoting mechanism is identical to <span style="font-variant: small-caps">R<sup>5</sup>RS</span>, except that keywords
constants  evaluate &quot;to themselves&quot; as numerical constants, string
constants, character constants, and boolean constants
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>'<span class="source-string">&quot;abc&quot;</span>     &#8658;  <span class="source-string">&quot;abc&quot;</span>
<span class="source-string">&quot;abc&quot;</span>      &#8658;  <span class="source-string">&quot;abc&quot;</span>
'145932    &#8658;  145932
145932     &#8658;  145932
'#t        &#8658;  #t
#t         &#8658;  #t
<span class="source-key">:foo</span>       &#8658;  <span class="source-key">:foo</span>
':foo      &#8658;  <span class="source-key">:foo</span>
</pre></td></tr>
</tbody></table></blockquote>

<strong>Note:</strong> <span style="font-variant: small-caps">R<sup>5</sup>RS</span> requires to quote constant lists and
constant vectors. This is not necessary with <span style="font-variant: small-caps">STklos</span>.</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Procedures"></a>
<h3 id="Procedures">2.2 Procedures</h3>
</div>
<div class="sectionbody"><a name="--index-entry-5998"></a><a name="--index-entry-6002"></a><a name="--index-entry-6006"></a><a name="--index-entry-6010"></a><a name="--index-entry-6014"></a><a name="--index-entry-6018"></a><a name="--index-entry-6022"></a><a name="--index-entry-6026"></a><a name="--index-entry-6030"></a><a name="--index-entry-6034"></a><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="lambda"></a><a name="--index-entry-6040"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(lambda &lt;formals&gt; &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<br />A lambda expression evaluates to a procedure. <span style="font-variant: small-caps">STklos</span> lambda expression
have been extended to allow a optional and keyword parameters.
<code>&lt;formals&gt;</code> should have one of the following forms:
<ul><li>
<code>(&lt;variable1&gt; ...)</code>
<br />
The procedure takes a fixed number of arguments;
when the procedure is called, the arguments will be stored in the
bindings of the corresponding variables.  This form is identical to
<span style="font-variant: small-caps">R<sup>5</sup>RS</span>.
</li>
<li>
<code>&lt;variable&gt;</code>
<br />
The procedure takes any number of arguments; when the
procedure is called, the sequence of actual arguments is converted into
a newly allocated list, and the list is stored in the binding of the
<code>&lt;variable&gt;</code>. This form is identical to <span style="font-variant: small-caps">R<sup>5</sup>RS</span>.
</li>
<li>
<code>(&lt;variable1&gt; ... &lt;variablen&gt; . &lt;variablen+1&gt;)</code>
<br />
If a space-delimited
period precedes the last variable, then the procedure takes n or more
 arguments, where n is the number of formal arguments before the period
(there must be at least one). The value stored in the binding of the
last variable will be a newly allocated list of the actual arguments left
over after all the other actual arguments have been matched up against
the other formal arguments. This form is identical to <span style="font-variant: small-caps">R<sup>5</sup>RS</span>.
</li>
<li>
<code>(&lt;variable1 ... &lt;variablen&gt; [:optional ...] [:rest ...] [:key ...])</code>
<br />
This form is specific to <span style="font-variant: small-caps">STklos</span> and allows to have procedure with
optional and keyword parameters. The form <code>:optional</code> allows to specify
optional parameters. All the parameters specified after <code>:optional</code> to the end
of <code>&lt;formals&gt;</code> (or until a <code>:rest</code> or <code>:key</code>) are optional parameters. An
optional parameter can declared as:
<ul><li>
<code>variable</code>: if a value is passed when the procedure is called, it will be
stored in the binding of the corresponding variable, otherwise the value <code>#f</code>
will be stored in it.
</li>
<li>
<code>(variable value)</code>: if a value is passed when the procedure is called, it
will be stored in the binding of the corresponding variable, otherwise <code>value</code>
will be stored in it.
</li>
<li>
<code>(variable value test?)</code>: if a value is passed when the procedure is called, it
will be stored in the binding of the corresponding variable, otherwise <code>value</code>
will be stored in it. Furthermore, <code>test?</code> will be given the value <code>#t</code> if
a value is passed for the given variable, otherwise <code>test?</code> is set to <code>#f</code>
</li>
</ul>
<br /><br />

Hereafter are some examples using <code>:optional</code> parameters
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>((<strong>lambda</strong> (a b <span class="source-key">:optional</span> c d) (list a b c d)) 1 2)
                            &#8658; (1 2 #f #f)
((<strong>lambda</strong> (a b <span class="source-key">:optional</span> c d) (list a b c d)) 1 2 3)
                            &#8658; (1 2 3 #f)
((<strong>lambda</strong> (a b <span class="source-key">:optional</span> c (d 100)) (list a b c d)) 1 2 3)
                            &#8658; (1 2 3 100)
((<strong>lambda</strong> (a b <span class="source-key">:optional</span> c (d #f d?)) (list a b c d d?)) 1 2 3)
                            &#8658; (1 2 3 #f #f)
</pre></td></tr>
</tbody></table></blockquote>

The form <code>:rest</code> parameter is similar to the dot notation seen before.
It is used before an identifier to collects the parameters in a single
binding:
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>((<strong>lambda</strong> (a <span class="source-key">:rest</span> b) (list a b)) 1)
                            &#8658; (1 ())
((<strong>lambda</strong> (a <span class="source-key">:rest</span> b) (list a b)) 1 2)
                            &#8658; (1 (2))
((<strong>lambda</strong> (a <span class="source-key">:rest</span> b) (list a b)) 1 2 3)
                            &#8658; (1 (2 3))
</pre></td></tr>
</tbody></table></blockquote>

The form <code>:key</code> allows to use keyword parameter passing. All the parameters
specified after <code>:key</code> to the end of <code>&lt;formals&gt;</code> are keyword parameters. A
keyword  parameter can be declared using the three forms given for optional
parameters. Here are some examples illustrating how to declare and how to use
keyword parameters:
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>((<strong>lambda</strong> (a <span class="source-key">:key</span> b c) (list a b c)) 1 <span class="source-key">:c</span> 2 <span class="source-key">:b</span> 3)
                            &#8658; (1 3 2)
((<strong>lambda</strong> (a <span class="source-key">:key</span> b c) (list a b c)) 1 <span class="source-key">:c</span> 2)
                            &#8658; (1 #f 2)
((<strong>lambda</strong> (a <span class="source-key">:key</span> (b 100 b?) c) (list a b c b?)) 1 <span class="source-key">:c</span> 2)
                            &#8658; (1 100 2 #f)
</pre></td></tr>
</tbody></table></blockquote>

At last, here is an example showing <code>:optional</code> <code>:rest</code> and <code>:key</code> parameters
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-define">define</span> f (<strong>lambda</strong> (a <span class="source-key">:optional</span> b <span class="source-key">:rest</span> c <span class="source-key">:key</span> d e)
             (list a b c d e)))

(f 1)                       &#8658; (1 #f () #f #f)
(f 1 2)                     &#8658; (1 2 () #f #f)
(f 1 2 <span class="source-key">:d</span> 3 <span class="source-key">:e</span> 4)           &#8658; (1 2 (<span class="source-key">:d</span> 3 <span class="source-key">:e</span> 4) 3 4)
(f 1 <span class="source-key">:d</span> 3 <span class="source-key">:e</span> 4)             &#8658; (1 #f (<span class="source-key">:d</span> 3 <span class="source-key">:e</span> 4) 3 4)
</pre></td></tr>
</tbody></table></blockquote>

</li>
</ul></td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="closure-"></a><a name="--index-entry-6441"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(closure? obj)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> procedure</i></font></td></tr>
</tbody></table>
<br />Returns <code>#t</code> if <code>obj</code> is a procedure created with the <code>lambda</code> syntax and
<code>#f</code> otherwise.</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="case-lambda"></a><a name="--index-entry-6480"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(case-lambda &lt;clause&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<br />Each <code>&lt;clause&gt;</code> should have the form <code>(&lt;formals&gt; &lt;body&gt;)</code>, where
<code>&lt;formals&gt;</code> is a formal arguments list as for <code>lambda</code>.
Each <code>&lt;body&gt;</code> is a <code>&lt;tail-body&gt;</code>, as defined in <span style="font-variant: small-caps">R<sup>5</sup>RS</span>.
<br /><br />
A <code>case-lambda</code> expression evaluates to a procedure that
accepts a variable number of arguments and is lexically scoped in
the same manner as procedures resulting from <code>lambda</code>
expressions. When the procedure is called with some arguments
<code>v1 ... vk</code>, then the first <code>&lt;clause&gt;</code> for which the arguments agree
with <code>&lt;formals&gt;</code> is selected, where agreement is specified as for the
<code>&lt;formals&gt;</code> of a <code>lambda</code> expression. The variables of <code>&lt;formals&gt;</code>
are bound to fresh locations, the values <code>v1 ... vk</code> are stored in those
locations, the <code>&lt;body&gt;</code> is evaluated in the extended environment,
and the results of <code>&lt;body&gt;</code> are returned as the results of the
procedure call.
<br /><br />
It is an error for the arguments not to agree with the <code>&lt;formals&gt;</code>
of any <code>&lt;clause&gt;</code>.
<br /><br />
This form is defined in  <strong><a  class="http" href="http://srfi.schemers.org/srfi-16/srfi-16.html">SRFI-16</a></strong>
      (<em>Syntax for procedures of variable arity</em>).

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre> (<span class="source-define">define</span> plus
   (<strong>case-lambda</strong>
    (() 0)
    ((x) x)
    ((x y) (+ x y))
    ((x y z) (+ (+ x y) z))
    (args (apply + args))))

 (plus)                     &#8658; 0
 (plus 1)                   &#8658; 1
 (plus 1 2 3)               &#8658; 6

 ((<strong>case-lambda</strong>
   ((a) a)
   ((a b) (* a b)))
  1 2 3)                    &#8658; <span class="source-error">error</span>
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Assignments"></a>
<h3 id="Assignments">2.3 Assignments</h3>
</div>
<div class="sectionbody"><a name="--index-entry-6666"></a><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="set-"></a><a name="--index-entry-6672"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(set! &lt;variable&gt; &lt;expression&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">(set! (&lt;proc&gt; &lt;arg&gt; ...) &lt;expression&gt;)</font></strong></code><br /><br />The first form of <code>set!</code> is the <span style="font-variant: small-caps">R<sup>5</sup>RS</span> one:
<br /><br />
<code>&lt;Expression&gt;</code> is evaluated, and the resulting value is stored in
the location to which <code>&lt;variable&gt;</code> is bound. <code>&lt;Variable&gt;</code> must be bound
either in some region enclosing the <code>set!</code> expression or at top level.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-define">define</span> x 2)
(+ x 1)                   &#8658;  3
(<strong>set!</strong> x 4)                &#8658;  unspecified
(+ x 1)                   &#8658;  5
</pre></td></tr>
</tbody></table></blockquote>


The second form of <code>set!</code> is defined in  <strong><a  class="http" href="http://srfi.schemers.org/srfi-17/srfi-17.html">SRFI-17</a></strong>
      (<em>Generalized set!</em>):
<br /><br />
This special form <code>set!</code>
is extended so the first operand can be a procedure application, and not
just a variable. The procedure is typically one that extracts a component
from some data structure. Informally, when the procedure is called in the
first operand of <code>set!</code>, it causes the corresponding component to be
replaced by the second operand. For example,
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(set (vector-ref x i) v)
</pre></td></tr>
</tbody></table></blockquote>

would be equivalent to:
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(vector-set! x i v)
</pre></td></tr>
</tbody></table></blockquote>


Each procedure that may be used as the first operand to <code>set!</code> must have
a corresponding <em>setter</em> procedure. The procedure <code>setter</code> (see below)
takes a procedure and returns the corresponding setter procedure.
So,
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>set!</strong> (proc arg ...) value)
</pre></td></tr>
</tbody></table></blockquote>

is equivalent to the call
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>((setter proc) arg ... value)
</pre></td></tr>
</tbody></table></blockquote>


The result of the <code>set!</code> expression is unspecified.</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="setter"></a><a name="--index-entry-6841"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(setter proc)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> procedure</i></font></td></tr>
</tbody></table>
<br />Returns the setter associated to a <code>proc</code>. Setters are defined in the
 <strong><a  class="http" href="http://srfi.schemers.org/srfi-17/srfi-17.html">SRFI-17</a></strong>
      (<em>Generalized set!</em>) document. A setter proc, can be used in a generalized
assignment, as described in <code>set!</code>.
<br /><br />
To associate <code>s</code> to the procedure <code>p</code>, use the following form:
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>set!</strong> (setter p) s)
</pre></td></tr>
</tbody></table></blockquote>

For instance, we can write
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>set!</strong> (setter car) set-car!)
</pre></td></tr>
</tbody></table></blockquote>


The following standard procedures have pre-defined setters:
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>set!</strong> (car x) v)              == (set-car! x v)
(<strong>set!</strong> (cdr x) v)              == (set-cdr! x v)
(<strong>set!</strong> (string-ref x i) v)     == (string-set! x i v)
(<strong>set!</strong> (vector-ref x i) v)     == (vector-set! x i v)!
(<strong>set!</strong> (slot-ref x 'name) v)   == (slot-set! x 'name v)
(<strong>set!</strong> (struct-ref x 'name) v) == (struct-set! x 'name v)
</pre></td></tr>
</tbody></table></blockquote>

Furhermore, <a href="stklos-ref-4.html#Parameter-Objects">parameters objects</a>
are their own setter:
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(real-precision)              &#8658; 15
(<strong>set!</strong> (real-precision) 12)
(real-precision)              &#8658; 12
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Conditionals"></a>
<h3 id="Conditionals">2.4 Conditionals</h3>
</div>
<div class="sectionbody"><a name="--index-entry-6958"></a><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="if"></a><a name="--index-entry-6964"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(if &lt;test&gt; &lt;consequent&gt; &lt;alternate&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">(if &lt;test&gt; &lt;consequent&gt;)</font></strong></code><br /><br />An <code>if</code> expression is evaluated as follows: first, <code>&lt;test&gt;</code> is
evaluated.  If it yields a true value, then <code>&lt;consequent&gt;</code> is
evaluated and its value(s) is(are) returned.  Otherwise <code>&lt;alternate&gt;</code>
is evaluated and its value(s) is(are) returned.  If <code>&lt;test&gt;</code> yields a
false value and no <code>&lt;alternate&gt;</code> is specified, then the result of the
expression is <em>void</em>.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>  (<strong>if</strong> (&gt; 3 2) 'yes 'no)           &#8658;  yes
  (<strong>if</strong> (&gt; 2 3) 'yes 'no)           &#8658;  no
  (<strong>if</strong> (&gt; 3 2)
      (- 3 2)
      (+ 3 2))                    &#8658;  1
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="cond"></a><a name="--index-entry-7052"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(cond &lt;clause1&gt; &lt;clause2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />In a <code>cond</code>, each <code>&lt;clause&gt;</code> should be of the form

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-module">&lt;test&gt;</span> <span class="source-module">&lt;expression1&gt;</span> ...)
</pre></td></tr>
</tbody></table></blockquote>


where <code>&lt;test&gt;</code> is any expression.  Alternatively, a <code>&lt;clause&gt;</code> may be
of the form

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-module">&lt;test&gt;</span> &#8658; <span class="source-module">&lt;expression&gt;</span>)
</pre></td></tr>
</tbody></table></blockquote>


The last <code>&lt;clause&gt;</code> may be an &quot;else clause,&quot; which has the form
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>else</strong> <span class="source-module">&lt;expression1&gt;</span> <span class="source-module">&lt;expression2&gt;</span> ...)
</pre></td></tr>
</tbody></table></blockquote>


A cond expression is evaluated by evaluating the <code>&lt;test&gt;</code> expressions
of successive <code>&lt;clause&gt;</code>s in order until one of them evaluates to a
true value When a <code>&lt;test&gt;</code> evaluates to a true value, then the
remaining <code>&lt;expression&gt;</code>s in its <code>&lt;clause&gt;</code> are evaluated in order,
and the result(s) of the last <code>&lt;expression&gt;</code> in the <code>&lt;clause&gt;</code> is(are)
returned as the result(s) of the entire cond expression.  If the
selected <code>&lt;clause&gt;</code> contains only the <code>&lt;test&gt;</code> and no <code>&lt;expression&gt;</code>s,
then the value of the <code>&lt;test&gt;</code> is returned as the result.  If the
selected <code>&lt;clause&gt;</code> uses the &#8658; alternate form, then the
<code>&lt;expression&gt;</code> is evaluated.  Its value must be a procedure that
accepts one argument; this procedure is then called on the value of
the <code>&lt;test&gt;</code> and the value(s) returned by this procedure is(are)
returned by the cond expression.
<br /><br />
If all <code>&lt;test&gt;</code>s evaluate to false
values, and there is no else clause, then the result of the
conditional expression is <em>void</em>; if there is an else clause,
then its <code>&lt;expression&gt;</code>s are evaluated, and the value(s) of the last
one is(are) returned.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>  (<strong>cond</strong> ((&gt; 3 2) 'greater)
        ((&lt; 3 2) 'less))                    &#8658;  greater

  (<strong>cond</strong> ((&gt; 3 3) 'greater)
        ((&lt; 3 3) 'less)
        (<strong>else</strong> 'equal))                      &#8658;  equal

  (<strong>cond</strong> ((assv 'b '((a 1) (b 2))) &#8658; cadr)
        (<strong>else</strong> #f))                          &#8658;  2
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="case"></a><a name="--index-entry-7270"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(case &lt;key&gt; &lt;clause1&gt; &lt;clause2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>7</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />In a <code>case</code>, each <code>&lt;clause&gt;</code> should have the form

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>((<span class="source-module">&lt;datum1&gt;</span> ...) <span class="source-module">&lt;expression1&gt;</span> <span class="source-module">&lt;expression2&gt;</span> ...),
</pre></td></tr>
</tbody></table></blockquote>


where each <code>&lt;datum&gt;</code> is an external representation of some object.  All the
<code>&lt;datum&gt;</code>s must be distinct.  The last <code>&lt;clause&gt;</code> may be an &quot;else clause,&quot; which
has the form

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>    (<strong>else</strong> <span class="source-module">&lt;expression1&gt;</span> <span class="source-module">&lt;expression2&gt;</span> ...).
</pre></td></tr>
</tbody></table></blockquote>


A case expression is evaluated as follows. <code>&lt;Key&gt;</code> is evaluated and
its result is compared against each <code>&lt;datum&gt;</code>.  If the result of
evaluating <code>&lt;key&gt;</code> is equivalent (in the sense of eqv?) to a
<code>&lt;datum&gt;</code>, then the expressions in the corresponding <code>&lt;clause&gt;</code> are
evaluated from left to right and the result(s) of the last expression
in the <code>&lt;clause&gt;</code> is(are) returned as the result(s) of the case
expression.  If the result of evaluating <code>&lt;key&gt;</code> is different from
every <code>&lt;datum&gt;</code>, then if there is an else clause its expressions are
evaluated and the result(s) of the last is(are) the result(s) of the
case expression; otherwise the result of the case expression is <em>void</em>.

If the selected <code>&lt;clause&gt;</code> or else clause uses the <code>&#8658;</code> alternate
form, then the <code>expression</code> is evaluated. It is an error if
its value is not a procedure accepting one argument. This
procedure is then called on the value of the hkeyi and the
values returned by this procedure are returned by the case
expression.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>  (<strong>case</strong> (* 2 3)
    ((2 3 5 7) 'prime)
    ((1 4 6 8 9) 'composite))     &#8658;  composite
  (<strong>case</strong> (car '(c d))
    ((a) 'a)
    ((b) 'b))                     &#8658;  void
  (<strong>case</strong> (car '(c d))
    ((a e i o u) 'vowel)
    ((w y) 'semivowel)
    (<strong>else</strong> 'consonant))            &#8658;  consonant
  (<strong>case</strong> (car '(c d))
    ((a e i o u) 'vowel)
    ((w y) 'semivowel)
    (<strong>else</strong>  &#8658; (<strong>lambda</strong> (x) (x))))  &#8658;  c
</pre></td></tr>
</tbody></table></blockquote>

</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="and"></a><a name="--index-entry-7456"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(and &lt;test1&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />The <code>&lt;test&gt;</code> expressions are evaluated from left to right, and the
value of the first expression that evaluates to a false value is
returned.  Any remaining expressions are not evaluated.  If all the
expressions evaluate to true values, the value of the last expression
is returned.  If there are no expressions then <code>#t</code> is returned.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>  (and (= 2 2) (&gt; 2 1))           &#8658;  #t
  (and (= 2 2) (&lt; 2 1))           &#8658;  #f
  (and 1 2 'c '(f g))             &#8658;  (f g)
  (and)                           &#8658;  #t
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="or"></a><a name="--index-entry-7517"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(or &lt;test1&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />The <code>&lt;test&gt;</code> expressions are evaluated from left to right, and the
value of the first expression that evaluates to a true value is
returned.  Any remaining expressions are not evaluated.  If all
expressions evaluate to false values, the value of the last expression
is returned.  If there are no expressions then <code>#f</code> is returned.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>  (or (= 2 2) (&gt; 2 1))            &#8658;  #t
  (or (= 2 2) (&lt; 2 1))            &#8658;  #t
  (or #f #f #f)                   &#8658;  #f
  (or (memq 'b '(a b c))
      (/ 3 0))                    &#8658;  (b c)
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="when"></a><a name="--index-entry-7579"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(when &lt;test&gt; &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<br />If the <code>&lt;test&gt;</code> expression yields a true value, the <code>&lt;expression&gt;</code>s are
evaluated from left to right and the value of the last <code>&lt;expression&gt;</code> is
returned. Otherwise, <code>when</code> returns <em>void</em>.</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="unless"></a><a name="--index-entry-7622"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(unless &lt;test&gt; &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<br />If the <code>&lt;test&gt;</code> expression yields a false value, the <code>&lt;expression&gt;</code>s are
evaluated from left to right and the value of the last <code>&lt;expression&gt;</code> is
returned. Otherwise, <code>unless</code> returns <em>void</em>.</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Binding-Constructs"></a>
<h3 id="Binding-Constructs">2.5 Binding Constructs</h3>
</div>
<div class="sectionbody"><a name="--index-entry-7666"></a>The three binding constructs <code>let</code>, <code>let*</code>, and
<code>letrec</code> are available in STklos.
These constructs differ in the regions they establish for
their variable bindings.  In a <code>let</code> expression, the initial values are
computed before any of the variables become bound; in a <code>let*</code>
expression, the bindings and evaluations are performed sequentially; while in a
<code>letrec</code> expression, all the bindings are in effect while their initial
values are being computed, thus allowing mutually recursive definitions.
<br />
<span style="font-variant: small-caps">STklos</span> also provides a <code>fluid-let</code> form which is described below.<br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="let"></a><a name="--index-entry-7681"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(let &lt;bindings&gt; &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">(let &lt;variable&gt; &lt;bindings&gt; &lt;body&gt;)</font></strong></code><br /><br />In a <code>let</code>, <code>&lt;bindings&gt;</code> should have the form

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>((<span class="source-module">&lt;variable1&gt;</span> <span class="source-module">&lt;init1&gt;</span>) ...)
</pre></td></tr>
</tbody></table></blockquote>


where each <code>&lt;init&gt;</code> is an expression, and <code>&lt;body&gt;</code> should be a sequence of one or
more expressions.  It is an error for a <code>&lt;variable&gt;</code> to appear more than once in
the list of variables being bound.
<br /><br />
The <code>&lt;init&gt;</code>s are evaluated in the current environment (in some
unspecified order), the <code>&lt;variable&gt;</code>s are bound to fresh locations holding the
results, the <code>&lt;body&gt;</code> is evaluated in the extended environment, and the value(s)
of the last expression of <code>&lt;body&gt;</code> is(are) returned.  Each binding of a
<code>&lt;variable&gt;</code> has <code>&lt;body&gt;</code> as its region.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>let</strong> ((x 2) (y 3))
  (* x y))                      &#8658;  6

(<strong>let</strong> ((x 2) (y 3))
  (<strong>let</strong> ((x 7)
        (z (+ x y)))
    (* z x)))                   &#8658;  35
</pre></td></tr>
</tbody></table></blockquote>


The second form of <code>let</code>, which is generally called a <em>named let</em>,
is a variant on the syntax of let which provides a more general
looping construct than <code>do</code> (&#x40;pxref{do}) and may also be used to
express recursions. It has the same syntax and semantics as ordinary
let except that <code>&lt;variable&gt;</code> is bound within <code>&lt;body&gt;</code> to a procedure whose
formal arguments are the bound variables and whose body is <code>&lt;body&gt;</code>.
Thus the execution of <code>&lt;body&gt;</code> may be repeated by invoking the procedure
named by <code>&lt;variable&gt;</code>.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>let</strong> loop ((numbers '(3 -2 1 6 -5))
           (nonneg  '())
           (neg     '()))
  (<strong>cond</strong> ((null? numbers) (list nonneg neg))
        ((&gt;= (car numbers) 0)
           (loop (cdr numbers)
                 (cons (car numbers) nonneg)
                 neg))
        ((&lt; (car numbers) 0)
           (loop (cdr numbers)
                  nonneg
                  (cons (car numbers) neg)))))
   &#8658;  ((6 1 3) (-5 -2))
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="let-"></a><a name="--index-entry-7869"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(let* &lt;bindings&gt; &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />In a <code>let*</code>, <code>&lt;bindings&gt;</code> should have the same form as in a <code>let</code> (however, a
&lt;variable&gt; can appear more than once in the list of variables being bound).
<br /><br />
<code>Let*</code> is similar to <code>let</code>, but the bindings are performed sequentially
from left to right, and the region of a binding indicated by
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-module">&lt;variable&gt;</span> <span class="source-module">&lt;init&gt;</span>)
</pre></td></tr>
</tbody></table></blockquote>

is that part of the <code>let*</code> expression to the right of the binding.  Thus
the second binding is done in an environment in which the first binding is
visible, and so on.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>let</strong> ((x 2) (y 3))
  (<strong>let*</strong> ((x 7)
         (z (+ x y)))
    (* z x)))             &#8658;  70
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="letrec"></a><a name="--index-entry-7952"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(letrec &lt;bindings&gt; &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />&lt;bindings&gt; should have the form as in <code>let</code>.

The <code>&lt;variable&gt;</code>s are bound to fresh locations holding undefined
values, the <code>&lt;init&gt;</code>s are evaluated in the resulting environment (in
some unspecified order), each <code>&lt;variable&gt;</code> is assigned to the result
of the corresponding <code>&lt;init&gt;</code>, the <code>&lt;body&gt;</code> is evaluated in the
resulting environment, and the value(s) of the last expression in
<code>&lt;body&gt;</code> is(are) returned.  Each binding of a <code>&lt;variable&gt;</code> has the
entire <code>letrec</code> expression as its region, making it possible to define
mutually recursive procedures.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>letrec</strong> ((even? (<strong>lambda</strong> (n)
                  (<strong>if</strong> (zero? n)
                      #t
                      (odd? (- n 1)))))
         (odd?  (<strong>lambda</strong> (n)
                  (<strong>if</strong> (zero? n)
                      #f
                      (even? (- n 1))))))
  (even? 88))
                  &#8658;  #t
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="letrec-"></a><a name="--index-entry-8044"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(letrec* &lt;bindings&gt; &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>7</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />&lt;bindings&gt; should have the form as in <code>let</code> and body is a sequence
of zero or more definitions followed by one or more expressions.

The <code>&lt;variable&gt;</code>s are bound to fresh locations, each <code>variable</code> is
assigned in left-to-right order to the result of evaluating the
corresponding <code>init</code>, the <code>body</code> is evaluated in the resulting
environment, and the values of the last expression in <code>body</code> are
returned. Despite the left-to-right evaluation and assignment order,
each binding of a <code>variable</code> has the entire <code>letrec*</code> expression as its
region, making it possible to define mutually recursive procedures.
If it is not possible to evaluate each <code>init</code> without assigning or
referring to the value of the corresponding <code>variable</code> or the
<code>variable</code> of any of the bindings that follow it in <code>bindings</code>, it is
an error.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(letrec* ((p (<strong>lambda</strong> (x)
               (+ 1 (q (- x 1)))))
          (q(<strong>lambda</strong> (y)
              (<strong>if</strong> (zero? y)
                  0
                  (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)  &#8658; 5
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="let-values"></a><a name="--index-entry-8148"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(let-values ((&lt;formals&gt; &lt;expression&gt;) ...) &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>7</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />Each <code>&lt;formals&gt;</code> should be a formal arguments list as for a <code>lambda</code> expression.

The <code>&lt;expression&gt;</code>s are evaluated in the current environment,
the variables of the <code>&lt;formals&gt;</code> are bound to fresh locations, the return
values of the <code>&lt;expression&gt;</code>s are stored in the variables, the <code>&lt;body&gt;</code> is
evaluated in the extended environment, and the values of the last expression
of <code>&lt;body&gt;</code> are returned.

The matching of each <code>&lt;formals&gt;</code> to values is as for the matching of
<code>&lt;formals&gt;</code> to arguments in a <code>lambda</code> expression, and it is an error
for an <code>&lt;expression&gt;</code> to return a number of values that does not match
its corresponding <code>&lt;formals&gt;</code>.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(let-values (((root rem) (exact-integer-sqrt 32)))
   (* root rem))            &#8658;  35

(<strong>let</strong> ((a 'a) (b 'b) (x 'x) (y 'y))
   (let-values (((a b) (values x y))
                ((x y) (values a b)))
     (list a b x y)))      &#8658; (x y a b)
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="let--values"></a><a name="--index-entry-8253"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(let-values ((&lt;formals&gt; &lt;expression&gt;) ...) &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>7</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />Each <code>&lt;formals&gt;</code> should be a formal arguments list as for a <code>lambda</code> expression.

<code>let*-values</code> is similar to <code>let-values</code>, but the bindings are performed
sequentially from left to right, and the region of a binding indicated by
<code>(&lt;formals&gt; &lt;expression&gt;)</code> is that part of the <code>let*-values</code> expression to
the right of the binding. Thus the second binding is done in an environment
in which the first binding is visible, and so on.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>let</strong> ((a 'a) (b 'b) (x 'x) (y 'y))
   (let*-values (((a b) (values x y))
                ((x y) (values a b)))
     (list a b x y)))      &#8658; (x y x y)
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="define-values"></a><a name="--index-entry-8320"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(define-values formals expression)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>7</sup>RS</span> procedure</i></font></td></tr>
</tbody></table>
<br />The form <code>define-values</code> creates multiple definitions from a single expression
returning multiple values. Here, <code>expression</code> is evaluated, and the <code>formals</code>
are bound to the return values in the same way that the <code>formals</code> in a
lambda expression are matched to the arguments in a procedure call.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>let</strong> ()
  (define-values (x y) (exact-integer-sqrt 17))
  (list x y))                   &#8658; (4 1)

(<strong>let</strong> ()
   (define-values (x y) (values 1 2))
   (+ x y))                     &#8658; 3

(<strong>let</strong> ()
   (define-values (x . y) (values 1 2 3))
   (list x y)                  &#8658; (1 (2 3))
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="fluid-let"></a><a name="--index-entry-8396"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(fluid-let &lt;bindings&gt; &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<br />The <code>&lt;bindings&gt;</code> are evaluated in the current environment, in some
unspecified order, the current values of the variables present in
<code>&lt;bindings&gt;</code> are saved, and the new evaluated values are assigned to the
<code>&lt;bindings&gt;</code> variables. Once this is done, the expressions of <code>&lt;body&gt;</code>
are evaluated sequentially in the current environment; the value of the
last expression is the result of <code>fluid-let</code>. Upon exit, the stored
variables values are restored. An error is signalled if any of the
<code>&lt;bindings&gt;</code> variable is unbound.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>let*</strong> ((a 'out)
       (f (<strong>lambda</strong> () a)))
  (list (f)
        (fluid-let ((a 'in)) (f))
        (f))) &#8658; (out in out)
</pre></td></tr>
</tbody></table></blockquote>


When the body of a <code>fluid-let</code> is exited by invoking a continuation,
the new variable values are saved, and the variables are set to their old
values. Then, if the body is reentered by invoking a continuation, the old
values are saved and new values are restored. The following example illustrates
this behavior

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>let</strong> ((cont #f)
      (l    '())
      (a    'out))
  (<strong>set!</strong> l (cons a l))
  (fluid-let ((a 'in))
    (<strong>set!</strong> cont (call-with-current-continuation (<strong>lambda</strong> (k) k)))
    (<strong>set!</strong> l (cons a l)))
  (<strong>set!</strong> l (cons a l))

  (<strong>if</strong> cont (cont #f) l)) &#8658;  (out in out in out)
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Sequencing"></a>
<h3 id="Sequencing">2.6 Sequencing</h3>
</div>
<div class="sectionbody"><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="begin"></a><a name="--index-entry-8502"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(begin &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />The <code>&lt;expression&gt;</code>s are evaluated sequentially from left to right, and the
value(s) of the last <code>&lt;expression&gt;</code> is(are) returned.  This expression type is
used to sequence side effects such as input and output.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>  (<span class="source-define">define</span> x 0)

  (<strong>begin</strong> (<strong>set!</strong> x 5)
         (+ x 1))                  &#8658;  6

  (<strong>begin</strong> (display <span class="source-string">&quot;4 plus 1 equals &quot;</span>)
         (display (+ 4 1)))        -| 4 plus 1 equals 5
                                   &#8658;  void
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="--"></a><a name="tagbody"></a><a name="--index-entry-8568"></a><a name="--index-entry-8572"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(tagbody &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">(-&gt; tag)</font></strong></code><br /><br />The <code>&lt;expression&gt;</code>s are evaluated sequentially from left to right,
and the value(s) of the last &lt;expression&gt; is(are) returned as in a
<code>begin</code> form. Within a <code>tagbody</code> form expressions which are keywords
are considered as tags and the special form <code>(-&gt; tag)</code> is used to
transfer execution to the given tag. This is a <strong>very low level</strong>
form which is inspired on <code>tabgody</code> Common Lisp's form. It can be useful
for defining new syntaxes, and should probably not used as is.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(tagbody               <span class="source-comment">;; an infinite loop</span>
   #:1 (display <span class="source-string">&quot;.&quot;</span>)
       (-&gt; #:1))

(<strong>let</strong> ((v 0))
  (tagbody
   #:top (when (&lt; v 5)
           (display v)
           (<strong>set!</strong> v (fx+ v 1))
           (-&gt; #:top))))                      &#8658; prints 01234

(tagbody (display 1)
         (tagbody (display 2)
                  (-&gt; #:inner)
                  (display <span class="source-string">&quot;not printed&quot;</span>)
           #:inner
                 (display 3)
                 (-&gt; #:outer)
                 (display <span class="source-string">&quot;not printed too&quot;</span>))
   #:outer
         (display <span class="source-string">&quot;4&quot;</span>))                        &#8658; prints 1234
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Iterations"></a>
<h3 id="Iterations">2.7 Iterations</h3>
</div>
<div class="sectionbody"><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="do"></a><a name="--index-entry-8672"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(do [[&lt;var1&gt; &lt;init1&gt; &lt;step1&gt;] ...] [&lt;test&gt; &lt;expr&gt; ...] &lt;command&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br /><code>Do</code> is an iteration construct.  It specifies a set of variables to be
bound, how they are to be initialized at the start, and how they are
to be updated on each iteration.  When a termination condition is met,
the loop exits after evaluating the <code>&lt;expr&gt;</code>s.
<br /><br />
<code>Do</code> expressions are evaluated as follows: The <code>&lt;init&gt;</code> expressions
are evaluated (in some unspecified order), the <code>&lt;var&gt;</code>s are bound
to fresh locations, the results of the <code>&lt;init&gt;</code> expressions are stored
in the bindings of the <code>&lt;var&gt;</code>s, and then the iteration phase
begins.
<br /><br />
Each iteration begins by evaluating <code>&lt;test&gt;</code>; if the result is false
then the <code>&lt;command&gt;</code> expressions are evaluated in order for effect,
the <code>&lt;step&gt;</code> expressions are evaluated in some unspecified order, the
<code>&lt;var&gt;</code>s are bound to fresh locations, the results of the <code>&lt;step&gt;</code>s
are stored in the bindings of the <code>&lt;var&gt;</code>s, and the next iteration
begins.
<br /><br />
If <code>&lt;test&gt;</code> evaluates to a true value, then the <code>&lt;expr&gt;</code>s are
evaluated from left to right and the value(s) of the last <code>&lt;expr&gt;</code>
is(are) returned.  If no <code>&lt;expr&gt;</code>s are present, then the value of
the do expression is <em>void</em>.
<br /><br />
The region of the binding of a <code>&lt;var&gt;</code> consists of the entire do
expression except for the <code>&lt;init&gt;</code>s.  It is an error for a <code>&lt;var&gt;</code> to
appear more than once in the list of do variables.
<br /><br />
A <code>&lt;step&gt;</code> may be omitted, in which case the effect is the same as if
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-module">&lt;var&gt;</span> <span class="source-module">&lt;init&gt;</span> <span class="source-module">&lt;var&gt;</span>)
</pre></td></tr>
</tbody></table></blockquote>

had been written.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>  (<strong>do</strong> ((vec (make-vector 5))
       (i 0 (+ i 1)))
      ((= i 5) vec)
    (vector-set! vec i i))            &#8658;  #(0 1 2 3 4)

  (<strong>let</strong> ((x '(1 3 5 7 9)))
    (<strong>do</strong> ((x x (cdr x))
         (sum 0 (+ sum (car x))))
        ((null? x) sum)))             &#8658;  25
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="dotimes"></a><a name="--index-entry-8862"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(dotimes [var count] &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">(dotimes [var count result] &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code><br /><br />Evaluates the <code>count</code> expression, which must return an
integer and then evaluates the <code>&lt;expression&gt;</code>s once for each
integer from zero (inclusive) to <code>count</code> (exclusive), in order,
with the symbol <code>var</code> bound to the integer; if the value of
<code>count</code> is zero or negative, then the <code>&lt;expression&gt;</code>s are not
evaluated. When the loop completes, <code>result</code> is evaluated and its
value is returned as the value of the <code>dotimes</code> construction. If
<code>result</code> is omitted, <code>dotimes</code> result is <em>void</em>.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<strong>let</strong> ((l '()))
  (<strong>dotimes</strong> (i 4 l)
     (<strong>set!</strong> l (cons i l)))) &#8658; (3 2 1 0)
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="repeat"></a><a name="--index-entry-8957"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(repeat count &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<br />Evaluates the <code>count</code> expression, which must return an
integer and then evaluates the <code>&lt;expression&gt;</code>s once for each
integer from zero (inclusive) to <code>count</code> (exclusive). The result of
<code>repeat</code> is undefined.

<br />
This form could be easily simulated with <code>dotimes</code>. Its interest is
that it is faster.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(repeat 3 (display <span class="source-string">&quot;.&quot;</span>))     &#8658; prints <span class="source-string">&quot;...&quot;</span>
(repeat 0 (display <span class="source-string">&quot;.&quot;</span>))     &#8658; prints nothing
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="while"></a><a name="--index-entry-9027"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(while &lt;test&gt; &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<br /><code>While</code> evaluates the <code>&lt;expression&gt;</code>s until <code>&lt;test&gt;</code> returns a false
value. The value returned by this form is <em>void</em>.</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="until"></a><a name="--index-entry-9065"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(until &lt;test&gt; &lt;expression1&gt; &lt;expression2&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<br /><code>Until</code> evaluates the <code>&lt;expression&gt;</code>s until <code>&lt;while&gt;</code> returns a false
value. The value returned by this form is <em>void</em>.</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Delayed-Evaluation"></a>
<h3 id="Delayed-Evaluation">2.8 Delayed Evaluation</h3>
</div>
<div class="sectionbody"><a name="--index-entry-9104"></a><a name="--index-entry-9108"></a><a name="--index-entry-9112"></a><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="delay"></a><a name="--index-entry-9118"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(delay &lt;expression&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />The <code>delay</code> construct is used together with the procedure <code>force</code>
to implement <em>lazy evaluation</em> or <em>call by need</em>. <code>(delay
&lt;expression&gt;)</code> returns an object called a <em>promise</em> which at some
point in the future may be asked (by the <code>force</code> procedure) to
evaluate <code>&lt;expression&gt;</code>, and deliver the resulting value.
The effect of <code>&lt;expression&gt;</code> returning multiple values is unpredictable.

See the description of <code>force</code> (&#x40;pxref{force}) for a more complete
description of <code>delay</code>.</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="delay-force"></a><a name="lazy"></a><a name="--index-entry-9191"></a><a name="--index-entry-9195"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(delay-force &lt;expression&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>7</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">(lazy &lt;expression&gt;)</font></strong></code><br /><br />The expression <code>(delay-force expression)</code> is conceptually similar
to <code>(delay (force expression))</code>, with the difference that forcing the result
of <code>delay-force</code> will in effect result in a tail call to <code>(force expression)</code>,
while forcing the result of <code>(delay (force expression))</code> might not. Thus
iterative lazy algorithms that might result in a long series of chains of
<code>delay</code> and <code>force</code> can be rewritten using <code>delay-force</code> to prevent consuming
unbounded space during evaluation.

The special form <code>delay-force</code> appears with name <code>lazy</code> in SRFI-45.
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="force"></a><a name="--index-entry-9269"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(force promise)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> procedure</i></font></td></tr>
</tbody></table>
<br />Forces the value of <code>promise</code> (see <a href="stklos-ref-2.html#delay">delay</a>). If no value has been
computed for the promise, then a value is computed and
returned. The value of the promise is cached (or &quot;memoized&quot;) so
that if it is forced a second time, the previously computed value
is returned.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(force (delay (+ 1 2)))        &#8658;  3
(<strong>let</strong> ((p (delay (+ 1 2))))
  (list (force p) (force p)))  &#8658;  (3 3)

(<span class="source-define">define</span> a-stream
  (<strong>letrec</strong> ((next (<strong>lambda</strong> (n)
                   (cons n (delay (next (+ n 1)))))))
    (next 0)))
(<span class="source-define">define</span> head car)
(<span class="source-define">define</span> tail (<strong>lambda</strong> (stream) (force (cdr stream))))

(head (tail (tail a-stream)))  &#8658;  2
</pre></td></tr>
</tbody></table></blockquote>


<code>Force</code> and <code>delay</code> are mainly intended for programs written in
functional style. The following examples should not be considered
to illustrate good programming style, but they illustrate the
property that only one value is computed for a promise, no matter
how many times it is forced.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-define">define</span> count 0)
(<span class="source-define">define</span> p (delay (<strong>begin</strong> (<strong>set!</strong> count (+ count 1))
                        (<strong>if</strong> (&gt; count x)
                            count
                            (force p)))))
(<span class="source-define">define</span> x 5)
p                     &#8658;  a promise
(force p)             &#8658;  6
p                     &#8658;  a promise, still
(<strong>begin</strong> (<strong>set!</strong> x 10)
       (force p))     &#8658;  6
</pre></td></tr>
</tbody></table></blockquote>

<strong>Note:</strong> See <span style="font-variant: small-caps">R<sup>5</sup>RS</span> for details on a posssible way to implement
<code>force</code> and <code>delay</code>.</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="promise-"></a><a name="--index-entry-9416"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(promise? obj)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>7</sup>RS</span> procedure</i></font></td></tr>
</tbody></table>
<br /> Returns <code>#t</code> if <code>obj</code> is a promise, otherwise returns <code>#f</code>.</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="make-promise"></a><a name="eager"></a><a name="--index-entry-9452"></a><a name="--index-entry-9456"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(make-promise obj)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>7</sup>RS</span> procedure</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">(eager obj)</font></strong></code><br /><br />The <code>make-promise</code> procedure returns a promise which,
when forced, will return <code>obj</code> . It is similar to <code>delay</code>, but
does not delay its argument: it is a procedure rather than
syntax. If <code>obj</code> is already a promise, it is returned.

The primitve <code>make-promise</code> appears with name <code>eager</code> in
SRFI-45.</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Quasiquotation"></a>
<h3 id="Quasiquotation">2.9 Quasiquotation</h3>
</div>
<div class="sectionbody"><a name="--index-entry-9511"></a><a name="--index-entry-9515"></a><a name="--index-entry-9519"></a><a name="--index-entry-9523"></a><a name="--index-entry-9527"></a><a name="--index-entry-9531"></a><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="quasiquote"></a><a name="--index-entry-9537"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(quasiquote &lt;template&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">`&lt;template&gt;</font></strong></code><br /><br />&quot;Backquote&quot; or &quot;quasiquote&quot; expressions are useful for constructing a
list or vector structure when most but not all of the desired structure
is known in advance.  If no commas appear within the <code>&lt;template&gt;</code>,
the result of evaluating <code>`&lt;template&gt;</code> is equivalent to the result of
evaluating <code>'&lt;template&gt;</code>.  If a comma appears within the
<code>&lt;template&gt;</code>, however, the expression following the comma is evaluated
(&quot;unquoted&quot;) and its result is inserted into the structure instead of
the comma and the expression.  If a comma appears followed immediately
by an at-sign (&#x40;), then the following expression must evaluate to a
list; the opening and closing parentheses of the list are then
&quot;stripped away&quot; and the elements of the list are inserted in place of the comma
at-sign expression sequence.  A comma at-sign should only appear within
a list or vector <code>&lt;template&gt;</code>.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>`(list ,(+ 1 2) 4)  &#8658;  (list 3 4)
(<strong>let</strong> ((name 'a)) `(list ,name ',name))
                    &#8658;  (list a (<strong>quote</strong> a))
`(a ,(+ 1 2) ,&#x40;(map abs '(4 -5 6)) b)
                    &#8658;  (a 3 4 5 6 b)
`((foo ,(- 10 3)) ,&#x40;(cdr '(c)) . )
                    &#8658;  ((foo 7) . cons)
`#(10 5 ,(sqrt 4) ,&#x40;(map sqrt '(16 9)) 8)
                    &#8658;  #(10 5 2 4 3 8)
</pre></td></tr>
</tbody></table></blockquote>


Quasiquote forms may be nested.  Substitutions are made only for unquoted
components appearing at the same nesting level as the outermost backquote.
The nesting level increases by one inside each successive quasiquotation,
and decreases by one inside each unquotation.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
          &#8658;  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(<strong>let</strong> ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e))
          &#8658;  (a `(b ,x ,'y d) e)
</pre></td></tr>
</tbody></table></blockquote>


The two notations <code>`&lt;template&gt;</code> and <code>(quasiquote &lt;template&gt;)</code> are identical
in all respects.  <code>,&lt;expression&gt;</code> is identical to <code>(unquote &lt;expression&gt;)</code>, and
<code>,&#x40;&lt;expression&gt;</code> is identical to <code>(unquote-splicing &lt;expression&gt;)</code>.

</td></tr>
</tbody></table></div></div><div class="sectiondiv"><div class="sectiontitle"><a name="Macros"></a>
<h3 id="Macros">2.10 Macros</h3>
</div>
<div class="sectionbody"><a name="--index-entry-9689"></a><a name="--index-entry-9693"></a><a name="--index-entry-9697"></a><p>STklos supports hygienic macros such as the ones defined in R5RS
as well as low level macros.</p><a name="--index-entry-9702"></a><p>Low level macros are defined with <code>define-macro</code> whereas
R5RS macros are defined with <code>define-syntax</code>
<a href="#fn--footnote-9708"><sup><small>1</small></sup></a>.  Hygienic macros use the implementation
called <em>Macro by Example</em> (Eugene Kohlbecker, R4RS) done by Dorai
Sitaram. This implementation generates low level STklos
macros. This implementation of hygienic macros is not expensive.</p><a name="--index-entry-9711"></a><p>The major drawback of this implementation is that the macros are
 not <em>referentially transparent</em> (see section `Macros' in
 R4RS for details). Lexically scoped macros
 (i.e., <code>let-syntax</code> and <code>letrec-syntax</code> are not
 supported). In any case, the problem of referential transparency
 gains poignancy only when <code>let-syntax</code> and
 <code>letrec-syntax</code> are used. So you will not be courting
 large-scale disaster unless you're using system-function names as
 local variables with unintuitive bindings that the macro can't
 use. However, if you must have the full R5RS macro
 functionality, you can do
 <blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(require <span class="source-string">&quot;full-syntax&quot;</span>)
</pre></td></tr>
</tbody></table></blockquote>

 to have access to the more featureful (but also more expensive)
 versions of <code>syntax-rules</code>. Requiring <code>&quot;full-syntax&quot;</code>
 loads the version 2.1 of an implementation of hygienic macros by
 Robert Hieb and R. Kent Dybvig.</p><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="define-macro"></a><a name="--index-entry-9733"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(define-macro (&lt;name&gt; &lt;formals&gt;) &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> syntax</i></font></td></tr>
</tbody></table>
<code><strong><font color="IndianRed">(define-macro &lt;name&gt; (lambda &lt;formals&gt; &lt;body&gt;))</font></strong></code><br /><br /><code>define-macro</code> can be used to define low-level macro
(i.e. <em>non hygienic</em> macros). This form is similar to the
<code>defmacro</code> form of Common Lisp.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-define">define-macro</span> (incr x) `(<strong>set!</strong> ,x (+ ,x 1)))
(<strong>let</strong> ((a 1)) (incr a) a)   &#8658; 2

(<span class="source-define">define-macro</span> (when test . body)
  `(<strong>if</strong> ,test ,&#x40;(<strong>if</strong> (null? (cdr body)) body `((<strong>begin</strong> ,&#x40;body)))))
(macro-expand '(when a b)) &#8658; (<strong>if</strong> a b)
(macro-expand '(when a b c d))
                           &#8658; (<strong>if</strong> a (<strong>begin</strong> b c d))

(<span class="source-define">define-macro</span> (my-and . exprs)
  (<strong>cond</strong>
   ((null? exprs)        #t)
   ((= (length exprs) 1) (car exprs))
   (<strong>else</strong>                 `(<strong>if</strong> ,(car exprs)
                           (my-and ,&#x40;(cdr exprs))
                           #f))))
(macro-expand '(my-and a b c))
                          &#8658; (<strong>if</strong> a (my-and b c) #f)
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="define-syntax"></a><a name="--index-entry-9830"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(define-syntax &lt;identifier&gt; &lt;transformer-spec&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br /><code>&lt;Define-syntax&gt;</code>  extends the top-level syntactic environment by binding
the <code>&lt;identifier&gt;</code> to the specified transformer.

<strong>Note:</strong> <code>&lt;transformer-spec&gt;</code> should be an instance of <code>syntax-rules</code>.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-define">define-syntax</span> <strong>let*</strong>
  (syntax-rules ()
    ((<strong>let*</strong> () body1 body2 ...)
     (<strong>let</strong> () body1 body2 ...))
    ((<strong>let*</strong> ((name1 val1) (name2 val2) ...)
       body1 body2 ...)
     (<strong>let</strong> ((name1 val1))
       (<strong>let*</strong> (( name2 val2) ...)
         body1 body2 ...))))
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="syntax-rules"></a><a name="--index-entry-9897"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(syntax-rules &lt;literals&gt; &lt;syntax-rule&gt; ...)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br /><code>&lt;literals&gt;</code> is a list of identifiers, and each <code>&lt;syntax-rule&gt;</code> should be of
the form
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(pattern template)
</pre></td></tr>
</tbody></table></blockquote>


An instance of <code>&lt;syntax-rules&gt;</code> produces a new macro transformer by
specifying a sequence of hygienic rewrite rules. A use of a macro
whose name is associated with a transformer specified by
&lt;syntax-rules&gt; is matched against the patterns contained in the
&lt;syntax-rules&gt;, beginning with the leftmost syntax-rule. When a match is
found, the macro use is transcribed hygienically according to the
template.
<br /><br />
Each pattern begins with the name for the macro. This name is not
involved in the matching and is not considered a pattern variable or
literal identifier.
<br /><br />
<strong>Note:</strong> For a complete description of the Scheme pattern language,
refer to <span style="font-variant: small-caps">R<sup>5</sup>RS</span>.</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="let-syntax"></a><a name="--index-entry-9958"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(let-syntax &lt;bindings&gt; &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br /><code>&lt;Bindings&gt;</code> should have the form
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>((<span class="source-module">&lt;keyword&gt;</span> &lt;transformer spec&gt;) ...)
</pre></td></tr>
</tbody></table></blockquote>

Each <code>&lt;keyword&gt;</code> is an identifier, each <code>&lt;transformer spec&gt;</code> is an instance of
<code>syntax-rules</code>, and <code>&lt;body&gt;</code> should be a sequence of one or more expressions.  It
is an error for a <code>&lt;keyword&gt;</code> to appear more than once in the list of keywords
being bound.
<br />
The <code>&lt;body&gt;</code> is expanded in the syntactic environment obtained by
extending the syntactic environment of the <code>let-syntax</code> expression with macros
whose keywords are the <code>&lt;keyword&gt;</code>s, bound to the specified transformers.  Each
binding of a <code>&lt;keyword&gt;</code> has <code>&lt;body&gt;</code> as its region.
<br />
<strong>Note:</strong> <code>let-syntax</code> is available only after having required the file
<code>&quot;full-syntax&quot;</code>.
<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(let-syntax ((when (syntax-rules ()
		     ((when test stmt1 stmt2 ...)
		      (<strong>if</strong> test
			  (<strong>begin</strong> stmt1
				 stmt2 ...))))))
  (<strong>let</strong> ((<strong>if</strong> #t))
    (when <strong>if</strong> (<strong>set!</strong> <strong>if</strong> 'now))
    <strong>if</strong>))                           &#8658;  now

(<strong>let</strong> ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (<strong>let</strong> ((x 'inner))
      (m))))                       &#8658;  outer
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="letrec-syntax"></a><a name="--index-entry-10105"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(letrec-syntax &lt;bindings&gt; &lt;body&gt;)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">R<sup>5</sup>RS</span> syntax</i></font></td></tr>
</tbody></table>
<br />Syntax of <code>letrec-syntax</code> is the same as for <code>let-syntax</code>.
<br />
The <code>&lt;body&gt;</code> is expanded in the syntactic environment obtained by
extending the syntactic environment of the <code>letrec-syntax</code> expression
with macros whose keywords are the <code>&lt;keyword&gt;</code>s, bound to the specified
transformers.  Each binding of a <code>&lt;keyword&gt;</code> has the <code>&lt;bindings&gt;</code> as well
as the <code>&lt;body&gt;</code> within its region, so the transformers can transcribe
expressions into uses of the macros introduced by the <code>letrec-syntax</code>
expression.
<br />
<strong>Note:</strong> <code>letrec-syntax</code> is available only after having required the file
<code>&quot;full-syntax&quot;</code>.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(letrec-syntax
  ((my-or (syntax-rules ()
            ((my-or) #f)
            ((my-or e) e)
            ((my-or e1 e2 ...)
             (<strong>let</strong> ((temp e1))
               (<strong>if</strong> temp
                   temp
                   (my-or e2 ...)))))))
  (<strong>let</strong> ((x #f)
        (y 7)
        (temp 8)
        (<strong>let</strong> odd?)
        (<strong>if</strong> even?))
    (my-or x
           (<strong>let</strong> temp)
           (<strong>if</strong> y)
           y)))        &#8658;  7
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table><a name="--index-entry-10227"></a><br /><table cellspacing="0" class="doc-box" cellpadding="0" width="100%"><tbody>
<tr><td bgcolor="#dddddd"><a name="macro-expand"></a><a name="--index-entry-10233"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="center"><code><strong><font color="IndianRed">(macro-expand form)</font></strong></code></td><td class="align-right" align="center"><font color="darkolivegreen"><i><span style="font-variant: small-caps">STklos</span> procedure</i></font></td></tr>
</tbody></table>
<br />Returns the macro expansion of <code>form</code> if it is a macro call,
otherwise <code>form</code> is returned unchanged.

<blockquote><table cellspacing="0" class="code" cellpadding="4" width="90%"><tbody>
<tr><td bgcolor="ivory"><pre>(<span class="source-define">define-macro</span> (incr x) `(<strong>set!</strong> ,x (+ ,x 1)))
(macro-expand '(incr foo)) &#8658; (<strong>set!</strong> foo (+ foo 1))
(macro-expand '(car bar))  &#8658; (car bar)
</pre></td></tr>
</tbody></table></blockquote>
</td></tr>
</tbody></table></div></div></div><div class='footnotes'>
<hr>
<b>Note:</b><br>
<a name="fn--footnote-9708"><sup><small>1</small></sup></a>: Documentation about hygienic macros has been stolen in
the SLIB manual
<br>
</div></td>
</tr></table><small><hr>This <span style="font-variant: small-caps">Html</span> page has been produced by 
                                     <a  class="http" href="http://www.stklos.net/~eg/Publis/JFP05/article.html">Skribe</a>.<br />Last update <em>Wed Nov 24 17:57:13 2021</em></small>
</body>
</html>
