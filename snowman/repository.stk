;;;;
;;;; repository.stk	-- Local repository management
;;;; 
;;;; Copyright © 2006-2007 Erick Gallesio - I3S-CNRS/ESSI <eg@essi.fr>
;;;; 
;;;; 
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;; 
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;; 
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
;;;; USA.
;;;; 
;;;;           Author: Erick Gallesio [eg@essi.fr]
;;;;    Creation date: 26-Dec-2006 18:20 (eg)
;;;; Last file update: 31-Jan-2007 14:48 (eg)
;;;;

(define interesting-tuning "stklos")	; The tuning we want to keep in our base

;; ----------------------------------------------------------------------
;;	ensure-repository-hierarchy ...
;; ----------------------------------------------------------------------
(define (ensure-repository-hierarchy)
  ;; Create the snowforts directory (eventually)
  (unless (file-exists? (snowman-snowforts-directory))
    (make-directories (snowman-snowforts-directory))
    (for-each (lambda (x)
		(let* ((name (make-path (snowman-snowforts-directory) x))
		       (out  (open-file name "w")))
		  (unless out
		    (die (format "Cannot create snowfort file ~a" name)))
		  (fprintf out ";; Generated file. DO NOT EDIT\n~a\n" '())
		  (close-port out)))
	      (snowfort-names)))
  ;; Create the cache directory (eventually)
  (unless (file-exists? (snowman-cache-directory))
    (make-directories (snowman-cache-directory))))

;; ----------------------------------------------------------------------
;;	load-repository-descriptions ...
;; ----------------------------------------------------------------------
(define (load-repository-descriptions)

  (define tuning-only-list '())  ; tuning only packages are added at the end

  (define (add-tuning descr)
    (and (pair? descr)
	 (let ((options (cdar descr)))
	   (make-tuning (key-get options :snowball "")
			(key-get options :url "")
			(key-get options :md5 "")))))

  (define (add-tuning-only-package pkg)
    (let* ((name    (package-name pkg))
	   (version (package-version pkg))
	   (items   (filter (lambda (x) (and (equal? (package-name x) name)
					     (equal? (package-version x) version)))
			    *snowman-pkgs*)))
      (if (null? items)
	  (eprintf "Warning: no package for tuning ~a-~a" name version)
	  (set! (package-tuning (car items)) (package-tuning pkg)))))

  (define (add-package descr)
    (let* ((options (cddr descr))
	   (pkg     (make-package
		            (car descr)		; name
			    (cadr descr)	; version
			    (key-get options :category #f)
			    (key-get options :snowball "")
			    (key-get options :url "")
			    (key-get options :md5 "")
			    (key-get options :description "")
			    (key-get options :author "")
			    (key-get options :license "")
			    (key-get options :homepage "")
			    (key-get options :dependencies '())
			    (add-tuning (key-get options :tunings '()))))
	   (tuning-only (key-get options :tuning-only #f)))
   
      (if tuning-only
	  ;; This is a tuning only package. Add it to tuning-only-list
	  (set! tuning-only-list (cons pkg tuning-only-list))
	  ;; Normal package. Add it to the global list 
	  (set! *snowman-pkgs* (cons pkg *snowman-pkgs*)))))

  (define (add-packages src)
    (let ((in (open-file src "r")))
      (unless in
	(die (format "Cannot load description in file ~s" src)))
      (let ((lst (read in)))
	(close-port in)
	(for-each add-package lst))))
	  
  (let ((all (map (lambda (x)
		    (make-path (snowman-snowforts-directory) x))
		  (snowfort-names))))
    (for-each add-packages all)
    ;; Patch our database with tuning-only packages
    (for-each add-tuning-only-package tuning-only-list)))


;; ----------------------------------------------------------------------
;; 	synchronize-snowforts ...
;; ----------------------------------------------------------------------
(define (synchronize-snowforts)

  (define (build-cache-name pkg version)
    (make-path (snowman-cache-directory) (format "~a-~a.tar.gz" pkg version)))
  
  (define (simplify-package-descr descr)
    (match-case descr
       ((?name ?version . ?rest)
	;; Build the name of the file in local cache 
	(key-set! rest :snowball (build-cache-name name version))
	;; Build the names of STklos the tunings in the local cache
	;; and delete informations on other tunings 
	(let* ((tunings   (key-get rest :tunings '()))
	       (my-tuning (assoc interesting-tuning tunings)))
	  (if my-tuning
	      (begin 
		(key-set! (cdr my-tuning)
			  :snowball
			  (build-cache-name (format "~a-stklos" name) version))
		(key-set! rest :tunings (list my-tuning)))
	      (key-set! rest :tunings '()))))
       (else
	(eprintf "Warning: illegal description ~S" descr))))

  (define (sync snowfort-name url)
    (eprintf "Synchronizing snowfort ~S\n   ~S ... " snowfort-name url)
    (flush-output-port (current-error-port))

    (let ((out (open-output-string)))
      (http-get url out)
      (let ((pkgs (read-from-string (get-output-string out))))
	;; Simplify packages description (e.g. delete non STklos tunings ...)
	(for-each simplify-package-descr pkgs)

	;; Save the informations of this snowfort
	(let* ((name (make-path (snowman-snowforts-directory) snowfort-name))
	       (out  (open-file name "w")))
	  (unless out
	    (die (format "cannot save snowfort descriptions of ~s" snowfort-name)))
	  (fprintf out ";; -*- Scheme -*-    Generated file DO NOT EDIT\n")
	  (fprintf out ";; Synchronization of ~a at ~s\n" snowfort-name url)
	  (fprintf out ";; State saved ~a\n" (date))
	  (write pkgs out)
	  (newline out)
	  (close-port out))))
    (eprintf "done\n"))

  ;;
  ;; synchronize-snowforts starts here
  ;;
  (for-each (lambda (x) (sync (car x) (cadr x)))
	    (snowman-sync-urls)))

;; ----------------------------------------------------------------------
;; 	list-repository-packages ...
;; ----------------------------------------------------------------------
(define (list-repository-packages)

  (define (display-package pkg)
    (printf "~a-~a" (package-name pkg) (package-version pkg))
    (if (> (snowman-verbosity) 0)
	(begin
	  (newline)
	  (printf "   Description: ~a\n" (package-description pkg))
	  (printf "   Category: ~a\n" (package-category pkg))
	  (printf "   STklos tuning: ~a\n" (if (package-tuning pkg) "yes" "no")))
	(printf "~a\n" (if (package-tuning pkg) " (tuning)" ""))))

  (for-each display-package
	    (sort *snowman-pkgs* package<?)))


;; ----------------------------------------------------------------------
;; 	find-package ...
;; ----------------------------------------------------------------------
(define (find-package pkg)

  (define (parse-name name)
    (match-case (string-split name "-")
       ((?name  ?version)
	(values name version))
       ((?name)
	(values name #f))
       (else
	(error 'find-package "bad package name" name))))

  (receive (name version)
	   (parse-name pkg)
     (let ((candidates (filter (lambda (x) (equal? (package-name x) name))
			       *snowman-pkgs*)))
       (cond
	 ((null? candidates)	;; no package found
	  #f)
	 (version		;; a version was specified filter the list
	  (let ((res (filter (lambda (x) (equal? (package-version x) version))
			     candidates)))
	    (and (not (null? res))
		 (car res))))
	 (else 			;; return the most recent package
	  (car (last-pair (sort candidates package<?))))))))

;; ----------------------------------------------------------------------
;; 	download-package ...
;; ----------------------------------------------------------------------
(define (download-package package)

  (define (download-tarball path url md5 tuning?)
    (when (> (snowman-verbosity) 0)
      (eprintf "Downloading ~a ~s ... " (if tuning? "tuning for" "package") package)
      (flush-output-port (current-error-port)))
    (let ((out (open-file path "w")))
      (unless out
	(die (format "cannot open file ~s when downloading ~s" path package)))
      (http-get url out)
      (close-port out))
    ;; Verify file integrity
    (let ((lmd5 (md5sum-file path)))
      (unless (equal? lmd5 md5)
	(remove-file path)
	(die (format "Package ~S corrupted. Cache file has been deleted" package))))
    ;; We have finished
    (when (> (snowman-verbosity) 0)
      (eprintf "done\n")))

  (let ((pkg (find-package package)))
    (unless pkg
      (die (format "cannot find package ~s in repository" package)))
    ;; Download dependencies
    (let ((dep (package-dependencies pkg)))
      (if (pair? dep)
	  (for-each (lambda (x)
		      (download-package (string-append (car x) (cadr x))))
		    dep)))
    ;; Try to find the package in the cache
    (let ((path (package-snowball pkg)))
      (unless (file-exists? path)
	;; Snowball absent. download it
	(download-tarball path (package-url pkg) (package-md5 pkg) #f)))
    ;; See if a tuning exits for this package. 
    (let ((tuning (package-tuning pkg)))
      (if tuning
	  (let ((path (tuning-snowball tuning)))
	    (unless (file-exists? path)
	      ;; Tuning absent. download it
	      (download-tarball path (tuning-url tuning) (tuning-md5 tuning) #t)))))
    pkg))

;; ----------------------------------------------------------------------
;; 	fill-cache ...
;; ----------------------------------------------------------------------
(define (fill-cache)
  (for-each (lambda (x)
	      (let ((name (format "~a-~a" (package-name x) (package-version x))))
		(download-package name)))
	    *snowman-pkgs*))


;; ----------------------------------------------------------------------
;; 	add-description-to-local-repository! ...
;; ----------------------------------------------------------------------
(define (add-description-to-local-repository! descr)

  (define (insert-descr lst name version descr)
    (let Loop ((lst lst)
	       (res '()))
      (cond
	((null? lst)
	 (cons descr res))
	((and (equal? (caar lst) name)
	      (equal? (cadar lst) version))
	 (Loop (cdr lst) res))
	(else
	 (Loop (cdr lst) (cons (car lst) res))))))

  (let* ((repo (make-path (snowman-snowforts-directory) "local"))
	 (old  (with-input-from-file repo read))
	 (name (car descr))
	 (vers (cadr descr))
	 (new  (insert-descr old name vers descr)))
    ;; save the new version
    (with-output-to-file repo
      (lambda ()
	(pp new :port #t)))))
    

	       
