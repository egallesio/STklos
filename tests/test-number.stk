;;;;
;;;; test-number.stk	-- Test numbers
;;;;
;;;; Copyright Â© 2005-2025 Erick Gallesio <eg@stklos.net>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@essi.fr]
;;;;    Creation date:  3-May-2005 14:29 (eg)
;;;;

;;;; Most of theses tests were stolen in Gauche Scheme distribution

(require "test")

(test-section "Numbers")


(define (exp2 pow)
  (do ((i 0 (+ i 1))
       (m 1 (+ m m)))
      ((>= i pow) m)))

(define (fermat n)                      ;Fermat's number
  (+ (expt 2 (expt 2 n)) 1))


;;==================================================================
;; Reader/writer
;;

;;------------------------------------------------------------------
(test-subsection "integer addition & reader")

(define (i-tester x)
  (list x (+ x -1 x) (+ x x) (- x) (- (+ x -1 x)) (- 0 x x) (- 0 x x 1)))

(test "around 2^28"
      '(268435456 536870911 536870912
        -268435456 -536870911 -536870912 -536870913)
      (i-tester (exp2 28)))

(test "around 2^31"
      '(2147483648 4294967295 4294967296
        -2147483648 -4294967295 -4294967296 -4294967297)
      (i-tester (exp2 31)))

(test "around 2^60"
      '(1152921504606846976 2305843009213693951 2305843009213693952
        -1152921504606846976 -2305843009213693951 -2305843009213693952
        -2305843009213693953)
      (i-tester (exp2 60)))

(test "around 2^63"
      '(9223372036854775808 18446744073709551615 18446744073709551616
        -9223372036854775808 -18446744073709551615 -18446744073709551616
        -18446744073709551617)
      (i-tester (exp2 63)))

(test "around 2^127"
      '(170141183460469231731687303715884105728
        340282366920938463463374607431768211455
        340282366920938463463374607431768211456
        -170141183460469231731687303715884105728
        -340282366920938463463374607431768211455
        -340282366920938463463374607431768211456
        -340282366920938463463374607431768211457)
      (i-tester (exp2 127)))

;; test for reader's overflow detection code
(test "peculiarity around 2^32"
      (* 477226729 10) 4772267290)

(test "radix" '(43605 342391 718048024785
                123456789 123456789987654321
                1193046 3735928559 3735928559)
              (list #b1010101001010101
              #o1234567
              #o12345677654321
              #d123456789
              #d123456789987654321
              #x123456
              #xdeadbeef
              #xDeadBeef))

(test "exactness.1" #t (exact? #e10))
(test "exactness.2" #t (exact? #e10.0))
(test "exactness.3" #t (exact? #e10e10))
(test "exactness.4" 617/50 (string->number "#e12.34"))
(test "inexactness.1" #f (exact? #i10))
(test "inexactness.2" #f (exact? #i10.0))
(test "inexactness.3" #f (exact? #i12.34))

(test "exactness & radix" '(#t 3735928559 #t 3735928559)
      (list (exact? #e#xdeadbeef)
                       #e#xdeadbeef
                       (exact? #x#edeadbeef)
                       #x#edeadbeef))
(test "inexactness & radix" '(#f 3735928559.0 #f 3735928559.0)
      (list (exact? #i#xdeadbeef)
                       #i#xdeadbeef
                       (exact? #x#ideadbeef)
                       #x#ideadbeef))

(test "invalid exactness/radix spec" #f
      (or (string->number "#e")
                     (string->number "#i")
                     (string->number "#e#i3")
                     (string->number "#i#e5")
                     (string->number "#x#o13")
                     (string->number "#e#b#i00101")))

;;------------------------------------------------------------------
(test-subsection "rational reader")

(define (rational-test v)
  (if (number? v) (list v (exact? v)) v))

(test "rational reader.1" '(1234 #t) (rational-test '1234/1))
(test "rational reader.2" '(-1234 #t) (rational-test '-1234/1))
(test "rational reader.3" '(1234 #t) (rational-test '+1234/1))
;; (test "rational reader.4" '(-1234 #t)| (rational-test '1234/-1)) ??
(test "rational reader.5" '(1234 #t) (rational-test '2468/2))
(test "rational reader.6" '(1/2 #t) (rational-test '1/2))
(test "rational reader.7" '(-1/2 #t) (rational-test '-1/2))
(test "rational reader.8" '(1/2 #t) (rational-test '+1/2))
(test "rational reader.9" '(1/2 #t) (rational-test '751/1502))

(test "rational reader" '(1 #t) (rational-test (string->number "3/03")))
(test/error "rational reader" (string->number "3/0"))
(test/error "rational reader" 3/3/4)
(test/error "rational reader" (rational-test (string->number "1/2.")))
(test/error "rational reader" (rational-test (string->number "1.3/2")))

(test "rational reader w/#e" '(1234 #t)
      (rational-test '#e1234/1))
(test "rational reader w/#e" '(-1234 #t)
      (rational-test '#e-1234/1))
(test "rational reader w/#e" 32/7
      (string->number "#e32/7"))
(test "rational reader w/#e" -32/7
      (string->number "#e-32/7"))

(test "rational reader w/radix" '(15 #t)
      (rational-test '#e#xff/11))
(test "rational reader w/radix" '(56 #t)
      (rational-test '#o770/11))
(test "rational reader w/radix" '(15.0 #f)
      (rational-test '#x#iff/11))


;;------------------------------------------------------------------
(test-subsection "flonum reader")

(define (flonum-test v)
  (if (number? v) (list v (inexact? v)) v))

(test "flonum reader.1" '(3.14 #t)  (flonum-test 3.14))
(test "flonum reader.2" '(0.14 #t)  (flonum-test 0.14))
(test "flonum reader.3" '(0.14 #t)  (flonum-test .14))
(test "flonum reader.4" '(3.0  #t)  (flonum-test 3.))
(test "flonum reader.5" '(-3.14 #t)  (flonum-test -3.14))
(test "flonum reader.6" '(-0.14 #t)  (flonum-test -0.14))
(test "flonum reader.7" '(-0.14 #t)  (flonum-test -.14))
(test "flonum reader.8" '(-3.0  #t)  (flonum-test -3.))
(test "flonum reader.9" '(3.14 #t)  (flonum-test +3.14))
(test "flonum reader.10" '(0.14 #t)  (flonum-test +0.14))
(test "flonum reader.11" '(0.14 #t)  (flonum-test +.14))
(test "flonum reader.12" '(3.0  #t)  (flonum-test +3.))
(test "flonum reader.13" '(0.0  #t)  (flonum-test .0))
(test "flonum reader.14" '(0.0  #t)  (flonum-test 0.))
(test "flonum reader.15" #f (string->number "."))
(test "flonum reader.16" #f (string->number "-."))
(test "flonum reader.17" #f (string->number "+."))

(test "flonum reader (exp).1" '(314.0 #t) (flonum-test 3.14e2))
(test "flonum reader (exp).2" '(314.0 #t) (flonum-test .314e3))
(test "flonum reader (exp).3" '(314.0 #t) (flonum-test 314e0))
(test "flonum reader (exp).4" '(314.0 #t) (flonum-test 314e-0))
(test "flonum reader (exp).5" '(314.0 #t) (flonum-test 3140000e-4))
(test "flonum reader (exp).6" '(-314.0 #t) (flonum-test -3.14e2))
(test "flonum reader (exp).7" '(-314.0 #t) (flonum-test -.314e3))
(test "flonum reader (exp).8" '(-314.0 #t) (flonum-test -314e0))
(test "flonum reader (exp).9" '(-314.0 #t) (flonum-test -314.e-0))
(test "flonum reader (exp).10" '(-314.0 #t) (flonum-test -3140000e-4))
(test "flonum reader (exp).11" '(314.0 #t) (flonum-test +3.14e2))
(test "flonum reader (exp).12" '(314.0 #t) (flonum-test +.314e3))
(test "flonum reader (exp).13" '(314.0 #t) (flonum-test +314.e0))
(test "flonum reader (exp).14" '(314.0 #t) (flonum-test +314e-0))
(test "flonum reader (exp).15" '(314.0 #t) (flonum-test +3140000.000e-4))

(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314E3))
(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314s3))
(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314S3))
(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314l3))
(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314L3))
(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314f3))
(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314F3))
(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314d3))
(test "flonum reader (exp)" '(314.0 #t) (flonum-test .314D3))

(test "padding" '(10.0 #t) (flonum-test '1#))
(test "padding" '(10.0 #t) (flonum-test '1#.))
(test "padding" '(10.0 #t) (flonum-test '1#.#))
(test "padding" '(100.0 #t) (flonum-test '10#.#))
(test "padding" '(100.0 #t) (flonum-test '1##.#))
(test "padding" '(100.0 #t) (flonum-test '100.0#))
(test "padding" '(1.0 #t) (flonum-test '1.#))

;; FIXME:
;; (test "padding" '|1#1| (flonum-test '1#1))
;; (test "padding" '|1##1| (flonum-test '1##1))
;; (test "padding" '|1#.1| (flonum-test '1#.1))
;; (test "padding" '|1.#1| (flonum-test '1.#1))

;;FIXME: (test "padding" '|.#| (flonum-test '.#))
(test "padding" '(0.0 #t) (flonum-test '0.#))
(test "padding" '(0.0 #t) (flonum-test '.0#))
(test "padding" '(0.0 #t) (flonum-test '0#))
(test "padding" '(0.0 #t) (flonum-test '0#.#))
;;FIXME: (test "padding" '|0#.0| (flonum-test '0#.0))

(test "padding" '(1000.0 #t) (flonum-test '1#e2))
(test "padding" '(1000.0 #t) (flonum-test '1##e1))
(test "padding" '(1000.0 #t) (flonum-test '1#.##e2))
(test "padding" '(0.0 #t) (flonum-test '0.#e2))
(test "padding" '(0.0 #t) (flonum-test '.0#e2))
;;FIXME: (test "padding" '|.##e2| (flonum-test '.##e2))


(test "padding (exactness)" '(100 #f) (flonum-test '#e1##))
(test "padding (exactness)" '(120 #f) (flonum-test '#e12#))
(test "padding (exactness)" '(120 #f) (flonum-test '#e12#.#))
(test "padding (exactness)" '(100.0 #t) (flonum-test '#i1##))
(test "padding (exactness)" '(120.0 #t) (flonum-test '#i12#))
(test "padding (exactness)" '(120.0 #t) (flonum-test '#i12#.#))

(test "flonum from ratio reader" '(0.4 #t)     (flonum-test '#i2/5))
(test "flonum from ratio reader" '(-0.6 #t)    (flonum-test '#i-3/5))
(test "flonum from ratio reader" '(-0.6 #t)    (flonum-test '#i3/-5))
(test "flonum from ratio reader" '(1234.0 #t)  (flonum-test '#i1234/1))
(test "flonum from ratio reader" '(-1234.0 #t) (flonum-test '#i-1234/1))
(test "flonum from ratio reader" '(-0.125 #t)  (flonum-test '#i-4/32))

;;------------------------------------------------------------------
(test-subsection "complex reader")

(define (decompose-complex z)
  (cond ((real? z) z)
        ((complex? z)
         (list (real-part z) (imag-part z)))
        (else z)))

(test "complex reader" '(1 1) (decompose-complex '1+i))
(test "complex reader" '(1 1) (decompose-complex '1+1i))
(test "complex reader" '(1 -1) (decompose-complex '1-i))
(test "complex reader" '(1 -1) (decompose-complex '1-1i))
(test "complex reader" '(1.0 1) (decompose-complex '1.0+1i))
(test "complex reader" '(1.0 1.0) (decompose-complex '1.0+1.0i))
(test "complex reader" '(1e-5 1) (decompose-complex '1e-5+1i))
(test "complex reader" '(1e+5 1) (decompose-complex '1e+5+1i))
(test "complex reader" '(1 1e-5) (decompose-complex '1+1e-5i))
(test "complex reader" '(1 1e+5) (decompose-complex '1+1e+5i))
(test "complex reader" '(0.1 1e+4) (decompose-complex '0.1+0.1e+5i))
(test "complex reader" '(0 1) (decompose-complex '+i))
(test "complex reader" '(0 -1) (decompose-complex '-i))
(test "complex reader" '(0 1) (decompose-complex '+1i))
(test "complex reader" '(0 -1) (decompose-complex '-1i))
(test "complex reader" '(0 1.0) (decompose-complex '+1.i))
(test "complex reader" '(0 -1.0) (decompose-complex '-1.i))
(test "complex reader" '(0 1.0) (decompose-complex '+1.0i))
(test "complex reader" '(0 -1.0) (decompose-complex '-1.0i))
(test "complex reader" 1 (decompose-complex '1+0i))
(test "complex reader" '(1 0.0) (decompose-complex '1+0.0i))
(test "complex reader" '(1 0.0) (decompose-complex '1+.0i))
(test "complex reader" '(1 0.0) (decompose-complex '1+0.i))
(test "complex reader" '(1 0.0) (decompose-complex '1+0.0e-43i))
(test "complex reader" '(100.0 0.0) (decompose-complex '1e2+0.0e-43i))

(test "complex reader" 'i (decompose-complex 'i))
(test "complex reader" #f (decompose-complex (string->number ".i")))
(test "complex reader" #f (decompose-complex (string->number "+.i")))
(test "complex reader" #f (decompose-complex (string->number "-.i")))
(test "complex reader" '33i (decompose-complex '33i))
(test "complex reader" 'i+1 (decompose-complex 'i+1))

(test "complex reader" '(1/2 1/2) (decompose-complex 1/2+1/2i))
(test "complex reader" '(0 1/2) (decompose-complex 0+1/2i))
(test "complex reader" '(0 -1/2) (decompose-complex -1/2i))
(test "complex reader" 1/2 (decompose-complex 1/2-0/2i))
;;FIXME: (test "complex reader" #f (decompose-complex (string->number "1/2-1/0i")))

(test "complex reader (polar)" (make-polar 1.0 1.0) 1.0@1.0)
(test "complex reader (polar)" (make-polar 1.0 -1.0) 1.0@-1.0)
(test "complex reader (polar)" (make-polar 1.0 1.0) 1.0@+1.0)
(test "complex reader (polar)" (make-polar -7.0 -3.0) -7@-3.0)
(test "complex reader (polar)" (make-polar 3.5 -3.0) 7/2@-3.0)
(test "complex reader (polar)" #f (string->number "7/2@-3.14i"))

(test "complex from ratio reader" '(0.4 1.0)    (decompose-complex '#i2/5+1i))
(test "complex from ratio reader" '(1.0 0.4)    (decompose-complex '#i1+2/5i))
(test "complex from ratio reader" '(0.6 2.0)    (decompose-complex '#i3/5+2i))
(test "complex from ratio reader" '(2.0 -2.5)   (decompose-complex '#i2+5/-2i))
(test "complex from ratio reader" '(0.0 0.0)    (decompose-complex '#i0/1+0/1i))
(test "complex from ratio reader" '(-0.5 -0.5)  (decompose-complex '#i-1/2-1/2i))

(test "complex from ratio reader (polar)" (make-polar #i2/5 1.0)       '#i2/5@1)
(test "complex from ratio reader (polar)" (make-polar 1.0 #i2/5)       '#i1@2/5)
(test "complex from ratio reader (polar)" (make-polar #i3/5 #i2)       '#i3/5@2)
(test "complex from ratio reader (polar)" (make-polar #i2 #i5/-2)      '#i2@5/-2)
(test "complex from ratio reader (polar)" (make-polar #i0 #i0)         '#i0/1@0/1)
(test "complex from ratio reader (polar)" (make-polar #i-1/2 #i1/2)    '#i-1/2@1/2)

;; missing "i" at the end of a complex number:
(test/error "complex missing i 1" 2+3)
(test/error "complex missing i 2" 2-3)
(test/error "complex missing i 3" 2_2+3_3)
(test/error "complex missing i 4" 2/3+4/5)
(test/error "complex missing i 5" 2/3-4/5)
(test/error "complex missing i 6" 1+1.0)
(test/error "complex missing i 7" 1-1.0)

;; these do trigger errors, but they also break the tests...
;; (test/error "complex missing i 8" '#x2+2)
;; (test/error "complex missing i 9" '#x2-2)
;; (test/error "complex missing i 10" '#b11+11)
;; (test/error "complex missing i 11" '#b11-11)

;; complexes can be written in hex or binary.
(test "complex hex ++"    '(#xab #x+c2)    (decompose-complex '#xab+c2i))
(test "complex hex +-"    '(#xab #x-c2)    (decompose-complex '#xab-c2i))
(test "complex hex -+"    '(#x-ab #x+c2)   (decompose-complex '#x-ab+c2i))
(test "complex hex --"    '(#x-ab #x-c2)   (decompose-complex '#x-ab-c2i))
(test "complex binary ++" '(#b101 #b111)   (decompose-complex '#b101+111i))
(test "complex binary +-" '(#b101 #b-111)  (decompose-complex '#b101-111i))
(test "complex binary -+" '(#b-101 #b111)  (decompose-complex '#b-101+111i))
(test "complex binary --" '(#b-101 #b-111) (decompose-complex '#b-101-111i))

(test "complex hex polar ++"    (make-polar #xa #xb)       #xa@b)
(test "complex hex polar +-"    (make-polar #x-a #xb)      #x-a@b)
(test "complex hex polar -+"    (make-polar #xa #x-b)      #xa@-b)
(test "complex hex polar --"    (make-polar #x-a #x-b)     #x-a@-b)
(test "complex binary polar ++" (make-polar #b101 #b111)   #b101@111)
(test "complex binary polar +-" (make-polar #b-101 #b111)  #b-101@111)
(test "complex binary polar -+" (make-polar #b101 #b-111)  #b101@-111)
(test "complex binary polar --" (make-polar #b-101 #b-111) #b-101@-111)

(test "complex inf+n"
      #t
      (let ((c +inf.0+1/2i))
        (and (infinite? (real-part c))
             (positive? (real-part c))
             (= 1/2 (imag-part c)))))

(test "complex n-inf"
      #t
      (let ((c 3/4-inf.0i))
        (and (infinite? (imag-part c))
             (negative? (imag-part c))
             (= 3/4 (real-part c)))))

(test "complex +inf+inf"
      #t
      (let ((c +inf.0-inf.0i))
        (and (infinite? (imag-part c))
             (infinite? (real-part c))
             (positive? (real-part c))
             (negative? (imag-part c)))))

(test "complex +inf@n"
      #t
      (let ((c +inf.0@2))
        (and (infinite? (imag-part c))
             (infinite? (real-part c))
             (negative? (real-part c))
             (positive? (imag-part c)))))


;;------------------------------------------------------------------
(test-subsection "integer writer syntax")

(define (i-tester2 x)
  (map number->string (i-tester x)))

(test "around 2^28"
      '("268435456" "536870911" "536870912"
        "-268435456" "-536870911" "-536870912" "-536870913")
      (i-tester2 (exp2 28)))

(test "around 2^31"
      '("2147483648" "4294967295" "4294967296"
        "-2147483648" "-4294967295" "-4294967296" "-4294967297")
      (i-tester2 (exp2 31)))

(test "around 2^60"
      '("1152921504606846976" "2305843009213693951" "2305843009213693952"
        "-1152921504606846976" "-2305843009213693951" "-2305843009213693952"
        "-2305843009213693953")
      (i-tester2 (exp2 60)))

(test "around 2^63"
      '("9223372036854775808" "18446744073709551615" "18446744073709551616"
        "-9223372036854775808" "-18446744073709551615" "-18446744073709551616"
        "-18446744073709551617")
      (i-tester2 (exp2 63)))

(test "around 2^127"
      '("170141183460469231731687303715884105728"
        "340282366920938463463374607431768211455"
        "340282366920938463463374607431768211456"
        "-170141183460469231731687303715884105728"
        "-340282366920938463463374607431768211455"
        "-340282366920938463463374607431768211456"
        "-340282366920938463463374607431768211457")
      (i-tester2 (exp2 127)))

;;------------------------------------------------------------------
(test-subsection "complex writer syntax")

(test "complex printing"
      '("+inf.0+inf.0i" "+nan.0+inf.0i" "+inf.0+inf.0i"
       "-inf.0-inf.0i"  "+nan.0+nan.0i" "+nan.0+nan.0i"
       "1+1i"           "0+1i"          "1+0.0i"
       "1-0.0i"         "1+1/2i"        "2-1/3i")
      (map number->string
           (list (* 1+1i +inf.0) (* 0+1i +inf.0) (* 2+1i +inf.0)
                 (* -inf.0 1+1i) (* -nan.0 +1i)  (* +nan.0 -1i)
                 1+1i            0+1i            1+0.0i
                 1-0.0i          1+1/2i          2-3/9i)))

;;==================================================================
;; Predicates
;;

(test-subsection "predicates")

(test "integer?" #t (integer? 0))
(test "integer?" #t (integer? 85736847562938475634534245))
(test "integer?" #f (integer? 85736.534245))
(test "integer?" #f (integer? 3.14))
(test "integer?" #f (integer? 3+4i))
(test "integer?" #t (integer? 3+0i))
(test "integer?" #f (integer? #f))
(test "integer?" #t (integer? (exact 1+0.0i)))
(test "integer?" #t (integer? (exact 1.0+0.0i)))
(test "integer?" #t (integer? (exact 0+0i)))

(test "rational?" #t (rational? 0))
(test "rational?" #t (rational? 85736847562938475634534245))
(test "rational?" #t (rational? 85736.534245))
(test "rational?" #t (rational? 3.14))
(test "rational?" #f (rational? 3+4i))
(test "rational?" #t (rational? 3+0i))
(test "rational?" #f (rational? #f))

(test "real?" #t (real? 0))
(test "real?" #t (real? 85736847562938475634534245))
(test "real?" #t (real? 857368.4756293847))
(test "real?" #t (real? 3+0i))
(test "real?" #f (real? 3+4i))
(test "real?" #f (real? +4.3i))
(test "real?" #f (real? '()))

(test "complex?" #t (complex? 0))
(test "complex?" #t (complex? 85736847562938475634534245))
(test "complex?" #t (complex? 857368.4756293847))
(test "complex?" #t (complex? 3+0i))
(test "complex?" #t (complex? 3+4i))
(test "complex?" #t (complex? +4.3i))
(test "complex?" #f (complex? '()))

(test "number?" #t (number? 0))
(test "number?" #t (number? 85736847562938475634534245))
(test "number?" #t (number? 857368.4756293847))
(test "number?" #t (number? 3+0i))
(test "number?" #t (number? 3+4i))
(test "number?" #t (number? +4.3i))
(test "number?" #f (number? '()))

(test "exact?" #t (exact? 1))
(test "exact?" #t (exact? 4304953480349304983049304953804))
(test "exact?" #f (exact? 1.0))
(test "exact?" #f (exact? 4304953480349304983.049304953804))
(test "exact?" #f (exact? 1.0+0i))
(test "exact?" #f (exact? 1.0+5i))
(test "exact?" #t (exact? 1+0i))
(test "exact?" #t (exact? (exact 1+0.0i)))
(test "exact?" #t (exact? (exact 1.0+0.0i)))
(test "exact?" #t (exact? 0+0i))
(test "inexact?" #f (inexact? 1))
(test "inexact?" #f (inexact? 4304953480349304983049304953804))
(test "inexact?" #t (inexact? 1.0))
(test "inexact?" #t (inexact? 4304953480349304983.049304953804))
(test "inexact?" #t (inexact? 1.0+0i))
(test "inexact?" #t (inexact? 1.0+5i))

(test "odd?"  #t (odd? 1))
(test "odd?"  #f (odd? 2))
(test "even?" #f (even? 1))
(test "even?" #t (even? 2))
(test "odd?"  #t (odd? 1.0))
(test "odd?"  #f (odd? 2.0))
(test "even?" #f (even? 1.0))
(test "even?" #t (even? 2.0))
(test "odd?" #t (odd? 10000000000000000000000000000000000001))
(test "odd?" #f (odd? 10000000000000000000000000000000000002))
(test "even?" #f (even? 10000000000000000000000000000000000001))
(test "even?" #t (even? 10000000000000000000000000000000000002))

;; test if non-integer numbers classify as neither even nor odd:
(test "odd?" #f (odd? 1/2))
(test "odd?" #f (odd? 1.5))
(test "odd?" #f (odd? 0+1i))
(test "odd?" #f (odd? 0+1.0i))
(test/error "odd?" (odd? "i am a number"))
(test "even?" #f (even? 1/2))
(test "even?" #f (even? 1.5))
(test "even?" #f (even? 0+1i))
(test "even?" #f (even? 0+1.0i))
(test/error "even?" (even? "i am a number"))

(test "zero?" #t (zero? 0))
(test "zero?" #t (zero? 0.0))
(test "zero?" #t (zero? (- 10 10.0)))
(test "zero?" #t (zero? 0+0i))
(test "zero?" #f (zero? 1.0))
(test "zero?" #f (zero? +5i))
(test "zero?" #t (zero? -0.0))
(test "positive?" #t (positive? 1))
(test "positive?" #f (positive? -1))
(test "positive?" #t (positive? 3.1416))
(test "positive?" #f (positive? -3.1416))
(test "positive?" #t (positive? 134539485343498539458394))
(test "positive?" #f (positive? -134539485343498539458394))
(test "negative?" #f (negative? 1))
(test "negative?" #t (negative? -1))
(test "negative?" #f (negative? 3.1416))
(test "negative?" #t (negative? -3.1416))
(test "negative?" #f (negative? 134539485343498539458394))
(test "negative?" #t (negative? -134539485343498539458394))

(test "eqv?" #t (eqv? 20 20))
(test "eqv?" #t (eqv? 20.0 20.00000))
(test "eqv?" #t (eqv? 20 (inexact->exact 20.0)))
(test "eqv?" #f (eqv? 20 20.0))

(test "integer-length" 2 (integer-length -3))
(test "integer-length" 1 (integer-length -2))
(test "integer-length" 0 (integer-length -1))
(test "integer-length" 0 (integer-length  0))
(test "integer-length" 1 (integer-length  1))
(test "integer-length" 2 (integer-length  2))
(test "integer-length" 2 (integer-length  3))
(test "integer-length" 3 (integer-length  4))
(test "integer-length" 3 (integer-length  5))
(test "integer-length" 5001 (integer-length (expt 2 5000)))

;;==================================================================
;; Arithmetics
;;

;;------------------------------------------------------------------
(test-subsection "integer addition")

(test/error "bad operand - unary addition" (+ "x"))
(test/error "bad operand  addition (fast path).1" (+ 0 "x"))
(test/error "bad operand  addition (fast path).2" (+ "x" 0))
(test/error "bad operand  substraction (fast path)" (- "x" 0))


(define x #xffffffff00000000ffffffff00000000)
(define xx (- x))
(define y #x00000002000000000000000200000000)
(define yy (- y))
(define z #x00000000000000010000000000000001)
(test "bignum + bignum" #x100000001000000010000000100000000
      (+ x y))
(test "bignum + -bignum" #xfffffffd00000000fffffffd00000000
      (+ x yy))
(test "bignum - bignum" #xfffffffefffffffffffffffeffffffff
      (- x z))
(test "bignum - bignum" x
      (- (+ x y) y))
(test "-bignum + bignum" #x-fffffffd00000000fffffffd00000000
      (+ xx y))
(test "-bignum + -bignum" #x-100000001000000010000000100000000
      (+ xx yy))
(test "-bignum - bignum" #x-100000001000000010000000100000000
      (- xx y))
(test "-bignum - -bignum" #x-fffffffd00000000fffffffd00000000
      (- xx yy))

;; Following tests work if (eqv? 0.0 -0.0) is #f
;; NOTE: (= 0.0 0.0) returns #t. Use strings to be sure
(test "minus-zero.1"
      "-0.0"
      (format "~a" (- 0.0)))

(test "minus-zero.2"
      "0.0"
      (format "~a" (- -0.0)))

(test "minus zero.3"
      "0.0"
      (format "~a" (- 0.0 0.0)))

(test "minus zero.4"
      "-0.0"
      (format "~a" (- 0 0.0 0.0)))

(test "minus zero.4"
      "0.0"
      (format "~a" (- 0 0.0 -0.0)))

(test "minus zero.5"
      #f
      (equal? 0.0 -0.0))

(test "minus zero.6"
      #t
      (equal? -0.0 -0.0))


;; Note: We have a special case: (- 0+0.0i 0.0) is "0.0+0.0i" and not
;; "-0.0+0.0i"
(test "minus zero in a complex"
      "0.0+0.0i"
      (format #f "~a" (- 0+0.0i 0.0)))



;;------------------------------------------------------------------
(test-subsection "small immediate integer constants")

;; pushing small literal integer on the stack may be done
;; by combined instruction PUSHI.  These tests if it works.

(define (foo a b c d e) (list a b c d e))

;; 2^19-1
(test "PUSHI" '(0 524287 524288 -524287 -524288)
              (foo 0 524287 524288 -524287 -524288))
;; 2^51-1
(test "PUSHI" '(0 2251799813685247 2251799813685248
                  -2251799813685247 -2251799813685248 )
              (foo 0 2251799813685247 2251799813685248
             -2251799813685247 -2251799813685248))

;;------------------------------------------------------------------
(test-subsection "small immediate integer additions")

;; small literal integer x (-2^19 <= x < 2^19 on 32bit architecture)
;; in binary addition/subtraction is compiled in special instructuions,
;; NUMADDI and NUMSUBI.

(define x 2)
(test "NUMADDI" 5 (+ 3 x))
(test "NUMADDI" 5 (+ x 3))
(test "NUMADDI" 1 (+ -1 x))
(test "NUMADDI" 1 (+ x -1))
(test "NUMSUBI" 1 (- 3 x))
(test "NUMSUBI" -1 (- x 3))
(test "NUMSUBI" -5 (- -3 x))
(test "NUMSUBI" 5 (- x -3))
(define x 2.0)
(test "NUMADDI" 5.0 (+ 3 x))
(test "NUMADDI" 5.0 (+ x 3))
(test "NUMADDI" 1.0 (+ -1 x))
(test "NUMADDI" 1.0 (+ x -1))
(test "NUMSUBI" 1.0 (- 3 x))
(test "NUMSUBI" -1.0 (- x 3))
(test "NUMSUBI" -5.0 (- -3 x))
(test "NUMSUBI" 5.0 (- x -3))
(define x #x100000000)
(test "NUMADDI" #x100000003 (+ 3 x))
(test "NUMADDI" #x100000003 (+ x 3))
(test "NUMADDI" #xffffffff (+ -1 x))
(test "NUMADDI" #xffffffff (+ x -1))
(test "NUMSUBI" #x-fffffffd (- 3 x))
(test "NUMSUBI" #xfffffffd (- x 3))
(test "NUMSUBI" #x-100000003 (- -3 x))
(test "NUMSUBI" #x100000003 (- x -3))

(test "NUMADDI" 30 (+ 10 (if #t 20 25)))
(test "NUMADDI" 30 (+ (if #t 20 25) 10))
(test "NUMADDI" 35 (+ 10 (if #f 20 25)))
(test "NUMADDI" 35 (+ (if #f 20 25) 10))
(test "NUMADDI" 30 (let ((x #t)) (+ 10 (if x 20 25))))
(test "NUMADDI" 30 (let ((x #t)) (+ (if x 20 25) 10)))
(test "NUMADDI" 35 (let ((x #f)) (+ 10 (if x 20 25))))
(test "NUMADDI" 35 (let ((x #f)) (+ (if x 20 25) 10)))
(test "NUMADDI" 21 (+ 10 (do ((x 0 (+ x 1))) ((> x 10) x))))
(test "NUMADDI" 21 (+ (do ((x 0 (+ x 1))) ((> x 10) x)) 10))
(test "NUMSUBI" -10 (- 10 (if #t 20 25)))
(test "NUMSUBI" 10 (- (if #t 20 25) 10))
(test "NUMSUBI" -15 (- 10 (if #f 20 25)))
(test "NUMSUBI" 15 (- (if #f 20 25) 10))
(test "NUMSUBI" -10 (let ((x #t)) (- 10 (if x 20 25))))
(test "NUMSUBI" 10 (let ((x #t)) (- (if x 20 25) 10)))
(test "NUMSUBI" -15 (let ((x #f)) (- 10 (if x 20 25))))
(test "NUMSUBI" 15 (let ((x #f)) (- (if x 20 25) 10)))
(test "NUMSUBI" -1 (- 10 (do ((x 0 (+ x 1))) ((> x 10) x))))
(test "NUMSUBI" 1 (- (do ((x 0 (+ x 1))) ((> x 10) x)) 10))

;;------------------------------------------------------------------
(test-subsection "promotions in addition")

(define (+-tester x) (list x (exact? x)))

(test "+" '(0 #t) (+-tester (+)))
(test "+" '(1 #t) (+-tester (+ 1)))
(test "+" '(3 #t) (+-tester (+ 1 2)))
(test "+" '(6 #t) (+-tester (+ 1 2 3)))
(test "+" '(1.0 #f) (+-tester (+ 1.0)))
(test "+" '(3.0 #f) (+-tester (+ 1.0 2)))
(test "+" '(3.0 #f) (+-tester (+ 1 2.0)))
(test "+" '(6.0 #f) (+-tester (+ 1 2 3.0)))
(test "+" '(1+i #t) (+-tester (+ 1 +i)))
(test "+" '(3+i #t) (+-tester (+ 1 2 +i)))
(test "+" '(3+i #t) (+-tester (+ +i 1 2)))
(test "+" '(3.0+i #f) (+-tester (+ 1.0 2 +i)))
(test "+" '(3.0+i #f) (+-tester (+ +i 1.0 2)))
(test "+" '(4294967298.0 #f) (+-tester (+ 4294967297 1.0)))
(test "+" '(4294967299.0 #f) (+-tester (+ 4294967297 1 1.0)))
(test "+" '(4294967298.0-i #f) (+-tester (+ 4294967297 1.0 -i)))
(test "+" '(4294967298.0-i #f) (+-tester (+ -i 4294967297 1.0)))
(test "+" '(4294967298.0-i #f) (+-tester (+ 1.0 4294967297 -i)))

;;------------------------------------------------------------------
(test-subsection "integer multiplication")

(test/error "bad operand - unary multiplication" (* "x"))
(test/error "bad operand  multiplication (fast path).1" (* 1 "x"))
(test/error "bad operand  multiplication (fast path).2" (* "x" 1))
(test/error "bad operand  division (fast path)" (/ "x" 1))


(define (m-result x) (list x (- x) (- x) x))
(define (m-tester x y)
  (list (* x y) (* (- x) y) (* x (- y)) (* (- x) (- y))))

(test "fix*fix->big[1]" (m-result 727836879)
      (m-tester 41943 17353))
(test "fix*fix->big[1]" (m-result 3663846879)
      (m-tester 41943 87353))
(test "fix*fix->big[2]" (m-result 4294967296)
      (m-tester 65536 65536))
(test "fix*fix->big[2]" (m-result 366384949959)
      (m-tester 4194303 87353))
(test "fix*big[1]->big[1]" (m-result 3378812463)
      (m-tester 3 1126270821))
(test "fix*big[1]->big[2]" (m-result 368276265762816)
      (m-tester 85746 4294967296))
(test "big[1]*fix->big[1]" (m-result 3378812463)
      (m-tester 1126270821 3))
(test "big[1]*fix->big[2]" (m-result 368276265762816)
      (m-tester 4294967296 85746))
(test "big[2]*fix->big[2]" (m-result 12312849128741)
      (m-tester 535341266467 23))
(test "big[1]*big[1]->big[2]" (m-result 1345585795375391817)
      (m-tester 1194726677 1126270821))

;; Large number multiplication test using Fermat's number
;; The decomposition of Fermat's number is taken from
;;   http://www.dd.iij4u.or.jp/~okuyamak/Information/Fermat.html
(test "fermat(7)" (fermat 7)
      (* 59649589127497217 5704689200685129054721))
(test "fermat(8)" (fermat 8)
              (* 1238926361552897
           93461639715357977769163558199606896584051237541638188580280321))
(test "fermat(9)" (fermat 9)
              (* 2424833
           7455602825647884208337395736200454918783366342657
           741640062627530801524787141901937474059940781097519023905821316144415759504705008092818711693940737))
(test "fermat(10)" (fermat 10)
              (* 45592577
           6487031809
           4659775785220018543264560743076778192897
           130439874405488189727484768796509903946608530841611892186895295776832416251471863574140227977573104895898783928842923844831149032913798729088601617946094119449010595906710130531906171018354491609619193912488538116080712299672322806217820753127014424577
           ))
(test "fermat(11)" (fermat 11)
              (* 319489
           974849
           167988556341760475137
           3560841906445833920513
           173462447179147555430258970864309778377421844723664084649347019061363579192879108857591038330408837177983810868451546421940712978306134189864280826014542758708589243873685563973118948869399158545506611147420216132557017260564139394366945793220968665108959685482705388072645828554151936401912464931182546092879815733057795573358504982279280090942872567591518912118622751714319229788100979251036035496917279912663527358783236647193154777091427745377038294584918917590325110939381322486044298573971650711059244462177542540706913047034664643603491382441723306598834177
           ))

;;------------------------------------------------------------------
(test-subsection "division")

(define (almost=? x y)
  (define (flonum=? x y)
    (let ((ax (abs x)) (ay (abs y)))
      (< (abs (- x y)) (* (max ax ay) 0.0000000000001))))
  (and (flonum=? (car x) (car y))
       (flonum=? (cadr x) (cadr y))
       (flonum=? (caddr x) (caddr y))
       (flonum=? (cadddr x) (cadddr y))
       (eq? (list-ref x 4) (list-ref y 4))))

(define (d-result x exact?) (list x (- x) (- x) x exact?))
(define (d-tester x y)
  (list (/ x y) (/ (- x) y) (/ x (- y)) (/ (- x) (- y))
        (exact? (/ x y))))

;; these uses BignumDivSI -> bignum_sdiv
(test "big[1]/fix->fix" (d-result 17353 #t)
      (d-tester 727836879 41943))
;;FIXME: (test "big[1]/fix->fix" (d-result 136582.040690235 #f)
;;FIXME:       (d-tester 3735928559 27353)
;;FIXME:       almost=?)
(test "big[2]/fix->big[1]" (d-result 535341266467 #t)
      (d-tester 12312849128741 23))
(test "big[2]/fix->big[2]" (d-result 12312849128741 #t)
      (d-tester 12312849128741 1))

;; these uses BignumDivSI -> bignum_gdiv
(test "big[1]/fix->fix" (d-result 41943 #t)
      (d-tester 3663846879 87353))
;;//FIXME: (test "big[2]/fix->fix" (d-result 92894912.9263878 #f)
;;//FIXME:       (d-tester 12312849128741 132546)
;;//FIXME:       almost=?)
;;//FIXME:(test "big[2]/fix->big[1]" (d-result 2582762030.11968 #f)
;;//FIXME:      (d-tester 425897458766735 164900)
;;//FIXME:      almost=?)

;; inexact division
(test "exact/inexact -> inexact" (d-result 3.25 #f)
      (d-tester 13 4.0))
(test "inexact/exact -> inexact" (d-result 3.25 #f)
      (d-tester 13.0 4))
(test "inexact/inexact -> inexact" (d-result 3.25 #f)
      (d-tester 13.0 4.0))

;; complex division
(test "complex division" 0.0
       (let ((a 3)
             (b 4+3i)
             (c 7.3))
         (- (/ a b c)
            (/ (/ a b) c))))

;;------------------------------------------------------------------
(test-subsection "quotient")

(define (q-result x exact?) (list x (- x) (- x) x exact?))
(define (q-tester x y)
  (list (quotient x y) (quotient (- x) y)
        (quotient x (- y)) (quotient (- x) (- y))
        (exact? (quotient x y))))

;; these uses BignumDivSI -> bignum_sdiv
(test "big[1]/fix->fix" (q-result 17353 #t)
      (q-tester 727836879 41943))
(test "big[1]/fix->fix" (q-result 136582 #t)
      (q-tester 3735928559 27353))
(test "big[2]/fix->big[1]" (q-result 535341266467 #t)
      (q-tester 12312849128741 23))
(test "big[2]/fix->big[2]" (q-result 12312849128741 #t)
      (q-tester 12312849128741 1))

;; these uses BignumDivSI -> bignum_gdiv
(test "big[1]/fix->fix" (q-result 41943 #t)
      (q-tester 3663846879 87353))
(test "big[2]/fix->fix" (q-result 19088743 #t)
      (q-tester 705986470884353 36984440))
(test "big[2]/fix->fix" (q-result 92894912 #t)
      (q-tester 12312849128741 132546))
(test "big[2]/fix->big[1]" (q-result 2582762030 #t)
      (q-tester 425897458766735 164900))

;; these uses BignumDivRem
(test "big[1]/big[1]->fix" (q-result 2 #t)
      (q-tester 4020957098 1952679221))
(test "big[1]/big[1] -> fix" (q-result 0 #t)
      (q-tester 1952679221 4020957098))
;; this tests loop in estimation phase
(test "big[3]/big[2] -> big[1]" (q-result #xffff0001 #t)
      (q-tester #x10000000000000000 #x10000ffff))
;; this test goes through a rare case handling code ("add back") in
;; the algorithm.
(test "big[3]/big[2] -> fix" (q-result #xeffe #t)
      (q-tester #x7800000000000000 #x80008889ffff))

;; inexact quotient
(test "exact/inexact -> inexact" (q-result 3.0 #f)
      (q-tester 13 4.0))
(test "inexact/exact -> inexact" (q-result 3.0 #f)
      (q-tester 13.0 4))
(test "inexact/inexact -> inexact" (q-result 3.0 #f)
      (q-tester 13.0 4.0))
(test "exact/inexact -> inexact" (q-result 17353.0 #f)
      (q-tester 727836879 41943.0))
(test "inexact/exact -> inexact" (q-result 17353.0 #f)
      (q-tester 727836879.0 41943))
(test "inexact/inexact -> inexact" (q-result 17353.0 #f)
      (q-tester 727836879.0 41943.0))

;; Test by fermat numbers
(test "fermat(7)" 59649589127497217
      (quotient (fermat 7) 5704689200685129054721))
(test "fermat(8)" 1238926361552897
              (quotient (fermat 8) 93461639715357977769163558199606896584051237541638188580280321))
(test "fermat(9)" 2424833
              (quotient (quotient (fermat 9) 7455602825647884208337395736200454918783366342657)
                  741640062627530801524787141901937474059940781097519023905821316144415759504705008092818711693940737))
(test "fermat(10)" 4659775785220018543264560743076778192897
              (quotient (quotient (quotient (fermat 10)
                                      130439874405488189727484768796509903946608530841611892186895295776832416251471863574140227977573104895898783928842923844831149032913798729088601617946094119449010595906710130531906171018354491609619193912488538116080712299672322806217820753127014424577)
                            6487031809)
                  45592577))
(test "fermat(11)" 3560841906445833920513
              (quotient (quotient (quotient (quotient (fermat 11)
                                                167988556341760475137)
                                      173462447179147555430258970864309778377421844723664084649347019061363579192879108857591038330408837177983810868451546421940712978306134189864280826014542758708589243873685563973118948869399158545506611147420216132557017260564139394366945793220968665108959685482705388072645828554151936401912464931182546092879815733057795573358504982279280090942872567591518912118622751714319229788100979251036035496917279912663527358783236647193154777091427745377038294584918917590325110939381322486044298573971650711059244462177542540706913047034664643603491382441723306598834177
                                      )
                            974849)
                  319489))

;;------------------------------------------------------------------
(test-subsection "remainder")

(define (r-result x exact?) (list x (- x) x (- x) exact?))
(define (r-tester x y)
  (list (remainder x y) (remainder (- x) y)
        (remainder x (- y)) (remainder (- x) (- y))
        (exact? (remainder x y))))

;; small int
(test "fix rem fix -> fix" (r-result 1 #t)
      (r-tester 13 4))
(test "fix rem fix -> fix" (r-result 1234 #t)
      (r-tester 1234 87935))
(test "fix rem big[1] -> fix" (r-result 12345 #t)
      (r-tester 12345 3735928559))

;; these uses BignumDivSI -> bignum_sdiv
(test "big[1] rem fix -> fix" (r-result 0 #t)
      (r-tester 727836879 41943))
(test "big[1] rem fix -> fix" (r-result 1113 #t)
      (r-tester 3735928559 27353))
(test "big[2] rem fix -> fix" (r-result 15 #t)
      (r-tester 12312849128756 23))
(test "big[2] rem fix -> fix" (r-result 0 #t)
      (r-tester 12312849128756 1))

;; these uses BignumDivSI -> bignum_gdiv
(test "big[1] rem fix -> fix" (r-result 0 #t)
      (r-tester 3663846879 87353))
(test "big[2] rem fix -> fix" (r-result 725433 #t)
      (r-tester 705986470884353 36984440))
(test "big[2] rem fix -> fix" (r-result 122789 #t)
      (r-tester 12312849128741 132546))
(test "big[2] rem fix -> fix" (r-result 19735 #t)
      (r-tester 425897458766735 164900))

;; these uses BignumDivRem
(test "big[1] rem big[1] -> fix" (r-result 115598656 #t)
      (r-tester 4020957098 1952679221))
(test "big[1] rem big[1] -> fix" (r-result 1952679221 #t)
      (r-tester 1952679221 4020957098))
;; this tests loop in estimation phase
(test "big[3] rem big[2] -> big[1]" (r-result #xfffe0001 #t)
      (r-tester #x10000000000000000 #x10000ffff))
;; this tests "add back" code
(test "big[3] rem big[2] -> big[2]" (r-result #x7fffb114effe #t)
      (r-tester #x7800000000000000 #x80008889ffff))

;; inexact remainder
(test "exact rem inexact -> inexact" (r-result 1.0 #f)
      (r-tester 13 4.0))
(test "inexact rem exact -> inexact" (r-result 1.0 #f)
      (r-tester 13.0 4))
(test "inexact rem inexact -> inexact" (r-result 1.0 #f)
      (r-tester 13.0 4.0))
(test "exact rem inexact -> inexact" (r-result 1113.0 #f)
      (r-tester 3735928559 27353.0))
(test "inexact rem exact -> inexact" (r-result 1113.0 #f)
      (r-tester 3735928559.0 27353))
(test "inexact rem inexact -> inexact" (r-result 1113.0 #f)
      (r-tester 3735928559.0 27353.0))

;;------------------------------------------------------------------
(test-subsection "modulo")

(define (m-result a b exact?) (list a b (- b) (- a) exact?))
(define (m-tester x y)
  (list (modulo x y) (modulo (- x) y)
        (modulo x (- y)) (modulo (- x) (- y))
        (exact? (modulo x y))))

;; small int
(test "fix mod fix -> fix" (m-result 1 3 #t)
      (m-tester 13 4))
(test "fix mod fix -> fix" (m-result 1234 86701 #t)
      (m-tester 1234 87935))
(test "fix mod big[1] -> fix/big" (m-result 12345 3735916214 #t)
      (m-tester 12345 3735928559))

;; these uses BignumDivSI -> bignum_sdiv
(test "big[1] mod fix -> fix" (m-result 0 0 #t)
      (m-tester 727836879 41943))
(test "big[1] mod fix -> fix" (m-result 1113 26240 #t)
      (m-tester 3735928559 27353))
(test "big[2] mod fix -> fix" (m-result 15 8 #t)
      (m-tester 12312849128756 23))
(test "big[2] mod fix -> fix" (m-result 0 0 #t)
      (m-tester 12312849128756 1))

;; these uses BignumDivSI -> bignum_gdiv
(test "big[1] mod fix -> fix" (m-result 0 0 #t)
      (m-tester 3663846879 87353))
(test "big[2] mod fix -> fix" (m-result 725433 36259007 #t)
      (m-tester 705986470884353 36984440))
(test "big[2] mod fix -> fix" (m-result 122789 9757 #t)
      (m-tester 12312849128741 132546))
(test "big[2] mod fix -> fix" (m-result 19735 145165 #t)
      (m-tester 425897458766735 164900))

;; these uses BignumDivRem
(test "big[1] mod big[1] -> fix" (m-result 115598656 1837080565 #t)
      (m-tester 4020957098 1952679221))
(test "big[1] mod big[1] -> fix" (m-result 1952679221 2068277877 #t)
      (m-tester 1952679221 4020957098))
;; this tests loop in estimation phase
(test "big[3] mod big[2] -> big[1]" (m-result #xfffe0001 #x2fffe #t)
      (m-tester #x10000000000000000 #x10000ffff))
;; this tests "add back" code
(test "big[3] mod big[2] -> big[2]" (m-result #x7fffb114effe #xd7751001 #t)
      (m-tester #x7800000000000000 #x80008889ffff))

;; inexact modulo
(test "exact mod inexact -> inexact" (m-result 1.0 3.0 #f)
      (m-tester 13 4.0))
(test "inexact mod exact -> inexact" (m-result 1.0 3.0 #f)
      (m-tester 13.0 4))
(test "inexact mod inexact -> inexact" (m-result 1.0 3.0 #f)
      (m-tester 13.0 4.0))
(test "exact mod inexact -> inexact" (m-result 1113.0 26240.0 #f)
      (m-tester 3735928559 27353.0))
(test "inexact mod exact -> inexact" (m-result 1113.0 26240.0 #f)
      (m-tester 3735928559.0 27353))
(test "inexact mod inexact -> inexact" (m-result 1113.0 26240.0 #f)
      (m-tester 3735928559.0 27353.0))

;; test by mersenne prime? - code by 'hipster'

(define (mersenne-prime? p)
  (let ((m (- (expt 2 p) 1)))
    (do ((i 3 (+ i 1))
         (s 4 (modulo (- (* s s) 2) m)))
        ((= i (+ p 1)) (= s 0)))))


(test "mersenne prime? 3" #t (mersenne-prime? 3))
(test "mersenne prime? 5" #t (mersenne-prime? 5))
(test "mersenne prime? 7" #t (mersenne-prime? 7))
(test "mersenne prime? 13" #t (mersenne-prime? 13))
(test "mersenne prime? 17" #t (mersenne-prime? 17))
(test "mersenne prime? 19" #t (mersenne-prime? 19))
(test "mersenne prime? 31" #t (mersenne-prime? 31))
(test "mersenne prime? 61" #t (mersenne-prime? 61))
(test "mersenne prime? 89" #t (mersenne-prime? 89))
(test "mersenne prime? 107" #t (mersenne-prime? 107))
(test "mersenne prime? 127" #t (mersenne-prime? 127))
(test "mersenne prime? 521" #t (mersenne-prime? 521))
(test "mersenne prime? 607" #t (mersenne-prime? 607))
(test "mersenne prime? 1279" #t (mersenne-prime? 1279))

(test "mersenne prime? 48" #f (mersenne-prime? 48))
(test "mersenne prime? 100" #f (mersenne-prime? 100))
(test "mersenne prime? (* 61 19)" #f (mersenne-prime? (* 61 19)))

;;------------------------------------------------------------------
(test-subsection "gcd and lcm")

(test "gcd" 0   (gcd))
(test "gcd" 5   (gcd 0 5))
(test "gcd" 5   (gcd 0 -5))
(test "gcd" 5.0 (gcd 0.0 -5))
(test "gcd" 1   (gcd 11 7))
(test "gcd" 1   (gcd 1 10))
(test "gcd" 1   (gcd -1 10))
(test "gcd" 4   (gcd 20 8))
(test "gcd" 4   (gcd -20 8))
(test "gcd" 4.0 (gcd 20.0 8))
(test "gcd" 4.0 (gcd 20 4.0))
(test "gcd" 1   (gcd 1208925819614629174706189 929192))   ; first is prime
(test "gcd" 1.0 (gcd 1208925819614629174706189 929192.0)) ; first is prime

(test "gcd with real turned into bignum"
      1.0
      (gcd 20000000000000000000.0 3))

(test "gcd 2 bignums -> fixnum"
      4857223
      ;; first: 2^65 * 7^5 * 17^2
      ;; second: 7^5 * 17^50
      (gcd 179199899179871458857844736
           559675465285191576525278231414576190110023838138985405765037623943))

(test "gcd 2 bignums -> bignum"
      569468379011812486801
      (gcd 21009674891402273592944939027143256440832
           460916811707362526506357210533854319331779361732494458019956379934890049))

(test "gcd"
      4
      (gcd 1099511627776 ;; 2^40
           274877906944  ;; 2^38
           10000         ;; 2^4 5^4
           44444))       ;; 2^2 41 271

;; parameterize won't work for compiler:... parameters, since
;; the form is compiled before the parameter is changed, so we
;; need to manually set it, in isolated forms.
(define %%%___inline-common-functions (compiler:inline-common-functions))
(compiler:inline-common-functions #f)
(test/error "gcd" (gcd 1.2  1))
(test/error "gcd" (gcd 1/2  1))
(test/error "gcd" (gcd 1+2i 1))
(test/error "gcd" (gcd 'a   1))
(test/error "gcd" (gcd #\a  1))
(test/error "gcd" (gcd "a"  1))
(test/error "gcd" (gcd gcd  1))

;; Different argument order, just to be sure:
(test/error "gcd" (gcd 1 1.2))
(test/error "gcd" (gcd 1 1/2))
(test/error "gcd" (gcd 1 1+2i))
(test/error "gcd" (gcd 1 'a))
(test/error "gcd" (gcd 1 #\a))
(test/error "gcd" (gcd 1 "a"))
(test/error "gcd" (gcd 1 gcd))

(compiler:inline-common-functions #t)
(test/compile-error "gcd" (gcd 1.2  1))
(test/compile-error "gcd" (gcd 1/2  1))
(test/compile-error "gcd" (gcd 1+2i 1))
(test/compile-error "gcd" (gcd 'a   1))
(test/compile-error "gcd" (gcd #\a  1))
(test/compile-error "gcd" (gcd "a"  1))
(test/compile-error "gcd" (gcd gcd  1))

;; Different argument order, just to be sure:
(test/compile-error "gcd" (gcd 1 1.2))
(test/compile-error "gcd" (gcd 1 1/2))
(test/compile-error "gcd" (gcd 1 1+2i))
(test/compile-error "gcd" (gcd 1 'a))
(test/compile-error "gcd" (gcd 1 #\a))
(test/compile-error "gcd" (gcd 1 "a"))
(test/compile-error "gcd" (gcd 1 gcd))

(compiler:inline-common-functions %%%___inline-common-functions)


(test "gcd" fx-greatest (gcd 0 fx-greatest))

(test "gcd" (+ fx-greatest 1) (gcd 0 (+ fx-greatest 1)))
(test "gcd" (- fx-least)      (gcd 0 fx-least))
(test "gcd"
      (- (- fx-least 1))
      (gcd 0 (- fx-least 1)))

(test "gcd" 15.0 (gcd -15.0))


(test "lcm" 1    (lcm))
(test "lcm" 11   (lcm 11))
(test "lcm" 11.0 (lcm 11.0))
(test "lcm" 6    (lcm 2 3))
(test "lcm" 60   (lcm 12 20))
(test "lcm" 60   (lcm -12 20))
(test "lcm" 60.0 (lcm 12.0 20))

(test "lcm"
      3298534883328        ;; 2^30 * 3
      (lcm 824633720832    ;; 2^38 * 3
           1099511627776)) ;; 2^40

(test "lcm"
      7635421060136960000 ;; 2^40  5^4 41 271
      (lcm 1099511627776  ;; 2^40
           274877906944   ;; 2^38
           10000          ;; 2^4 5^4
           44444))        ;; 2^2 41 271

(test "lcm"
      687194767360000.0   ;; 2^40 5^4
      (lcm 1099511627776  ;; 2^40
           274877906944   ;; 2^38
           10000.0))      ;; 2^4 5^4

(test "lcm"
      189054653969025946927236298201845439024134660015551794280371585024       ;; 2^200 7^6
      (lcm 120472576                                                           ;; 2^10  7^6
           27007807709860849561033756885977919860590665716507399182910226432)) ;; 2^200 7^5

;; parameterize won't work for compiler:... parameters, since
;; the form is compiled before the parameter is changed, so we
;; need to manually set it, in isolated forms.
(define %%%___inline-common-functions (compiler:inline-common-functions))
(compiler:inline-common-functions #f)
(test/error "lcm" (lcm 1.2  1))
(test/error "lcm" (lcm 1/2  1))
(test/error "lcm" (lcm 1+2i 1))
(test/error "lcm" (lcm 'a   1))
(test/error "lcm" (lcm #\a  1))
(test/error "lcm" (lcm "a"  1))
(test/error "lcm" (lcm lcm  1))

;; Different argument order, just to be sure:
(test/error "lcm" (lcm 1 1.2))
(test/error "lcm" (lcm 1 1/2))
(test/error "lcm" (lcm 1 1+2i))
(test/error "lcm" (lcm 1 'a))
(test/error "lcm" (lcm 1 #\a))
(test/error "lcm" (lcm 1"a"))
(test/error "lcm" (lcm 1 lcm))

(compiler:inline-common-functions #t)
(test/compile-error "lcm" (lcm 1.2  1))
(test/compile-error "lcm" (lcm 1/2  1))
(test/compile-error "lcm" (lcm 1+2i 1))
(test/compile-error "lcm" (lcm 'a   1))
(test/compile-error "lcm" (lcm #\a  1))
(test/compile-error "lcm" (lcm "a"  1))
(test/compile-error "lcm" (lcm lcm  1))

;; Different argument order, just to be sure:
(test/compile-error "lcm" (lcm 1 1.2))
(test/compile-error "lcm" (lcm 1 1/2))
(test/compile-error "lcm" (lcm 1 1+2i))
(test/compile-error "lcm" (lcm 1 'a))
(test/compile-error "lcm" (lcm 1 #\a))
(test/compile-error "lcm" (lcm 1 "a"))
(test/compile-error "lcm" (lcm 1 lcm))

(compiler:inline-common-functions %%%___inline-common-functions)

;;------------------------------------------------------------------
(test-subsection "expt")

(test "exact expt" 1 (expt 5 0))
(test "exact expt" 9765625 (expt 5 10))
(test "exact expt" 1220703125 (expt 5 13))
(test "exact expt" 94039548065783000637498922977779654225493244541767001720700136502273380756378173828125 (expt 5 123))
(test "exact expt" 1 (expt -5 0))
(test "exact expt" 9765625 (expt -5 10))
(test "exact expt" -1220703125 (expt -5 13))
(test "exact expt" -94039548065783000637498922977779654225493244541767001720700136502273380756378173828125 (expt -5 123))
(test "exact expt" 1 (expt 1 720000))
(test "exact expt" 1 (expt -1 720000))
(test "exact expt" -1 (expt -1 720001))
(test "exact real" 8 (exact (expt 2 3.0))) ;; 3.0 is precisely representable in
                                           ;; the IEEE standards
(test "expt -2 0.5" #t
      (complex? (expt -2.0 0.5)))
(test "expt -2 1/2" #t
      (complex? (expt -2.0 1/2)))

(test "expt -2 0.5, expt -2 1/2 (imag part)" #t
      (< (abs (- (imag-part (expt -2.0 0.5))
                 (imag-part (expt -2.0 1/2))))
         0.000001))
(test "expt -2 0.5, expt -2 1/2 (real part)" #t
      (< (abs (- (real-part (expt -2.0 0.5))
                 (real-part (expt -2.0 1/2))))
         0.000001))

(test "0^0.1" 1 (expt 0 0))          ;; exact exponent, exact 1
(test "0^0.2" 1 (expt 0.0 0))        ;; exact exponent, exact 1
(test "0^0/3" 1.0 (expt 0 0.0))      ;; inexact exponent, inexact 1.0
(test "0^0.4" 1.0 (expt 0.0 0.0))    ;; inexact exponent, inexact 1.0

(test "42^0.0" 1.0    (expt +42 +0.0))
(test "-42x^0.0" 1.0  (expt -42 +0.0))
(test "42x^-0.0" 1.0  (expt +42 -0.0))
(test "-42x^-0.0" 1.0 (expt -42 -0.0))


(test "0.0^4"   0.0 (expt  0.0 4))
(test "-0.0^4"  0.0 (expt -0.0 4))
(test "0.0^5"   0.0 (expt  0.0 5))
(test "-0.0^5"   -0.0 (expt -0.0 5))

(test "+0.0^3.2"  0.0    (expt +0.0 3.2))
(test "-0.0^3.2"  0.0    (expt -0.0 3.2))
(test "+0.0^-3.2" +inf.0 (expt +0.0 -3.2))
(test "-0.0^-3.2" +inf.0 (expt -0.0 -3.2))

(test "complex expt"
      #t
      (let* ((z (expt 2 -3+4i))
             (r (real-part z))
             (i (imag-part z)))
        (and (< -0.116585885  r -0.116585884)
             (<  0.045085823 i   0.045085824))))
(test/error "0^-a+bi" (expt 0   -2+1i))
(test/error "0^-a+bi" (expt 0.0 -2+1i))

(test "exact expt" 1/1606938044258990275541962092341162602522202993782792835301376
      (expt (expt 2 100) -2))

(test "expt big exponent.1"
      1
      (expt 1 132897461238946918327469812213123215555532132133764))

(test "expt big exponent.2"
      1
      (expt 1 132897461238946918327469812213123215555532132133763))

(test "expt big exponent.3"
      1
      (expt -1 132897461238946918327469812213123215555532132133764))

(test "expt big exponent.4"
      -1
      (expt -1 132897461238946918327469812213123215555532132133763))

;; ----------

(test "expt big exponent.5"
      1.0
      (expt 1.0 132897461238946918327469812213123215555532132133764))

(test "expt big exponent.6"
      1.0
      (expt 1.0 132897461238946918327469812213123215555532132133763))

(test "expt big exponent.7"
      1.0
      (expt -1.0 132897461238946918327469812213123215555532132133764))

(test "expt big exponent.8"
      -1.0
      (expt -1.0 132897461238946918327469812213123215555532132133763))



;;------------------------------------------------------------------
(test-subsection "sqrt")

(test "sqrt small fixnum" 4  (sqrt 16))
(test "sqrt small fixnum" #t (let ((x (sqrt 17)))
			       (and (inexact? x)
				    (< 4.123 x 4.124))))
(test "sqrt small fixnum" 2.0 (sqrt 4.0))
(test "sqrt small fixnum" #t (exact? (sqrt 4)))
(test "sqrt small fixnum" #f (exact? (sqrt 4.0)))

(test "sqrt small fixnum < 0" 0+1i (sqrt -1))
(test "sqrt small fixnum < 0" 0+4i (sqrt -16))
(test "sqrt small fixnum" #t (exact? (sqrt -4)))
(test "sqrt small fixnum" #f (exact? (sqrt -4.0)))

(test "sqrt bignum"  1452616561298192819 (sqrt (* 1452616561298192819
						  1452616561298192819)))
(test "sqrt bignum"  1452616561298192819 (sqrt 2110094874157786375590269875303166761))
(test "sqrt bignum"  0+1452616561298192819i
      		     (sqrt (* 1452616561298192819 -1452616561298192819)))
(test "sqrt bignum"  0+1452616561298192819i
      		     (sqrt -2110094874157786375590269875303166761))

;; FIXME: the 700 exponent works for 64 bits, not for smaller floats.
(test "sqrt bignum" #t ;; the argument is not representable as double, but the
                       ;; result is!
      (< 9.0e+210
         (sqrt (* (expt 2 700) (expt 2 700) 3))
         9.2e+210))
(test "sqrt complex with +0.0 imaginary part" 0.0+1.0i
      (sqrt -1+0.0i))
(test "sqrt complex with +0.0 imaginary part" 0.0-1.0i
      (sqrt -1-0.0i))

(test "sqrt -1" +1i (sqrt -1))
(test "sqrt -1.0" #t
      (let ((s (sqrt -1.0)))
        (and (zero? (real-part s))
             (< 0.999999 (imag-part s) 1.00001)
             (inexact? s))))

;;------------------------------------------------------------------
(test-subsection "logical operations")

(test "bit-shift (fixnum)" #x408000           ;fixnum
      (bit-shift #x81 15))
(test "bit-shift (fixnum)" #x81
      (bit-shift #x408000 -15))
(test "bit-shift (fixnum)" #x01
      (bit-shift #x408000 -22))
(test "bit-shift (fixnum)" 0
      (bit-shift #x408000 -23))
(test "bit-shift (fixnum)" 0
      (bit-shift #x408000 -24))
(test "bit-shift (fixnum)" 0
      (bit-shift #x408000 -100))
(test "bit-shift (fixnum)" #x81
      (bit-shift #x81 0))
(test "bit-shift (neg. fixnum)" #x-408000  ;negative fixnum
      (bit-shift #x-81 15))
(test "bit-shift (neg. fixnum)" #x-81      ;nagative fixnum
      (bit-shift #x-408000 -15))
(test "bit-shift (fixnum)" -2
      (bit-shift #x-408000 -22))
(test "bit-shift (fixnum)" -1
      (bit-shift #x-408000 -23))
(test "bit-shift (fixnum)" -1
      (bit-shift #x-408000 -24))
(test "bit-shift (fixnum)" -1
      (bit-shift #x-408000 -100))
(test "bit-shift (fixnum)" #x-408000
      (bit-shift #x-408000 0))

(test "bit-shift (fixnum->bignum)" #x81000000
      (bit-shift #x81 24))
(test "bit-shift (fixnum->bignum)" #x4080000000
      (bit-shift #x81 31))
(test "bit-shift (fixnum->bignum)" #x8100000000
      (bit-shift #x81 32))
(test "bit-shift (fixnum->bignum)" #x8100000000000000
      (bit-shift #x81 56))
(test "bit-shift (fixnum->bignum)" #x408000000000000000
      (bit-shift #x81 63))
(test "bit-shift (fixnum->bignum)" #x810000000000000000
      (bit-shift #x81 64))
(test "bit-shift (neg.fixnum->bignum)" #x-81000000
      (bit-shift #x-81 24))
(test "bit-shift (neg.fixnum->bignum)" #x-4080000000
      (bit-shift #x-81 31))
(test "bit-shift (neg.fixnum->bignum)" #x-8100000000
      (bit-shift #x-81 32))
(test "bit-shift (neg.fixnum->bignum)" #x-8100000000000000
      (bit-shift #x-81 56))
(test "bit-shift (neg.fixnum->bignum)" #x-408000000000000000
      (bit-shift #x-81 63))
(test "bit-shift (neg.fixnum->bignum)" #x-810000000000000000
      (bit-shift #x-81 64))

(test "bit-shift (bignum->fixnum)" #x81
      (bit-shift  #x81000000 -24))
(test "bit-shift (bignum->fixnum)" #x40
      (bit-shift  #x81000000 -25))
(test "bit-shift (bignum->fixnum)" 1
      (bit-shift  #x81000000 -31))
(test "bit-shift (bignum->fixnum)" 0
      (bit-shift  #x81000000 -32))
(test "bit-shift (bignum->fixnum)" 0
      (bit-shift  #x81000000 -100))
(test "bit-shift (bignum->fixnum)" #x81
      (bit-shift #x4080000000 -31))
(test "bit-shift (bignum->fixnum)" #x81
      (bit-shift #x8100000000 -32))
(test "bit-shift (bignum->fixnum)" #x40
      (bit-shift #x8100000000 -33))
(test "bit-shift (bignum->fixnum)" 1
      (bit-shift #x8100000000 -39))
(test "bit-shift (bignum->fixnum)" 0
      (bit-shift #x8100000000 -40))
(test "bit-shift (bignum->fixnum)" 0
      (bit-shift #x8100000000 -100))
(test "bit-shift (bignum->fixnum)" #x81
      (bit-shift #x8100000000000000 -56))
(test "bit-shift (bignum->fixnum)" #x81
      (bit-shift #x408000000000000000 -63))
(test "bit-shift (bignum->fixnum)" #x40
      (bit-shift #x408000000000000000 -64))
(test "bit-shift (bignum->fixnum)" #x20
      (bit-shift #x408000000000000000 -65))
(test "bit-shift (bignum->fixnum)" 1
      (bit-shift #x408000000000000000 -70))
(test "bit-shift (bignum->fixnum)" 0
      (bit-shift #x408000000000000000 -71))
(test "bit-shift (bignum->fixnum)" 0
      (bit-shift #x408000000000000000 -100))

(test "bit-shift (neg.bignum->fixnum)" #x-81
      (bit-shift #x-81000000 -24))
(test "bit-shift (neg.bignum->fixnum)" #x-41
      (bit-shift #x-81000000 -25))
(test "bit-shift (neg.bignum->fixnum)" #x-21
      (bit-shift #x-81000000 -26))
(test "bit-shift (neg.bignum->fixnum)" -2
      (bit-shift #x-81000000 -31))
(test "bit-shift (neg.bignum->fixnum)" -1
      (bit-shift #x-81000000 -32))
(test "bit-shift (neg.bignum->fixnum)" -1
      (bit-shift #x-81000000 -33))
(test "bit-shift (neg.bignum->fixnum)" -1
      (bit-shift #x-81000000 -100))
(test "bit-shift (neg.bignum->fixnum)" #x-81
      (bit-shift #x-4080000000 -31))
(test "bit-shift (neg.bignum->fixnum)" #x-41
      (bit-shift #x-4080000000 -32))
(test "bit-shift (neg.bignum->fixnum)" #x-21
      (bit-shift #x-4080000000 -33))
(test "bit-shift (neg.bignum->fixnum)" -2
      (bit-shift #x-4080000000 -38))
(test "bit-shift (neg.bignum->fixnum)" -1
      (bit-shift #x-4080000000 -39))
(test "bit-shift (neg.bignum->fixnum)" -1
      (bit-shift #x-4080000000 -100))
(test "bit-shift (neg.bignum->fixnum)" #x-81
      (bit-shift #x-408000000000000000 -63))
(test "bit-shift (neg.bignum->fixnum)" #x-41
      (bit-shift #x-408000000000000000 -64))
(test "bit-shift (neg.bignum->fixnum)" #x-21
      (bit-shift #x-408000000000000000 -65))
(test "bit-shift (neg.bignum->fixnum)" -2
      (bit-shift #x-408000000000000000 -70))
(test "bit-shift (neg.bignum->fixnum)" -1
      (bit-shift #x-408000000000000000 -71))
(test "bit-shift (neg.bignum->fixnum)" -1
      (bit-shift #x-408000000000000000 -72))

(test "bit-shift (bignum->bignum)" #x12345678123456780
      (bit-shift #x1234567812345678 4))
(test "bit-shift (bignum->bignum)" #x1234567812345678000000000000000
      (bit-shift #x1234567812345678 60))
(test "bit-shift (bignum->bignum)" #x12345678123456780000000000000000
      (bit-shift #x1234567812345678 64))
(test "bit-shift (bignum->bignum)" #x123456781234567
      (bit-shift #x1234567812345678 -4))
(test "bit-shift (bignum->bignum)" #x12345678
      (bit-shift #x1234567812345678 -32))
(test "bit-shift (neg.bignum->bignum)" #x-123456781234568
      (bit-shift #x-1234567812345678 -4))
(test "bit-shift (bignum->bignum)" #x-12345679
      (bit-shift #x-1234567812345678 -32))

(test "bit-not (fixnum)" -1 (bit-not 0))
(test "bit-not (fixnum)" 0 (bit-not -1))
(test "bit-not (fixnum)" -65536 (bit-not 65535))
(test "bit-not (fixnum)" 65535 (bit-not -65536))
(test "bit-not (bignum)" #x-1000000000000000001
      (bit-not #x1000000000000000000))
(test "bit-not (bignum)" #x1000000000000000000
      (bit-not #x-1000000000000000001))

(test "bit-and (+fix & 0)" 0
      (bit-and #x123456 0))
(test "bit-and (+big & 0)" 0
      (bit-and #x1234567812345678 0))
(test "bit-and (+fix & -1)" #x123456
      (bit-and #x123456 -1))
(test "bit-and (+big & -1)" #x1234567812345678
      (bit-and #x1234567812345678 -1))
(test "bit-and (+fix & +fix)" #x2244
      (bit-and #xaa55 #x6666))
(test "bit-and (+fix & +big)" #x2244
      (bit-and #xaa55 #x6666666666))
(test "bit-and (+big & +fix)" #x4422
      (bit-and #xaa55aa55aa #x6666))
(test "bit-and (+big & +big)" #x2244224422
      (bit-and #xaa55aa55aa #x6666666666))
(test "bit-and (+big & +big)" #x103454301aaccaa
      (bit-and #x123456789abcdef #xfedcba987654321fedcba987654321fedcba))
(test "bit-and (+big & +big)" #x400000
      (bit-and #xaa55ea55aa #x55aa55aa55))
(test "bit-and (+fix & -fix)" #x8810
      (bit-and #xaa55 #x-6666))
(test "bit-and (+fix & -big)" #x8810
      (bit-and #xaa55 #x-6666666666))
(test "bit-and (+big & -fix)" #xaa55aa118a
      (bit-and #xaa55aa55aa #x-6666))
(test "bit-and (+big & -big)" #x881188118a
      (bit-and #xaa55aa55aa #x-6666666666))
(test "bit-and (+big & -big)" #x20002488010146
      (bit-and #x123456789abcdef #x-fedcba987654321fedcba987654321fedcba))
(test "bit-and (-fix & +fix)" #x4422
      (bit-and #x-aa55 #x6666))
(test "bit-and (-fix & +big)" #x6666664422
      (bit-and #x-aa55 #x6666666666))
(test "bit-and (-big & +fix)" #x2246
      (bit-and #x-aa55aa55aa #x6666))
(test "bit-and (-big & +big)" #x4422442246
      (bit-and #x-aa55aa55aa #x6666666666))
(test "bit-and (-big & +big)" #xfedcba987654321fedcba884200020541010
      (bit-and #x-123456789abcdef #xfedcba987654321fedcba987654321fedcba))
(test "bit-and (-fix & -fix)" #x-ee76
      (bit-and #x-aa55 #x-6666))
(test "bit-and (-fix & -big)" #x-666666ee76
      (bit-and #x-aa55 #x-6666666666))
(test "bit-and (-big & -fix)" #x-aa55aa77ee
      (bit-and #x-aa55aa55aa #x-6666))
(test "bit-and (-big & -big)" #x-ee77ee77ee
      (bit-and #x-aa55aa55aa #x-6666666666))
(test "bit-and (-big & -big)" #x-fedcba987654321fedcba9a76567a9ffde00
      (bit-and #x-123456789abcdef #x-fedcba987654321fedcba987654321fedcba))

(test "bit-or (+fix | 0)" #x123456
      (bit-or #x123456 0))
(test "bit-or (+big | 0)" #x1234567812345678
      (bit-or #x1234567812345678 0))
(test "bit-or (+fix | -1)" -1
      (bit-or #x123456 -1))
(test "bit-or (+big | -1)" -1
      (bit-or #x1234567812345678 -1))
(test "bit-or (+fix | +fix)" #xee77
      (bit-or #xaa55 #x6666))
(test "bit-or (+fix | +big)" #x666666ee77
      (bit-or #xaa55 #x6666666666))
(test "bit-or (+big | +fix)" #xaa55aa77ee
      (bit-or #xaa55aa55aa #x6666))
(test "bit-or (+big | +big)" #xee77ee77ee
      (bit-or #xaa55aa55aa #x6666666666))
(test "bit-or (+big | +big)" #xfedcba987654321fedcba9a76567a9ffddff
      (bit-or #x123456789abcdef #xfedcba987654321fedcba987654321fedcba))
(test "bit-or (+fix | -fix)" #x-4421
      (bit-or #xaa55 #x-6666))
(test "bit-or (+fix | -big)" #x-6666664421
      (bit-or #xaa55 #x-6666666666))
(test "bit-or (+big | -fix)" #x-2246
      (bit-or #xaa55aa55aa #x-6666))
(test "bit-or (+big | -big)" #x-4422442246
      (bit-or #xaa55aa55aa #x-6666666666))
(test "bit-or (+big | -big)" #x-fedcba987654321fedcba884200020541011
      (bit-or #x123456789abcdef #x-fedcba987654321fedcba987654321fedcba))
(test "bit-or (-fix | +fix)" #x-8811
      (bit-or #x-aa55 #x6666))
(test "bit-or (-fix | +big)" #x-8811
      (bit-or #x-aa55 #x6666666666))
(test "bit-or (-big | +fix)" #x-aa55aa118a
      (bit-or #x-aa55aa55aa #x6666))
(test "bit-or (-big | +big)" #x-881188118a
      (bit-or #x-aa55aa55aa #x6666666666))
(test "bit-or (-big | +big)" #x-20002488010145
      (bit-or #x-123456789abcdef #xfedcba987654321fedcba987654321fedcba))
(test "bit-or (-fix | -fix)" #x-2245
      (bit-or #x-aa55 #x-6666))
(test "bit-or (-fix | -big)" #x-2245
      (bit-or #x-aa55 #x-6666666666))
(test "bit-or (-big | -fix)" #x-4422
      (bit-or #x-aa55aa55aa #x-6666))
(test "bit-or (-big | -big)" #x-2244224422
      (bit-or #x-aa55aa55aa #x-6666666666))
(test "bit-or (-big | -big)" #x-103454301aacca9
      (bit-or #x-123456789abcdef #x-fedcba987654321fedcba987654321fedcba))

;;------------------------------------------------------------------
(test-subsection "transcendental functions")

;; exp

(test "exp 0.0"
      1.0
      (exp 0.0))

(test "exp 1.0"
      #t
      (< 2.7182818000
         (exp 1.0)
         2.7182819000))

(test "exp 3/2, e times sqrt(e)"
      #t
      (=  (exp 3/2)
          (* (exp 1) (sqrt (exp 1)))))

(test "exp 1-2i"
      #t
      (let* ((z (exp 1-2i))
             (r (real-part z))
             (i (imag-part z)))
        (and (< -1.1312044000 r -1.1312043000)
             (< -2.4717267000 i -2.4717266000))))

;; log

(test "log 1.0"
      0.0
      (log 1.0))

(test "log 0.0"
      -inf.0
      (log 0.0))

(test "log -0.0" ;; R7RS says (log -0.0) should be "-inf + i*pi".
      #t
      (let ((z (log -0.0)))
        (and (infinite? (real-part z))
             (negative? (real-part z))
             (< 3.14159265350 (imag-part z) 3.14159265360))))

(test "log -inf.0" ;; The limit when x -> -inf is "+inf + i*pi".
      #t
      (let ((z (log -inf.0)))
        (and (infinite? (real-part z))
             (positive? (real-part z))
             (< 3.14159265350 (imag-part z) 3.14159265360))))

(test "log 2/3"
      #t
      (< -0.4055000
         (log 2/3)
         -0.4054000))

(test "(log 3 4) = (log 3)/(log 4)"
      #t
      (= (log 3 4)
         (/ (log 3) (log 4))))

(test "log 16 2"
      4
      (log 16 2))

(test "log 1/4 2"
      -2
      (log 1/4 2))

(test "log 2 10"
      #t
      (< 0.30102000
         (log 2 10)
         0.30103000))

(test "log -64 4 re"
      3
      (real-part (log -64 4)))
(test "log -64 4 im"
      #t
      (< 2.26618
         (imag-part (log -64 4))
         2.26619))

(test "log 3-5i"
      #t
      (let* ((z (log  3-5i))
             (r (real-part z))
             (i (imag-part z)))
        (and (<  1.7631802000 r  1.7631803000)
             (< -1.0303769000 i -1.0303768000))))

;; exact-integer-log

(dotimes (n 50)
  (dotimes (b 50)
    (when (and (positive? n) (> b 1))
      (receive (l r)
          (exact-integer-log n b)
        (test "exact-integer-log.1"
              #t
              (and (= n (+ (expt b l) r))
                   (> (expt b (+ 1 l)) n)))))))

(dotimes (n 50)
  (dotimes (b 50)
    (when (and (positive? n) (> b 1))
      (let ((N (+ 500 (expt 11 n)))
            (B (* 3 (expt 7 b))))
        (receive (l r)
            (exact-integer-log N B)
          (test "exact-integer-log.2"
                #t
                (and (= N (+ (expt B l) r))
                     (> (expt B (+ 1 l)) N))))))))


(test "log 1" 0 (log 1 2))
(test "log 1" 0 (log 1 3))
(test "log 1" 0 (log 1 -2))
(test "log 1" 0 (log 1 -3))
(test "log 1" 0 (log 1 (expt 2 300)))
(test "log 1" 0 (log 1 (- (expt 2 300))))
(test "log 1" 0 (log 1 (inexact (expt 2 300))))
(test "log 1" 0 (log 1 (inexact (- (expt 2 300)))))
(test "log 1" 0 (log 1 2.0))
(test "log 1" 0 (log 1 3.0))
(test "log 1" 0 (log 1 -2.0))
(test "log 1" 0 (log 1 -3.0))
(test "log 1" 0 (log 1 (/ 1 (expt 2 300))))
(test "log 1" 0 (log 1 (/ 1 (- (expt 2 300)))))
(test "log 1" 0 (log 1 (inexact (/ 1 (expt 2 300)))))
(test "log 1" 0 (log 1 (inexact (/ 1 (- (expt 2 300))))))

(test/error "log 1 0" (log 1 0))
(test/error "log 1 1" (log 1 1))

;; exp, log

(test "exp log 1.0"
      1.0
      (exp (log 1.0)))

(test "log exp 1.0"
      1.0
      (log (exp 1.0)))

(test "log exp 2-3i"
      #t
      (let* ((z (log (exp 2-3i)))
             (r (real-part z))
             (i (imag-part z)))
        (and (<  1.99999999 r  2.00000001)
             (< -3.00000001 i -2.99999999))))


;; log with bignums

(test "log 2^200" ;; bignum that fits into a double
      #t
      (let ((z (log (expt 2 200))))
        (<  138.6294360 z 138.629437)))

(test "log 2^200 / 3" ;; numerator is a bignum that fits into a double,
      ;; denominator is a fixnum
      #t
      (let ((z (log (/ (expt 2 200) 3))))
        (<  137.530823 z 137.530824)))

(test "log 2^60 / 3^70" ;; numerator is a fixnum,
      ;; denominator is a bignum that fits into a double
      #t
      (let ((z (log (/ (expt 2 60) (expt 3 70)))))
        (<  -35.314030 z -35.314029)))

(test "log 2^70 / 3^70" ;; numerator and denominator are bignums that
      ;; fit into a double
      #t
      (let ((z (log (/ (expt 2 70) (expt 3 70)))))
        (<  -28.3825576 z -28.3825575)))

;; Just being picky:
(test "%stklos-has-gmp?" #t (boolean? (%stklos-has-gmp?)))

(when (%stklos-has-gmp?)

  (test "log 2^3000"
        #t
        (let ((z (log (expt 2 3000))))
          (<  2079.44154160000 z 2079.44154170000)))

  (test "log_2 2^4000"
        4000
        (log (expt 2 4000) 2))

  (test "log_4 4^4000"
        4000
        (log (expt 4 4000) 4))

  (test "log 10^3000 / 3"
        #t
        (let ((z (log (/ (expt 10 3000) 7))))
          (<  6905.80936 z 6905.80937)))

  (test "log 2^3000 / 3^2500" ;; numerator and denominator are bignums
        #t
        (let ((z (log (/ (expt 2 3000) (expt 3 2500)))))
          (<  -667.089180 z -667.089179)))
  )

(dotimes (base 3)
  (dotimes (x 1000)
    (test "logs"
          x
          (log (expt (expt 2 (+ base 1)) x) (expt 2 (+ base 1))))))

;; sin, cos

(test "sin 1-1i"
      #t
      (let* ((z (sin 1-1i))
             (r (real-part z))
             (i (imag-part z)))
        (and (<  1.2984575000 r  1.2984576000)
             (< -0.6349640000 i -0.6349639000))))

(test "sin +- 1-1i"
      #t
      (= (sin 1-1i) (- (sin -1+1i))))

(test "cos 1-1i"
      #t
      (let* ((z (cos 1-1i))
             (r (real-part z))
             (i (imag-part z)))
        (and (<  0.8337300000 r 0.8337301000)
             (<  0.9888977000 i 0.9888978000))))

(test "cos +- 1-1i"
      #t
      (= (cos 1-1i) (cos -1+1i)))

;; sin, cos
(test "sin 0.0"
      0.0
      (sin 0.0))

(test "cos 0.0"
      1.0
      (cos 0.0))


;; sin, asin; cos, acos
(test "sin-asin 1"
      1.0
      (sin (asin 1)))

(test "sin-asin 2/3"
      #t
      (= (+ 0.0 2/3)
         (sin (asin 2/3))))

(test "cos-acos 1"
      1
      (cos (acos 1)))

(test "cos-acos 2/3"
      #t
      (= (+ 0.0 2/3)
         (cos (acos 2/3))))

;; tan

(test "tan 0.0"
      0.0
      (tan 0.0))

(test "tan 1"
      #t
      (< 1.5574077000
         (tan 1)
         1.5574078000))

(test "tan 3/5"
      #t
      (< 0.6841368000
         (tan 3/5)
         0.6841369000))

(test "tan -5+2i"
      #t
      (let* ((z (tan -5+2i))
             (r (real-part z))
             (i (imag-part z)))
        (and (< 0.0205530000 r 0.0205531000)
             (< 1.0310080000 i 1.0310081000))))

(test "tan acos 0"
      #t
      (> (tan (acos 0)) 1e16))

(test "atan 0 1"
      0.0
      (atan 0 1))

(test "atan 1 0"
      #t
      (= (atan 1 0) (acos 0)))

(test "atan 1 1"
      #t
      (< 0.7853981000
         (atan 1 1)
         0.7853982000))

(test/error "angle zero, I"  (angle 0))

;; The following tests are borrowed from Gauche:
(let ((pi 3.141592653589793115997963468544185161590576171875))
  (test "atan +0.0 +x"    +0.0     (atan 0.0 1))
  (test "atan -0.0 +x" -0.0        (atan -0.0 1))
  (test "atan +0.0 -x" pi          (atan +0.0 -1))
  (test "atan -0.0 -x" (- pi)      (atan -0.0 -1))
  (test "atan +0.0 +0.0" +0.0      (atan +0.0 +0.0))
  (test "atan -0.0 +0.0" -0.0      (atan -0.0 +0.0))
  (test "atan +0.0 -0.0" pi        (atan +0.0 -0.0))
  (test "atan -0.0 -0.0" (- pi)    (atan -0.0 -0.0))
  (test "atan +0.0 0" (/ pi 2)     (atan +0.0 0))
  (test "atan -0.0 0" (- (/ pi 2)) (atan -0.0 0))
  (test/error "atan 0 0" (nan? (atan 0 0))))

;; tan, atan

(test "atan tan 2/3"
      (+ 0.0 2/3)
      (atan (tan 2/3)))

;; this one (tan (atan 1 1)) is usually slightly inaccurate,
;; so we use an interval for testing
(test "tan atan 1 1"
      #t
      (< 0.9999999999
         (tan (atan 1 1))
         1.0000000001))

(test "atan tan 1 1"
      1.0
      (atan (tan 1) 1))

;; hyperbolic trigs

(test "sinh 5"
      #t
      (< 74.20321057770000
         (sinh 5)
         74.20321057780000))

(test "cosh 0.5"
      #t
      (< 1.1276259650000000
         (cosh 0.5)
         1.1276259660000000))

(test "sinh 0.5"
      #t
      (< 0.521095305000000
         (sinh 0.5)
         0.521095306000000))

(test "cosh 7"
      #t
      (< 548.31703515400000
         (cosh 7)
         548.31703515600000))

(test "tanh 0.5"
      #t
      (< 0.4621171572000000
         (tanh 0.5)
         0.4621171573000000))

(test "tanh 2"
      #t
      (< 0.9640275800000000
         (tanh 2)
         0.9640275801000000))


(test "sinh asinh 2"
      #t
      (< 1.9999999999
         (sinh (asinh 2))
         2.0000000001))

(test "cosh acosh 2"
      #t
      (< 1.9999999999
         (cosh (acosh 2))
         2.0000000001))


(test "tanh atanh 1/2"
      #t
      (< 0.4999999999
         (tanh (atanh 1/2))
         0.5000000001))


(test "asinh 2"
      #t
      (< 1.4436354751000000
         (asinh 2)
         1.4436354752000000))

(test "asinh 2^75"
      #t
      (< 52.67918572000000
         (asinh (expt 2 75))
         52.67918573000000))

(test "acosh 3"
      #t
      (< 1.7627471740000000
         (acosh 3)
         1.7627471750000000))

(test "acosh 2^75"
      #t
      (< 52.67918572000000
         (acosh (expt 2 75))
         52.67918573000000))

(test "asinh 1"
      #t
      (< 0.8813735870000000
         (asinh 1)
         0.8813735880000000))

;; Domain error:
(test/error "atanh 1"    (atanh +1))
(test/error "atanh -1"   (atanh -1))
(test/error "atanh 1.0"  (atanh +1.0))
(test/error "atanh -1.0" (atanh -1.0))

(test "atanh 1/2"
      #t
      (< 0.5493061440000000
         (atanh 1/2)
         0.5493061450000000))

;; These should return exact results:
(test "sinh 0.0"  0 (sinh  0.0))
(test "cosh 0.0"  1 (cosh  0.0))
(test "tanh 0.0"  0 (tanh  0.0))
(test "asinh 0.0" 0 (asinh 0.0))
(test "acosh 1.0" 0 (acosh 1.0))
(test "atanh 0.0" 0 (atanh 0.0))
(test "sinh 0"    0 (sinh  0))
(test "cosh 0"    1 (cosh  0))
(test "tanh 0"    0 (tanh  0))
(test "asinh 0"   0 (asinh 0))
(test "acosh 1"   0 (acosh 1))
(test "atanh 0"   0 (atanh 0))

;;------------------------------------------------------------------
(test-subsection "Complexes")

(test "complex sum"
      7+3i
      (+ 2-3i 5+6i))

(test "complex sub"
      -3-9i
      (- 2-3i 5+6i))

(test "complex mul"
      28-3i
      (* 2-3i 5+6i))

(test "complex div"
      -8/61-27/61i
      (/ 2-3i 5+6i))

(test "complex multiply by integer"
      2+inf.0i
      (*  2+inf.0i  1))

(test "complex multiply by real"
      2.0+inf.0i
      (*  2+inf.0i  1.0))

(test "complex square"
      #f
      (nan? (expt +inf.0+1i 2)))

(test "complex square"
      #t
      (and (infinite? (real-part (expt +inf.0+1i 2)))
           (infinite? (imag-part (expt +inf.0+1i 2)))))

(test "complex division with infinity.1"
      #t
      ;; The real value is 0.0+0.0i in STklos. Some Schemes do
      ;; return 0.0+0.0i, some return exact zero, some return
      ;; +nan+0.0i.
      (zero? (imag-part (/ 2 +inf.0+0.0i))))
(test "complex division with infinity.2"
      +inf.0+5/3i
      (/ +inf.0+5i 3))
(test "complex division with infinity.3"
      5/3-inf.0i
      (/ 5-inf.0i 3))


(test "complex mult with infinity.1"
      +inf.0+6i
      (* 2 +inf.0+3i))
(test "complex mult with infinity.2"
      +inf.0+6.0i
      (* 2 +inf.0+3.0i))
(test "complex mult with infinity.3"
      +inf.0+6.0i
      (* 2.0 +inf.0+3i))
(test "complex mult with infinity.4"
      +inf.0+3/2i
      (* 1/2 +inf.0+3i))


(test "cosh +inf"
      #t
      (and (infinite? (cosh +inf.0))
           (positive? (cosh +inf.0))))

(test "cosh -inf"
      #t
      (and (infinite? (cosh -inf.0))
           (positive? (cosh -inf.0))))

(test "sinh +inf"
      #t
      (and (infinite? (sinh +inf.0))
           (positive? (sinh +inf.0))))

(test "sinh -inf"
      #t
      (and (infinite? (sinh -inf.0))
           (negative? (sinh -inf.0))))


(test "acosh +inf"
      #t
      (and (infinite? (acosh +inf.0))
           (positive? (acosh +inf.0))))

(test "acosh -inf"
      #t
      (and (infinite? (acosh -inf.0))
           (positive? (acosh -inf.0))))

(test "asinh +inf"
      #t
      (and (infinite? (asinh +inf.0))
           (positive? (asinh +inf.0))))

(test "asinh -inf"
      #t
      (and (infinite? (asinh -inf.0))
           (negative? (asinh -inf.0))))

;; atanh(+inf) = -(i.pi)/2
;; atanh(-inf) = +(i.pi)/2
(test "atanh -inf"
      #t
      (let ((x (atanh -inf.0)))
        (and (zero? (real-part x))
             (inexact? (real-part x))
             (< 1.5707963260     ;; pi/2
                (imag-part x)
                1.5707963270))))

(test "atanh +inf"
      #t
      (let ((x (atanh +inf.0)))
        (and (zero? (real-part x))
             (inexact? (real-part x))
             (< -1.5707963270     ;; pi/2
                (imag-part x)
                -1.5707963260))))

;;------------------------------------------------------------------
(test-subsection "Misc")

(test "numerator.1"   3   (numerator (/ 6 4)))
(test "denominator.1" 2   (denominator (/ 6 4)))

(test "numerator.2"   -3  (numerator (/ -6 4)))
(test "denominator.2" 2   (denominator (/ -6 4)))

(test "numerator.3"   -3  (numerator (/ 6 -4)))
(test "denominator.3" 2   (denominator (/ 6 -4)))

(test "numerator.4"   0   (numerator 0))
(test "denominator.4" 1   (denominator 0))

(test "numerator.5"   -1  (numerator -1))
(test "denominator.5" 1   (denominator -1))

(test "numerator.6"   3.0 (numerator (inexact (/ 6 4))))
(test "denominator.6" 2.0 (denominator (inexact (/ 6 4))))

(test "numerator.7"  -3.0 (numerator (inexact (/ -6 4))))
(test "denominator.7" 2.0 (denominator (inexact (/ -6 4))))


;; decode-float


(define (test-decode-float val)
  (let-values (( (signif ex sign) (decode-float val) ))
    (test "decode-float"
          val
          (exact->inexact (* sign signif (expt 2 ex))))))

(import (only (srfi 144)
              flnormalized?
              fl-least fl-greatest
              fl-e fl-e-euler fl-phi
              fl-sqrt-2 fl-sqrt-5
              fl-sin-1 fl-pi))


(test-decode-float 0.0)
(test-decode-float 1.0)
(test-decode-float -1.0)
(test-decode-float fl-e)
(test-decode-float (- fl-e))
(test-decode-float fl-e-euler)
(test-decode-float (- fl-e-euler))
(test-decode-float fl-phi)
(test-decode-float (- fl-phi))
(test-decode-float fl-sqrt-2)
(test-decode-float (- fl-sqrt-2))
(test-decode-float fl-sqrt-5)
(test-decode-float (- fl-sqrt-5))
(test-decode-float fl-sin-1)
(test-decode-float (- fl-sin-1))
(test-decode-float fl-pi)
(test-decode-float (- fl-pi))
(test-decode-float fl-least)
(test-decode-float (* fl-least 101))    ; subnormal
(test-decode-float (* fl-least 2))      ; subnormal
(test-decode-float (* fl-least 100000)) ; subnormal
(test-decode-float (* fl-least -98))    ; subnormal
(test-decode-float fl-greatest)


(define (test-subnormal-decode val)
  (let-values (( (signif ex sign) (decode-float val) ))
    (test "subnormal?" #f (flnormalized? val))
    (test "subnormal-exponent"
          (float-min-exponent)
          ex)))

(test-subnormal-decode (* fl-least))        ; subnormal
(test-subnormal-decode (* fl-least 101))    ; subnormal
(test-subnormal-decode (* fl-least 2))      ; subnormal
(test-subnormal-decode (* fl-least 100000)) ; subnormal
(test-subnormal-decode (* fl-least -98))    ; subnormal


(define (test-re-encode-float val)
  (let-values (( (signif ex sign) (decode-float val) ))
    (test "re-encode-float"
          val
          (exact->inexact (encode-float signif ex sign)))))

(test-re-encode-float 0.0)
(test-re-encode-float 1.0)
(test-re-encode-float -1.0)
(test-re-encode-float fl-e)
(test-re-encode-float (- fl-e))
(test-re-encode-float fl-e-euler)
(test-re-encode-float (- fl-e-euler))
(test-re-encode-float fl-phi)
(test-re-encode-float (- fl-phi))
(test-re-encode-float fl-sqrt-2)
(test-re-encode-float (- fl-sqrt-2))
(test-re-encode-float fl-sqrt-5)
(test-re-encode-float (- fl-sqrt-5))
(test-re-encode-float fl-sin-1)
(test-re-encode-float (- fl-sin-1))
(test-re-encode-float fl-pi)
(test-re-encode-float (- fl-pi))
(test-re-encode-float fl-least)            ; subnormal
(test-re-encode-float (* fl-least 101))    ; subnormal
(test-re-encode-float (* fl-least 2))      ; subnormal
(test-re-encode-float (* fl-least 100000)) ; subnormal
(test-re-encode-float (* fl-least -98))    ; subnormal
(test-re-encode-float fl-greatest)


(test/error "encode > max exponent"
            (encode-float 1 (+ (float-max-exponent) 1) 1))

(test/error "encode < min exponent"
            (encode-float 1 (- (float-min-exponent) 1) 1))

(test/error "encode > max significand"
            (encode-float (+ (float-max-significand) 1) 1 1))

;; real-precision.
;; This one is interesting. We're actually testing C's printf... :)

(test/error "real-precision.0"
      (parameterize ((real-precision 0)) (with-output-to-string (lambda () (display 10.001)))))

(test/error "real-precision.51"
      (parameterize ((real-precision 51)) (with-output-to-string (lambda () (display 10.001)))))


(test "real-precision.1"
      "1e+01"
      (parameterize ((real-precision 1)) (with-output-to-string (lambda () (display 10.001)))))
(test "real-precision.2"
      "10.0"
      (parameterize ((real-precision 2)) (with-output-to-string (lambda () (display 10.001)))))
(test "real-precision.3"
      "10.0"
      (parameterize ((real-precision 3)) (with-output-to-string (lambda () (display 10.001)))))
(test "real-precision.4"
      "10.0"
      (parameterize ((real-precision 4)) (with-output-to-string (lambda () (display 10.001)))))

(test "real-precision.5"
      "10.001"
      (parameterize ((real-precision 5)) (with-output-to-string (lambda () (display 10.001)))))

(test "real-precision..3"
      "0.123"
      (parameterize ((real-precision 3)) (with-output-to-string (lambda () (display 0.1234567890123456789)))))
(test "real-precision..3"
      "1.12"
      (parameterize ((real-precision 3)) (with-output-to-string (lambda () (display 1.1234567890123456789)))))

(test "real-precision..10"
      "0.123456789"
      (parameterize ((real-precision 10)) (with-output-to-string (lambda () (display 0.1234567890123456789)))))

(test "real-precision..10"
      "1.123456789"
      (parameterize ((real-precision 10)) (with-output-to-string (lambda () (display 1.1234567890123456789)))))


(test "real-precision..3"
      "123.0"
      (parameterize ((real-precision 3)) (with-output-to-string (lambda () (display 123.1234567890123456789)))))

(test "real-precision..10"
      "123.1234568" ;; last digit is 7, will be rounded to the closest one
      (parameterize ((real-precision 10)) (with-output-to-string (lambda () (display 123.1234567890123456789)))))

(test "real-precision..6"
      "123.123"
      (parameterize ((real-precision 6)) (with-output-to-string (lambda () (display 123.1234567890123456789)))))

(test "degrees->radians 0"
      0.0
      (degrees->radians 0))

(test "degrees->radians 180"
      #t
      (< 3.14159265
         (degrees->radians 180)
         3.14159266))

(test "degrees->radians 10"
      #t
      (< 0.17453292
         (degrees->radians 10)
         0.17453293))

(let ((pi 3.141592653589793115997963468544185161590576171875))

  (test "radians->degrees 0"
        0.0
        (radians->degrees 0))

  (test "radians->degrees pi"
        #t
        (< 179.99999
           (radians->degrees pi)
           180.00001))

  (test "radians->degrees 10"
        #t
        (< 35.99999
           (radians->degrees (/ pi 5))
           36.00001)))
;;;
;;; Zeroes and infinities (some tests comes from Chez)
;;;
(test "zeros & infinities.0" +inf.0 (/ +0.0))
(test "zeros & infinities.2" -inf.0 (/ -0.0))
(test "zeros & infinities.3" +0.0 (/ +inf.0))
(test "zeros & infinities.4" -0.0 (/ -inf.0))
(test "zeros & infinities.5" +nan.0 (/ +nan.0))
(test "zeros & infinities.6" +inf.0 (/ +1.0 +0.0))
(test "zeros & infinities.7" -inf.0 (/ +1.0 -0.0))
(test "zeros & infinities.8" -inf.0 (/ -1.0 +0.0))
(test "zeros & infinities.9" +inf.0 (/ -1.0 -0.0))
(test "zeros & infinities.10" +nan.0 (/ +0.0 +0.0))
(test "zeros & infinities.11" +nan.0 (/ +0.0 -0.0))
(test "zeros & infinities.12" +nan.0 (/ -0.0 +0.0))
(test "zeros & infinities.13" +nan.0 (/ -0.0 -0.0))

(test "zeros & infinities.14" 0 (/ 0 2))
(test "zeros & infinities.15" 0.0 (/ 0.0 2))
(test "zeros & infinities.16" 0+0.0i (/ 0+0.0i 2))

(test "zeros & infinities.17" +nan.0 (/ +inf.0 -inf.0))
(test "zeros & infinities.18" +nan.0 (/ -inf.0 -inf.0))
(test "zeros & infinities.19" -inf.0 (/ -inf.0 0.0))

(test "zeros & infinities.20" +inf.0 (/ 2 0.0))
(test "zeros & infinities.21" -inf.0 (/ -2 0.0))
(test "zeros & infinities.21" +inf.0 (/ -2 -0.0))
(test "zeros & infinities.23" 0 (/ 0 2+3i))
(test "zeros & infinities.24" -0.0+0.0i (/ -0.0 2+3i))
(test "zeros & infinities.25" +0.0+0.0i (/ 0+0.0i 2+3i))


;;;
;;; Misc
;;;
(test "weird number or symbol.1" #t (number? '3s2))
(test "weird number or symbol.2" #f (number? '3s2x))
(test "weird number or symbol.3" #t (number? '3#d2+5i))
(test "weird number or symbol.4" #f (number? '3#d2+5))

(test "equivalence +nan.0 -nan.0" +nan.0 -nan.0)
(test "nan and comp.1" #t (eqv? +nan.0 +nan.0))
(test "nan and comp.2" #t (eqv? +nan.0 -nan.0))
(test "nan and com.3" #f (= +nan.0 +nan.0))
(test "nan and comp.4" #f (= +nan.0 -nan.0))
(test "nan and comp.5" #f (>= +nan.0 +nan.0))
(test "nan and comp.6" #f (>= +nan.0 -nan.0))
(test "nan and comp.7" #f (= (%make-nan #f #f 42) (%make-nan #f #f 42)))
(test "nan and comp.8" #t (eqv? (%make-nan #f #f 42) (%make-nan #f #f 42)))
(test "nan and comp.9" #f (= (%make-nan #f #f 42) (%make-nan #f #f 0)))
(test "nan and comp.10" #f (eqv? (%make-nan #f #f 42) (%make-nan #f #f 0)))

(test "nan and max.1" +nan.0 (max 1 2 3.0 4/5 +nan.0))
(test "nan and max.2" +nan.0 (max +nan.0 1 2 3.0 4/5))
(test "nan and min.1" +nan.0 (min 1 2 3.0 4/5 +nan.0))
(test "nan and min.2" +nan.0 (min +nan.0 1 2 3.0 4/5))


(test "abs complex"
      5
      (abs -3-4i))

(test "abs complex"
      5.0
      (abs -3.0-4i))

(test "abs complex"
      #t
      (infinite? (abs -inf.0+4i)))

(test "abs complex"
      #t
      (infinite? (abs 2-inf.0i)))

(test "abs complex"
      #t
      (nan? (abs -nan.0+4i)))

(test "abs complex"
      #t
      (nan? (abs 1-nan.0i)))

(test "eqv? on 0.0 and -0.0" #f (eqv? +0.0 -0.0))
(test "= on 0.0 and -0.0" #t (= +0.0 -0.0))
(test "eqv? on two inexact complexes.1" #f (eqv? 1.0+i 1.0+1.0i))
(test "eqv? on two inexact complexes.2" #t (eqv? 1.0+1.0i 1.0+1.0i))


(test "read a 9000 digits bignum (see Issue #592)"
      #t
      (= (with-input-from-string
             (with-output-to-string
               (lambda () (display (expt 2 30000))))
           (lambda () (read)))
         (expt 2 30000)))

(test "Number equality test.1"
      #f
      (= 4999999999999999727876154935214080.0 5000000000000000000000000000000000))

(test "Number equality test.2"
      #t
      (= 4999999999999999727876154935214080.0 4999999999999999727876154935214080))

(test "Number equality test.3"
      #t
      (< 4999999999999999727876154935214080.0 5000000000000000000000000000000000))

(test "Number equality test.4"
      #f
      (> 4999999999999999727876154935214080.0 5000000000000000000000000000000000))

(test "Number equality test.5"
      #t
      (= 1.0 1))

(test "Number equality test.6"
      #t
      (= 2.0 2))

(test "Number equality test.7"
      #t
      (= 2+2i 2.0+2.0i))

(test "Number equality test.8"
      #f
      (= 4999999999999999727876154935214080.0+4999999999999999727876154935214080.0i
         5000000000000000000000000000000000+5000000000000000000000000000000000i ))

(test "Number equality test.9"
      #f
      (= 5000000000000000000000000000000000+4999999999999999727876154935214080.0i
         5000000000000000000000000000000000+5000000000000000000000000000000000i ))

(test "Number equality test.10"
      #f
       (= 4999999999999999727876154935214080.0+5000000000000000000000000000000000i
          5000000000000000000000000000000000+5000000000000000000000000000000000i ))

(test "Number equality test.11"
      #t
       (= 4999999999999999727876154935214080.0+5000000000000000000000000000000000i
          4999999999999999727876154935214080+5000000000000000000000000000000000i ))

(test "Number equality test.12"
      #t
       (= 5000000000000000000000000000000000+4999999999999999727876154935214080.0i
          5000000000000000000000000000000000+4999999999999999727876154935214080i))

(test "Number equality test.13"
      #f
      (= 1/3 #i1/3))

(test "Number equality test.14"
      #f
      (= #i1/3 1/3))

(test "Number equality test.15"
      #f
      (= (exact->inexact (inexact->exact 1/3)) 1/3))

;; Tests added on 2024-08-02 for STk_add2, STk_mul2, STk_mul2, STk_div2 dont
;; try to convert numbers before doing the operation (this permit to limit
;; some number allocation
;; NOTE: this is very basic and not sufficient

(define (approx?  n1 n2)
  (cond
   ((and (real? n1) (real? n2))
    (if (zero? n1)
        (= n1 n2)
        (< (abs (/ (- n1 n2) n1)) 1e-10)))
    ((and (complex? n1) (complex? n2))
     (and (approx? (real-part n1) (real-part n2))
          (approx? (imag-part n1) (imag-part n2))))
    (else (= n1 n2))))

(test "Simple testing STk_add2.1" '6+4i
      (+ 3+2i 3+2i) approx?)
(test "Simple testing STk_add2.2" '4.23+2i
      (+ 3+2i 1.23) approx?)
(test "Simple testing STk_add2.3" '70/23+2i
      (+ 3+2i 1/23) approx?)
(test "Simple testing STk_add2.4" '1222222222222222222222222222222222222226+2i
      (+ 3+2i 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_add2.5" '126+2i
      (+ 3+2i 123) approx?)
(test "Simple testing STk_add2.6" '4.23+2i
      (+ 1.23 3+2i) approx?)
(test "Simple testing STk_add2.7" '2.46
      (+ 1.23 1.23) approx?)
(test "Simple testing STk_add2.8" '1.27347826086957
      (+ 1.23 1/23) approx?)
(test "Simple testing STk_add2.9" '1.22222222222222e+39
      (+ 1.23 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_add2.10" '124.23
      (+ 1.23 123) approx?)
(test "Simple testing STk_add2.11" '70/23+2i
      (+ 1/23 3+2i) approx?)
(test "Simple testing STk_add2.12" '1.27347826086957
      (+ 1/23 1.23) approx?)
(test "Simple testing STk_add2.13" '2/23
      (+ 1/23 1/23) approx?)
(test "Simple testing STk_add2.14" '28111111111111111111111111111111111111130/23
      (+ 1/23 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_add2.15" '2830/23
      (+ 1/23 123) approx?)
(test "Simple testing STk_add2.16" '122222222222222222222222226+2i
      (+ 122222222222222222222222223 3+2i) approx?)
(test "Simple testing STk_add2.17" '1.22222222222222e+26
      (+ 122222222222222222222222223 1.23) approx?)
(test "Simple testing STk_add2.18" '2811111111111111111111111130/23
      (+ 122222222222222222222222223 1/23) approx?)
(test "Simple testing STk_add2.19" '1222222222222344444444444444444444444446
      (+ 122222222222222222222222223 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_add2.20" '122222222222222222222222346
      (+ 122222222222222222222222223 123) approx?)
(test "Simple testing STk_add2.21" '126+2i
      (+ 123 3+2i) approx?)
(test "Simple testing STk_add2.22" '124.23
      (+ 123 1.23) approx?)
(test "Simple testing STk_add2.23" '2830/23
      (+ 123 1/23) approx?)
(test "Simple testing STk_add2.24" '1222222222222222222222222222222222222346
      (+ 123 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_add2.25" '246
      (+ 123 123) approx?)
(test "Simple testing STk_sub2.1" '0
      (- 3+2i 3+2i) approx?)
(test "Simple testing STk_sub2.2" '1.77+2i
      (- 3+2i 1.23) approx?)
(test "Simple testing STk_sub2.3" '68/23+2i
      (- 3+2i 1/23) approx?)
(test "Simple testing STk_sub2.4" '-1222222222222222222222222222222222222220+2i
      (- 3+2i 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_sub2.5" '-120+2i
      (- 3+2i 123) approx?)
(test "Simple testing STk_sub2.6" '-1.77-2i
      (- 1.23 3+2i) approx?)
(test "Simple testing STk_sub2.7" '0.0
      (- 1.23 1.23) approx?)
(test "Simple testing STk_sub2.8" '1.18652173913043
      (- 1.23 1/23) approx?)
(test "Simple testing STk_sub2.9" '-1.22222222222222e+39
      (- 1.23 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_sub2.10" '-121.77
      (- 1.23 123) approx?)
(test "Simple testing STk_sub2.11" '-68/23-2i
      (- 1/23 3+2i) approx?)
(test "Simple testing STk_sub2.12" '-1.18652173913043
      (- 1/23 1.23) approx?)
(test "Simple testing STk_sub2.13" '0
      (- 1/23 1/23) approx?)
(test "Simple testing STk_sub2.14" '-28111111111111111111111111111111111111128/23
      (- 1/23 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_sub2.15" '-2828/23
      (- 1/23 123) approx?)
(test "Simple testing STk_sub2.16" '122222222222222222222222220-2i
      (- 122222222222222222222222223 3+2i) approx?)
(test "Simple testing STk_sub2.17" '1.22222222222222e+26
      (- 122222222222222222222222223 1.23) approx?)
(test "Simple testing STk_sub2.18" '2811111111111111111111111128/23
      (- 122222222222222222222222223 1/23) approx?)
(test "Simple testing STk_sub2.19" '-1222222222222100000000000000000000000000
      (- 122222222222222222222222223 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_sub2.20" '122222222222222222222222100
      (- 122222222222222222222222223 123) approx?)
(test "Simple testing STk_sub2.21" '120-2i
      (- 123 3+2i) approx?)
(test "Simple testing STk_sub2.22" '121.77
      (- 123 1.23) approx?)
(test "Simple testing STk_sub2.23" '2828/23
      (- 123 1/23) approx?)
(test "Simple testing STk_sub2.24" '-1222222222222222222222222222222222222100
      (- 123 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_sub2.25" '0
      (- 123 123) approx?)
(test "Simple testing STk_div2.1" '1
      (/ 3+2i 3+2i) approx?)
(test "Simple testing STk_div2.2" '2.4390243902439+1.6260162601626i
      (/ 3+2i 1.23) approx?)
(test "Simple testing STk_div2.3" '69+46i
      (/ 3+2i 1/23) approx?)
(test "Simple testing STk_div2.4" '3/1222222222222222222222222222222222222223+2/1222222222222222222222222222222222222223i
      (/ 3+2i 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_div2.5" '1/41+2/123i
      (/ 3+2i 123) approx?)
(test "Simple testing STk_div2.6" '0.283846153846154-0.189230769230769i
      (/ 1.23 3+2i) approx?)
(test "Simple testing STk_div2.7" '1.0
      (/ 1.23 1.23) approx?)
(test "Simple testing STk_div2.8" '28.29
      (/ 1.23 1/23) approx?)
(test "Simple testing STk_div2.9" '1.00636363636364e-39
      (/ 1.23 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_div2.10" '0.01
      (/ 1.23 123) approx?)
(test "Simple testing STk_div2.11" '3/299-2/299i
      (/ 1/23 3+2i) approx?)
(test "Simple testing STk_div2.12" '0.0353481795687522
      (/ 1/23 1.23) approx?)
(test "Simple testing STk_div2.13" '1
      (/ 1/23 1/23) approx?)
(test "Simple testing STk_div2.14" '1/28111111111111111111111111111111111111129
      (/ 1/23 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_div2.15" '1/2829
      (/ 1/23 123) approx?)
(test "Simple testing STk_div2.16" '366666666666666666666666669/13-244444444444444444444444446/13i
      (/ 122222222222222222222222223 3+2i) approx?)
(test "Simple testing STk_div2.17" '9.93676603432701e+25
      (/ 122222222222222222222222223 1.23) approx?)
(test "Simple testing STk_div2.18" '2811111111111111111111111129
      (/ 122222222222222222222222223 1/23) approx?)
(test "Simple testing STk_div2.19" '122222222222222222222222223/1222222222222222222222222222222222222223
      (/ 122222222222222222222222223 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_div2.20" '40740740740740740740740741/41
      (/ 122222222222222222222222223 123) approx?)
(test "Simple testing STk_div2.21" '369/13-246/13i
      (/ 123 3+2i) approx?)
(test "Simple testing STk_div2.22" '100.0
      (/ 123 1.23) approx?)
(test "Simple testing STk_div2.23" '2829
      (/ 123 1/23) approx?)
(test "Simple testing STk_div2.24" '123/1222222222222222222222222222222222222223
      (/ 123 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_div2.25" '1
      (/ 123 123) approx?)
(test "Simple testing STk_mul2.1" '5+12i
      (* 3+2i 3+2i) approx?)
(test "Simple testing STk_mul2.2" '3.69+2.46i
      (* 3+2i 1.23) approx?)
(test "Simple testing STk_mul2.3" '3/23+2/23i
      (* 3+2i 1/23) approx?)
(test "Simple testing STk_mul2.4" '3666666666666666666666666666666666666669+2444444444444444444444444444444444444446i
      (* 3+2i 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_mul2.5" '369+246i
      (* 3+2i 123) approx?)
(test "Simple testing STk_mul2.6" '3.69+2.46i
      (* 1.23 3+2i) approx?)
(test "Simple testing STk_mul2.7" '1.5129
      (* 1.23 1.23) approx?)
(test "Simple testing STk_mul2.8" '0.0534782608695652
      (* 1.23 1/23) approx?)
(test "Simple testing STk_mul2.9" '1.50333333333333e+39
      (* 1.23 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_mul2.10" '151.29
      (* 1.23 123) approx?)
(test "Simple testing STk_mul2.11" '3/23+2/23i
      (* 1/23 3+2i) approx?)
(test "Simple testing STk_mul2.12" '0.0534782608695652
      (* 1/23 1.23) approx?)
(test "Simple testing STk_mul2.13" '1/529
      (* 1/23 1/23) approx?)
(test "Simple testing STk_mul2.14" '1222222222222222222222222222222222222223/23
      (* 1/23 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_mul2.15" '123/23
      (* 1/23 123) approx?)
(test "Simple testing STk_mul2.16" '366666666666666666666666669+244444444444444444444444446i
      (* 122222222222222222222222223 3+2i) approx?)
(test "Simple testing STk_mul2.17" '1.50333333333333e+26
      (* 122222222222222222222222223 1.23) approx?)
(test "Simple testing STk_mul2.18" '122222222222222222222222223/23
      (* 122222222222222222222222223 1/23) approx?)
(test "Simple testing STk_mul2.19" '149382716049382716049382717000000000000095061728395061728395061729
      (* 122222222222222222222222223 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_mul2.20" '15033333333333333333333333429
      (* 122222222222222222222222223 123) approx?)
(test "Simple testing STk_mul2.21" '369+246i
      (* 123 3+2i) approx?)
(test "Simple testing STk_mul2.22" '151.29
      (* 123 1.23) approx?)
(test "Simple testing STk_mul2.23" '123/23
      (* 123 1/23) approx?)
(test "Simple testing STk_mul2.24" '150333333333333333333333333333333333333429
      (* 123 1222222222222222222222222222222222222223) approx?)
(test "Simple testing STk_mul2.25" '15129
      (* 123 123) approx?)


(test-section-end)
