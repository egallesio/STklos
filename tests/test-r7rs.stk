;;;;                                                    -*- coding: latin-1 -*-
;;;;
;;;; test-r7rs.stk      -- Testing R7RS constructs/primitives
;;;;
;;;; Copyright Â© 2011 Erick Gallesio - Polytech'Nice-Sophia <eg@unice.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 17-Apr-2011 20:58 (eg)
;;;; Last file update: 28-Jun-2018 10:39 (eg)
;;;;

(require "test")

(test-section "R7RS")


;;------------------------------------------------------------------
(test-subsection "Control features")

(test "string-map 1"  "abdegh"  (string-map char-downcase "AbdEgH"))
(test "string-map 2"  "IBM"     (string-map (lambda (c)
                                              (integer->char (+ 1 (char->integer c))))
                                            "HAL"))
(test "string-map 3"  "StUdLyCaPs"  (string-map (lambda (c k)
                                                  (if (eqv? k #\u)
                                                      (char-upcase c)
                                                      (char-downcase c)))
                                                "studlycaps"
                                                "ululululul"))

;; **********
(test "vector-map 1"
      #(b e h)
      (vector-map cadr '#((a b) (d e) (g h))))

(test "vector-map 2" #(1 4 27 256 3125)
      (vector-map (lambda (n) (expt n n))
                  '#(1 2 3 4 5)))

(test "vector-map 3" #(5 7 9)
      (vector-map + '#(1 2 3) '#(4 5 6)))

(test "vector-map 4"  #(1 2)
      (let ((count 0))
        (vector-map (lambda (ignored)
                      (set! count (+ count 1))
                      count)
                    '#(a b))))

;; **********
(test "string-for-each"
      '(101 100 99 98 97)
      (let ((v (list)))
        (string-for-each (lambda (c) (set! v (cons (char->integer c) v)))
                         "abcde")
         v))

;; **********
(test "vector-for-each"
      '#(0 1 4 9 16)
      (let ((v (make-vector 5)))
        (vector-for-each (lambda (i) (vector-set! v i (* i i)))
                         '#(0 1 2 3 4))
        v))

;;------------------------------------------------------------------
(test-subsection "Strings")

(test "Extended string=?.1" #t (string=? "a"))
(test "Extended string=?.2" #t (string=? "a" "a" "a" "a"))
(test "Extended string=?.3" #f (string=? "a" "a" "A" "a"))

(test "Extended string-ci=?.1" #t (string-ci=? "a"))
(test "Extended string-ci=?.2" #t (string-ci=? "a" "a" "a" "a"))
(test "Extended string-ci=?.3" #t (string-ci=? "a" "a" "A" "a"))
(test "Extended string-ci=?.4" #f (string-ci=? "a" "a" "A" "b"))

(test "Extended string<?.1" #t (string<? "a"))
(test "Extended string<?.2" #t (string<? "a" "b" "c" "d"))
(test "Extended string<?.3" #f (string<? "a" "B" "c" "D"))
(test "Extended string<?.4" #f (string<? "a" "a" "A" "b"))

(test "Extended string-ci<?.1" #t (string-ci<? "a"))
(test "Extended string-ci<?.2" #t (string-ci<? "a" "b" "c" "d"))
(test "Extended string-ci<?.3" #t (string-ci<? "a" "B" "c" "D"))
(test "Extended string-ci<?.4" #f (string-ci<? "a" "a" "A" "b"))

(let ((str "abcdef"))
  (test "Extended string->list.1" '(#\a #\b #\c #\d #\e #\f) (string->list str))
  (test "Extended string->list.2" '(#\c #\d #\e #\f) (string->list str 2))
  (test "Extended string->list.3" '(#\c #\d #\e) (string->list str 2 5))
  (test "Extended string->list.4" *test-failed* (string->list str 2 100))

  (test "Extended string-copy.1" "abcdef" (string-copy str))
  (test "Extended string-copy.2" "cdef" (string-copy str 2))
  (test "Extended string-copy.3" "cde" (string-copy str 2 5))
  (test "Extended string-copy.4" *test-failed* (string-copy str 2 100)))


(test "string-copy!.1"
      "abc12f"
      (let ((s (string-copy "abcdef"))) (string-copy! s 3 "12") s))
(test "string-copy!.2"
      *test-failed*
      (let ((s (string-copy "abcdef"))) (string-copy! s 5 "12") s))
(test "string-copy!.3"
      "a23def"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 1) s))
(test "string-copy!.4"
      "a23def"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 1) s))
(test "string-copy!.5"
      "a3cdef"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 2) s))
(test "string-copy!.6"
      "abcdef"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 3) s))
(test "string-copy!.7"
      "a12def"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 0 2) s))
(test "string-copy!.8"
      "a123ef"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 0 3) s))
(test "string-copy!.9"
      *test-failed*
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 0 4) s))

(test "string-copy! overlap.1"
      "ababcfg"
      (let ((s (string-copy "abcdefg")))   (string-copy! s 2 s 0 3) s))

(test "string-copy! overlap.2"
      "efcdefg"
      (let ((s (string-copy "abcdefg")))   (string-copy! s 0 s 4 6) s))

;;------------------------------------------------------------------
(test-subsection "Lists and Pairs")

(test "member with 3d parameter.1"
      '("b" "c")
      (member "B" '("a" "b" "c") string-ci=?))

(test "member with 3d parameter.2"
      '(2.0 3.0)
      (member 1.99 '(1.0 2.0 3.0) (lambda (x y) (< (abs (- x y)) 0.1))))

(test "assoc with 3d parameter.1"
      '(2 4)
      (assoc 2.0 '((1 1) (2 4) (3 9)) =))

(test "assoc with 3d parameter.2"
      '("b" 4)
      (assoc "B" '(("a" 1) ("b" 4) ("c" 9)) string-ci=?))

(test "list-set!.1"
      '("foo" 2 3)
      (let ((l (list 1 2 3)))
        (list-set! l 0 "foo")
        l))

(test "make-list.1"
      '(#void #void #void)
      (make-list 3))

(test "make-list.2"
      '(42 42 42 42)
      (make-list 4 42))

(test-section-end)
