;;;;
;;;; test-srfi.stk  -- Test of various SRFIs
;;;;
;;;; Copyright Â© 2005-2020 Erick Gallesio - I3S-CNRS/ESSI <eg@essi.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@essi.fr]
;;;;    Creation date:  4-Aug-2005 10:34 (eg)
;;;; Last file update: 21-Oct-2020 13:07 (eg)
;;;;

(require "test")


(test-section "SRFIs")

;; ----------------------------------------------------------------------
;;  SRFI 2 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 2 - AND-LET*: an AND with local bindings ...")

(require "srfi-2")

(test "and-let*.1" 1  (and-let* () 1))
(test "and-let*.2" 2  (and-let* () 1 2))
(test "and-let*.3" #t (and-let* () ))
(test "and-let*.4" #f  (let ((x #f)) (and-let* (x))))
(test "and-let*.5" 1   (let ((x 1)) (and-let* (x))))
(test "and-let*.6" #f  (and-let* ((x #f)) ))
(test "and-let*.7" 1   (and-let* ((x 1)) ))
(test/error "and-let*.8" (and-let* ( #f (x 1))))
(test "and-let*.9" #f (and-let* ( (#f) (x 1))))
(test/error "and-let*.10" (and-let* (2 (x 1))) )
(test "and-let*.11" 1  (and-let* ( (2) (x 1)) ))
(test "and-let*.12" 2  (and-let* ( (x 1) (2)) ))
(test "and-let*.13" #f (let ((x #f)) (and-let* (x) x)))
(test "and-let*.14" "" (let ((x "")) (and-let* (x) x)))
(test "and-let*.15" "" (let ((x "")) (and-let* (x)  )))
(test "and-let*.16" 2  (let ((x 1)) (and-let* (x) (+ x 1))))
(test "and-let*.17" #f (let ((x #f)) (and-let* (x) (+ x 1))))
(test "and-let*.18" 2  (let ((x 1)) (and-let* (((positive? x))) (+ x 1))))
(test "and-let*.19" #t (let ((x 1)) (and-let* (((positive? x))) )))
(test "and-let*.20" #f (let ((x 0)) (and-let* (((positive? x))) (+ x 1))))
(test "and-let*.21" 3  (let ((x 1))
                         (and-let* (((positive? x)) (x (+ x 1))) (+ x 1))))
(test/error "and-let*.22" (let ((x 1))
                            (and-let* (((positive? x)) (x (+ x 1)) (x (+ x 1)))
                                      (+ x 1))))
(test "and-let*.23" 2  (let ((x 1)) (and-let* (x ((positive? x))) (+ x 1))))
(test "and-let*.24" 2  (let ((x 1))
                         (and-let* ( ((begin x)) ((positive? x))) (+ x 1))))
(test "and-let*.25" #f (let ((x 0)) (and-let* (x ((positive? x))) (+ x 1))))
(test "and-let*.26" #f (let ((x #f)) (and-let* (x ((positive? x))) (+ x 1))))
(test "and-let*.27" #f (let ((x #f))
                         (and-let* ( ((begin x)) ((positive? x))) (+ x 1))))
(test "and-let*.28" #f (let ((x 1))
                         (and-let* (x (y (- x 1)) ((positive? y))) (/ x y))))
(test "and-let*.29" #f (let ((x 0))
                         (and-let* (x (y (- x 1)) ((positive? y))) (/ x y))))
(test "and-let*.30" #f (let ((x #f))
                         (and-let* (x (y (- x 1)) ((positive? y))) (/ x y))))
(test "and-let*.31" 3/2 (let ((x 3))
                          (and-let* (x (y (- x 1)) ((positive? y))) (/ x y))))

;; ----------------------------------------------------------------------
;;  SRFI 5 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 5 - A compatible let form ...")

(require "srfi-5")

;; A binding list must be a sequence of pairs, and with SRFI-5,
;; these mayy be followed by a SYMBOL and a free list.
;; But it MUST be a symbol!
(test/error "error in bindings"
            (let ((a 1)
                  (b 2)
                  3 4 5)))

(test "Unnamed.0"
      #f
      (let () #f))

(test "Unnamed.1"
      '(2 . 1)
      (let ((x 1) (y 2)) (cons y x)))

(test "Named, non-signature-style, no rest argument"
      55
      (let loop ((i 10) (sum 0))
        (if (> i 0)
            (loop (- i 1) (+ sum i))
            sum)))

(test "Named, signature-style, no rest argument"
      55
      (let (loop (i 10) (sum 0))
        (if (> i 0)
            (loop (- i 1) (+ sum i))
            sum)))

(test "Named, non-signature-style, rest argument"
      '(4 3 2 1)
      (let reverse-list ((res '()) . (l 1 2 3 4))
        (if (null? l)
            res
            (apply reverse-list (cons (car l) res) (cdr l)))))

(test "Named, signature-style, rest argument"
      '(4 3 2 1)
      (let (reverse-list (res '()) . (l 1 2 3 4))
        (if (null? l)
            res
            (apply reverse-list (cons (car l) res) (cdr l)))))

;; The two following tests are Andy Gaynor's examples from the SRFI:
(test "fibonacci"
      55
      (let (fibonacci (n 10) (i 0) (f0 0) (f1 1))
        (if (= i n)
            f0
            (fibonacci n (+ i 1) f1 (+ f0 f1)))))

(test "contrived"
      "345"
      (with-output-to-string
        (lambda ()
          (let (blast (port (current-output-port)) . (x (+ 1 2) 4 5))
            (if (null? x)
                'just-a-silly-contrived-example
                (begin
                  (write (car x) port)
                  (apply blast port (cdr x))))))))

(test "recursive list sum"
      21
      (let (loop (sum 0) (lst '(1 2 3 4 5 6)))
        (if (null? lst)
            sum
            (loop (+ (car lst) sum) (cdr lst)))))

(test "recursive list sum with rest arguments"
      21
      (let (loop (sum 0) . (lst 1 2 3 4 5 6))
        (if (null? lst)
            sum
            (apply loop (+ (car lst) sum) (cdr lst)))))

;; ----------------------------------------------------------------------
;;  SRFI 13 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 13 - String Libraries")

(require "srfi-13")
(require "srfi-14")


(define (fill text)
  (let* ((len (string-length text))
         (max-text-len 60)
         (last-col 70)
         (text (if (> len max-text-len)
                   (begin
                     (set! len max-text-len)
                     (substring text 0 max-text-len))
                   text)))
    (string-append text (make-string (- last-col len) #\.))))

; Tests for SRFI-13 as implemented by the Gauche scheme system.
;;
;;   Copyright (c) 2000-2003 Shiro Kawai, All rights reserved.
;;
;;   Redistribution and use in source and binary forms, with or without
;;   modification, are permitted provided that the following conditions
;;   are met:
;;
;;    1. Redistributions of source code must retain the above copyright
;;       notice, this list of conditions and the following disclaimer.
;;
;;    2. Redistributions in binary form must reproduce the above copyright
;;       notice, this list of conditions and the following disclaimer in the
;;       documentation and/or other materials provided with the distribution.
;;
;;    3. Neither the name of the authors nor the names of its contributors
;;       may be used to endorse or promote products derived from this
;;       software without specific prior written permission.
;;
;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;
;; See http://sourceforge.net/projects/gauche/

(test "string-null?" #f (string-null? "abc"))
(test "string-null?" #t (string-null? ""))
(test "string-every" #t (string-every #\a ""))
(test "string-every" #t (string-every #\a "aaaa"))
(test "string-every" #f (string-every #\a "aaba"))
(test "string-every" #t (string-every char-set:lower-case "aaba"))
(test "string-every" #f (string-every char-set:lower-case "aAba"))
(test "string-every" #t (string-every char-set:lower-case ""))
(test "string-every" #t (string-every (lambda (x) (char-ci=? x #\a)) "aAaA"))
(test "string-every" #f (string-every (lambda (x) (char-ci=? x #\a)) "aAbA"))
(test "string-every" (char->integer #\A)
       (string-every (lambda (x) (char->integer x)) "aAbA"))
(test "string-every" #t
       (string-every (lambda (x) (error "hoge")) ""))
(test "string-any" #t (string-any #\a "aaaa"))
(test "string-any" #f (string-any #\a "Abcd"))
(test "string-any" #f (string-any #\a ""))
(test "string-any" #t (string-any char-set:lower-case "ABcD"))
(test "string-any" #f (string-any char-set:lower-case "ABCD"))
(test "string-any" #f (string-any char-set:lower-case ""))
(test "string-any" #t (string-any (lambda (x) (char-ci=? x #\a)) "CAaA"))
(test "string-any" #f (string-any (lambda (x) (char-ci=? x #\a)) "ZBRC"))
(test "string-any" #f (string-any (lambda (x) (char-ci=? x #\a)) ""))
(test "string-any" (char->integer #\a)
       (string-any (lambda (x) (char->integer x)) "aAbA"))
(test "string-tabulate" "0123456789"
       (string-tabulate (lambda (code)
                          (integer->char (+ code (char->integer #\0))))
                        10))
(test "string-tabulate" ""
       (string-tabulate (lambda (code)
                          (integer->char (+ code (char->integer #\0))))
                        0))
(test "reverse-list->string" "cBa"
       (reverse-list->string '(#\a #\B #\c)))
(test "reverse-list->string" ""
       (reverse-list->string '()))
; string-join : Gauche builtin.
(test "substring/shared" "cde" (substring/shared "abcde" 2))
(test "substring/shared" "cd"  (substring/shared "abcde" 2 4))
(test "string-copy!" "abCDEfg"
       (let ((x (string-copy "abcdefg")))
         (string-copy! x 2 "CDE")
         x))
(test "string-copy!" "abCDEfg"
       (let ((x (string-copy "abcdefg")))
         (string-copy! x 2 "ZABCDE" 3)
         x))
(test "string-copy!" "abCDEfg"
       (let ((x (string-copy "abcdefg")))
         (string-copy! x 2 "ZABCDEFG" 3 6)
         x))

;; From Guile.  Thanks to Mark H Weaver.
(test "string-copy!: overlapping src and dest, moving right"
      "aabce"
      (let ((str (string-copy "abcde")))
    (string-copy! str 1 str 0 3) str))

(test "string-copy!: overlapping src and dest, moving left"
      "bcdde"
      (let ((str (string-copy "abcde")))
    (string-copy! str 0 str 1 4) str))

(test "string-take" "Pete S"  (string-take "Pete Szilagyi" 6))
(test "string-take" ""        (string-take "Pete Szilagyi" 0))
(test "string-take" "Pete Szilagyi" (string-take "Pete Szilagyi" 13))
(test "string-drop" "zilagyi" (string-drop "Pete Szilagyi" 6))
(test "string-drop" "Pete Szilagyi" (string-drop "Pete Szilagyi" 0))
(test "string-drop" ""        (string-drop "Pete Szilagyi" 13))

(test "string-take-right" "rules" (string-take-right "Beta rules" 5))
(test "string-take-right" ""      (string-take-right "Beta rules" 0))
(test "string-take-right" "Beta rules" (string-take-right "Beta rules" 10))
(test "string-drop-right" "Beta " (string-drop-right "Beta rules" 5))
(test "string-drop-right" "Beta rules" (string-drop-right "Beta rules" 0))
(test "string-drop-right" ""      (string-drop-right "Beta rules" 10))

(test "string-pad" "  325" (string-pad "325" 5))
(test "string-pad" "71325" (string-pad "71325" 5))
(test "string-pad" "71325" (string-pad "8871325" 5))
(test "string-pad" "~~325" (string-pad "325" 5 #\~))
(test "string-pad" "~~~25" (string-pad "325" 5 #\~ 1))
(test "string-pad" "~~~~2" (string-pad "325" 5 #\~ 1 2))
(test "string-pad-right" "325  " (string-pad-right "325" 5))
(test "string-pad-right" "71325" (string-pad-right "71325" 5))
(test "string-pad-right" "88713" (string-pad-right "8871325" 5))
(test "string-pad-right" "325~~" (string-pad-right "325" 5 #\~))
(test "string-pad-right" "25~~~" (string-pad-right "325" 5 #\~ 1))
(test "string-pad-right" "2~~~~" (string-pad-right "325" 5 #\~ 1 2))

(test "string-trim"  "a b c d  \n"
       (string-trim "  \t  a b c d  \n"))
(test "string-trim"  "\t  a b c d  \n"
       (string-trim "  \t  a b c d  \n" #\space))
(test "string-trim"  "a b c d  \n"
       (string-trim "4358948a b c d  \n" char-set:digit))

(test "string-trim-right"  "  \t  a b c d"
       (string-trim-right "  \t  a b c d  \n"))
(test "string-trim-right"  "  \t  a b c d  "
       (string-trim-right "  \t  a b c d  \n" (char-set #\newline)))
(test "string-trim-right"  "349853a b c d"
       (string-trim-right "349853a b c d03490" char-set:digit))

(test "string-trim-both"  "a b c d"
       (string-trim-both "  \t  a b c d  \n"))
(test "string-trim-both"  "  \t  a b c d  "
       (string-trim-both "  \t  a b c d  \n" (char-set #\newline)))
(test "string-trim-both"  "a b c d"
       (string-trim-both "349853a b c d03490" char-set:digit))

;; string-fill - in string.scm

(test "string-compare" 5
       (string-compare "The cat in the hat" "abcdefgh"
                       values values values
                       4 6 2 4))
(test "string-compare-ci" 5
       (string-compare-ci "The cat in the hat" "ABCDEFGH"
                          values values values
                          4 6 2 4))

;; TODO: bunch of string= families

(test "string-prefix-length" 5
       (string-prefix-length "cancaNCAM" "cancancan"))
(test "string-prefix-length-ci" 8
       (string-prefix-length-ci "cancaNCAM" "cancancan"))
(test "string-suffix-length" 2
       (string-suffix-length "CanCan" "cankancan"))
(test "string-suffix-length-ci" 5
       (string-suffix-length-ci "CanCan" "cankancan"))

(test "string-prefix?" #t    (string-prefix? "abcd" "abcdefg"))
(test "string-prefix?" #f    (string-prefix? "abcf" "abcdefg"))
(test "string-prefix-ci?" #t (string-prefix-ci? "abcd" "aBCDEfg"))
(test "string-prefix-ci?" #f (string-prefix-ci? "abcf" "aBCDEfg"))
(test "string-suffix?" #t    (string-suffix? "defg" "abcdefg"))
(test "string-suffix?" #f    (string-suffix? "aefg" "abcdefg"))
(test "string-suffix-ci?" #t (string-suffix-ci? "defg" "aBCDEfg"))
(test "string-suffix-ci?" #f (string-suffix-ci? "aefg" "aBCDEfg"))

(test "string-index #1" 4
       (string-index "abcd:efgh:ijkl" #\:))
(test "string-index #2" 4
       (string-index "abcd:efgh;ijkl" (char-set-complement char-set:letter)))
(test "string-index #3" #f
       (string-index "abcd:efgh;ijkl" char-set:digit))
(test "string-index #4" 9
       (string-index "abcd:efgh:ijkl" #\: 5))
(test "string-index-right #1" 4
       (string-index-right "abcd:efgh;ijkl" #\:))
(test "string-index-right #2" 9
       (string-index-right "abcd:efgh;ijkl" (char-set-complement char-set:letter)))
(test "string-index-right #3" #f
       (string-index-right "abcd:efgh;ijkl" char-set:digit))
(test "string-index-right #4" 4
       (string-index-right "abcd:efgh;ijkl" (char-set-complement char-set:letter) 2 5))

(test "string-count #1" 2
       (string-count "abc def\tghi jkl" #\space))
(test "string-count #2" 3
       (string-count "abc def\tghi jkl" char-set:whitespace))
(test "string-count #3" 2
       (string-count "abc def\tghi jkl" char-set:whitespace 4))
(test "string-count #4" 1
       (string-count "abc def\tghi jkl" char-set:whitespace 4 9))
(test "string-contains" 3
       (string-contains "Ma mere l'oye" "mer"))
(test "string-contains" #f
       (string-contains "Ma mere l'oye" "Mer"))
(test "string-contains-ci" 3
       (string-contains-ci "Ma mere l'oye" "Mer"))
(test "string-contains-ci" #f
       (string-contains-ci "Ma mere l'oye" "Meer"))

(test "string-titlecase" "--Capitalize This Sentence."
       (string-titlecase "--capitalize tHIS sentence."))
(test "string-titlecase" "3Com Makes Routers."
       (string-titlecase "3com makes routers."))
(test "string-titlecase!" "alSo Whatever"
       (let ((s (string-copy "also whatever")))
         (string-titlecase! s 2 9)
         s))

(test "string-upcase" "SPEAK LOUDLY"
       (string-upcase "speak loudly"))
(test "string-upcase" "PEAK"
       (string-upcase "speak loudly" 1 5))
(test "string-upcase!" "sPEAK loudly"
       (let ((s (string-copy "speak loudly")))
         (string-upcase! s 1 5)
         s))

(test "string-downcase" "speak softly"
       (string-downcase "SPEAK SOFTLY"))
(test "string-downcase" "peak"
       (string-downcase "SPEAK SOFTLY" 1 5))
(test "string-downcase!" "Speak SOFTLY"
       (let ((s (string-copy "SPEAK SOFTLY")))
         (string-downcase! s 1 5)
         s))

(test "string-reverse" "nomel on nolem on"
       (string-reverse "no melon no lemon"))
(test "string-reverse" "nomel on"
       (string-reverse "no melon no lemon" 9))
(test "string-reverse" "on"
       (string-reverse "no melon no lemon" 9 11))
(test "string-reverse!" "nomel on nolem on"
       (let ((s (string-copy "no melon no lemon")))
         (string-reverse! s) s))
(test "string-reverse!" "no melon nomel on"
       (let ((s (string-copy "no melon no lemon")))
         (string-reverse! s 9) s))
(test "string-reverse!" "no melon on lemon"
       (let ((s (string-copy "no melon no lemon")))
         (string-reverse! s 9 11) s))

(test "string-append" #f
       (let ((s "test")) (eq? s (string-append s))))
(test "string-concatenate" #f
       (let ((s "test")) (eq? s (string-concatenate (list s)))))
(test "string-concatenate" "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
       (string-concatenate
        '("A" "B" "C" "D" "E" "F" "G" "H"
          "I" "J" "K" "L" "M" "N" "O" "P"
          "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
          "a" "b" "c" "d" "e" "f" "g" "h"
          "i" "j" "k" "l" "m" "n" "o" "p"
          "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))
(test "string-concatenate/shared" "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
       (string-concatenate/shared
        '("A" "B" "C" "D" "E" "F" "G" "H"
          "I" "J" "K" "L" "M" "N" "O" "P"
          "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
          "a" "b" "c" "d" "e" "f" "g" "h"
          "i" "j" "k" "l" "m" "n" "o" "p"
          "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))
(test "string-concatenate-reverse" "zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA"
       (string-concatenate-reverse
        '("A" "B" "C" "D" "E" "F" "G" "H"
          "I" "J" "K" "L" "M" "N" "O" "P"
          "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
          "a" "b" "c" "d" "e" "f" "g" "h"
          "i" "j" "k" "l" "m" "n" "o" "p"
          "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))
(test "string-concatenate-reverse" #f
       (let ((s "test"))
         (eq? s (string-concatenate-reverse (list s)))))
(test "string-concatenate-reverse/shared" "zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA"
       (string-concatenate-reverse/shared
        '("A" "B" "C" "D" "E" "F" "G" "H"
          "I" "J" "K" "L" "M" "N" "O" "P"
          "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
          "a" "b" "c" "d" "e" "f" "g" "h"
          "i" "j" "k" "l" "m" "n" "o" "p"
          "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))

(test "string-map" "svool"
       (string-map (lambda (c)
                     (integer->char (- 219 (char->integer c))))
                   "hello"))
(test "string-map" "vool"
       (string-map (lambda (c)
                     (integer->char (- 219 (char->integer c))))
                   "hello" 1))
(test "string-map" "vo"
       (string-map (lambda (c)
                     (integer->char (- 219 (char->integer c))))
                   "hello" 1 3))
(test "string-map!" "svool"
       (let ((s (string-copy "hello")))
         (string-map! (lambda (c)
                        (integer->char (- 219 (char->integer c))))
                      s)
         s))
(test "string-map!" "hvool"
       (let ((s (string-copy "hello")))
         (string-map! (lambda (c)
                        (integer->char (- 219 (char->integer c))))
                      s 1)
         s))
(test "string-map!" "hvolo"
       (let ((s (string-copy "hello")))
         (string-map! (lambda (c)
                        (integer->char (- 219 (char->integer c))))
                      s 1 3)
         s))

(test "string-fold" '(#\o #\l #\l #\e #\h . #t)
       (string-fold cons #t "hello"))
(test "string-fold" '(#\l #\e . #t)
       (string-fold cons #t "hello" 1 3))
(test "string-fold-right" '(#\h #\e #\l #\l #\o . #t)
       (string-fold-right cons #t "hello"))
(test "string-fold-right" '(#\e #\l . #t)
       (string-fold-right cons #t "hello" 1 3))

(test "string-unfold" "hello"
       (string-unfold null? car cdr '(#\h #\e #\l #\l #\o)))
(test "string-unfold" "hi hello"
       (string-unfold null? car cdr '(#\h #\e #\l #\l #\o) "hi "))
(test "string-unfold" "hi hello ho"
       (string-unfold null? car cdr
                      '(#\h #\e #\l #\l #\o) "hi "
                      (lambda (x) " ho")))

(test "string-unfold-right" "olleh"
       (string-unfold-right null? car cdr '(#\h #\e #\l #\l #\o)))
(test "string-unfold-right" "olleh hi"
       (string-unfold-right null? car cdr '(#\h #\e #\l #\l #\o) " hi"))
(test "string-unfold-right" "ho olleh hi"
       (string-unfold-right null? car cdr
                            '(#\h #\e #\l #\l #\o) " hi"
                            (lambda (x) "ho ")))

(test "string-for-each" "CLtL"
       (let ((out (open-output-string))
             (prev #f))
         (string-for-each (lambda (c)
                            (if (or (not prev)
                                    (char-whitespace? prev))
                                (write-char c out))
                            (set! prev c))
                          "Common Lisp, the Language")

         (get-output-string out)))
(test "string-for-each" "oLtL"
       (let ((out (open-output-string))
             (prev #f))
         (string-for-each (lambda (c)
                            (if (or (not prev)
                                    (char-whitespace? prev))
                                (write-char c out))
                            (set! prev c))
                          "Common Lisp, the Language" 1)
         (get-output-string out)))
(test "string-for-each" "oL"
       (let ((out (open-output-string))
             (prev #f))
         (string-for-each (lambda (c)
                            (if (or (not prev)
                                    (char-whitespace? prev))
                                (write-char c out))
                            (set! prev c))
                          "Common Lisp, the Language" 1 10)
         (get-output-string out)))
(test "string-for-each-index" '(4 3 2 1 0)
       (let ((r '()))
         (string-for-each-index (lambda (i) (set! r (cons i r))) "hello")
         r))
(test "string-for-each-index" '(4 3 2 1)
       (let ((r '()))
         (string-for-each-index (lambda (i) (set! r (cons i r))) "hello" 1)
         r))
(test "string-for-each-index" '(2 1)
       (let ((r '()))
         (string-for-each-index (lambda (i) (set! r (cons i r))) "hello" 1 3)
         r))

(test "xsubstring" "cdefab"
       (xsubstring "abcdef" 2))
(test "xsubstring" "efabcd"
       (xsubstring "abcdef" -2))
(test "xsubstring" "abcabca"
       (xsubstring "abc" 0 7))
;; (test "xsubstring" "abcabca"
;;        (xsubstring "abc"
;;                    30000000000000000000000000000000
;;                    30000000000000000000000000000007))
(test "xsubstring" "defdefd"
       (xsubstring "abcdefg" 0 7 3 6))
(test "xsubstring" ""
       (xsubstring "abcdefg" 9 9 3 6))

(test "string-xcopy!" "ZZcdefabZZ"
       (let ((s (make-string 10 #\Z)))
         (string-xcopy! s 2 "abcdef" 2)
         s))
(test "string-xcopy!" "ZZdefdefZZ"
       (let ((s (make-string 10 #\Z)))
         (string-xcopy! s 2 "abcdef" 0 6 3)
         s))

(test "string-replace" "abcdXYZghi"
       (string-replace "abcdefghi" "XYZ" 4 6))
(test "string-replace" "abcdZghi"
       (string-replace "abcdefghi" "XYZ" 4 6 2))
(test "string-replace" "abcdZefghi"
       (string-replace "abcdefghi" "XYZ" 4 4 2))
(test "string-replace" "abcdefghi"
       (string-replace "abcdefghi" "XYZ" 4 4 1 1))
(test "string-replace" "abcdhi"
       (string-replace "abcdefghi" "" 4 7))

(test "string-tokenize" '("Help" "make" "programs" "run," "run," "RUN!")
       (string-tokenize "Help make programs run, run, RUN!"))
(test "string-tokenize" '("Help" "make" "programs" "run" "run" "RUN")
       (string-tokenize "Help make programs run, run, RUN!"
                        char-set:letter))
(test "string-tokenize" '("programs" "run" "run" "RUN")
       (string-tokenize "Help make programs run, run, RUN!"
                        char-set:letter 10))
(test "string-tokenize" '("elp" "make" "programs" "run" "run")
       (string-tokenize "Help make programs run, run, RUN!"
                        char-set:lower-case))

(test "string-filter" "rrrr"
       (string-filter #\r "Help make programs run, run, RUN!"))
(test "string-filter" "HelpmakeprogramsrunrunRUN"
       (string-filter char-set:letter "Help make programs run, run, RUN!"))

(test "string-filter" "programsrunrun"
       (string-filter (lambda (c) (char-lower-case? c))
                      "Help make programs run, run, RUN!"
                      10))
(test "string-filter" ""
       (string-filter (lambda (c) (char-lower-case? c)) ""))
(test "string-delete" "Help make pogams un, un, RUN!"
       (string-delete #\r "Help make programs run, run, RUN!"))
(test "string-delete" "   , , !"
       (string-delete char-set:letter "Help make programs run, run, RUN!"))
(test "string-delete" " , , RUN!"
       (string-delete (lambda (c) (char-lower-case? c))
                      "Help make programs run, run, RUN!"
                      10))
(test "string-delete" ""
       (string-delete (lambda (c) (char-lower-case? c)) ""))

;;; Additional tests so that the suite at least touches all
;;; the functions.

(test "string-hash" #t (<= 0 (string-hash "abracadabra" 20) 19))

(test "string-hash" #t (= (string-hash "abracadabra" 20) (string-hash "abracadabra" 20)))

(test "string-hash" #t (= (string-hash "abracadabra" 20 2 7)
                          (string-hash (substring "abracadabra" 2 7) 20)))

(test "string-hash-ci" #t (= (string-hash-ci "aBrAcAdAbRa" 20)
                             (string-hash-ci "AbRaCaDaBrA" 20)))

(test "string-hash-ci" #t (= (string-hash-ci "aBrAcAdAbRa" 20 2 7)
                             (string-hash-ci (substring "AbRaCaDaBrA" 2 7) 20)))

(test "string=" #t (string= "foo" "foo"))
(test "string=" #t (string= "foobar" "foo" 0 3))
(test "string=" #t (string= "foobar" "barfoo" 0 3 3))
(test "string=" #t (not (string= "foobar" "barfoo" 0 3 2 5)))

(test "string<>" #t (string<> "flo" "foo"))
(test "string<>" #t (string<> "flobar" "foo" 0 3))
(test "string<>" #t (string<> "flobar" "barfoo" 0 3 3))
(test "string<>" #t (not (string<> "foobar" "foobar" 0 3 0 3)))

(test "string<=" #t (string<= "fol" "foo"))
(test "string<=" #t (string<= "folbar" "foo" 0 3))
(test "string<=" #t (string<= "foobar" "barfoo" 0 3 3))
(test "string<=" #f (string<= "foobar" "barfoo" 0 3 1 4))

(test "string<" #t (string< "fol" "foo"))
(test "string<" #t (string< "folbar" "foo" 0 3))
(test "string<" #t (string< "folbar" "barfoo" 0 3 3))
(test "string<" #t (not (string< "foobar" "barfoo" 0 3 1 4)))

(test "string>=" #t (string>= "foo" "fol"))
(test "string>=" #t (string>= "foo" "folbar" 0 3 0 3))
(test "string>=" #t (string>= "barfoo" "foo" 3 6 0))
(test "string>=" #t (not (string>= "barfoo" "foobar" 1 4 0 3)))

(test "string>" #t (string> "foo" "fol"))
(test "string>" #t (string> "foo" "folbar" 0 3 0 3))
(test "string>" #t (string> "barfoo" "fol" 3 6 0))
(test "string>" #t (not (string> "barfoo" "foobar" 1 4 0 3)))

(test "string-ci=" #t (string-ci= "Foo" "foO"))
(test "string-ci=" #t (string-ci= "Foobar" "fOo" 0 3))
(test "string-ci=" #t (string-ci= "Foobar" "bArfOo" 0 3 3))
(test "string-ci=" #t (not (string-ci= "foobar" "BARFOO" 0 3 2 5)))

(test "string-ci<>" #t (string-ci<> "flo" "FOO"))
(test "string-ci<>" #t (string-ci<> "FLOBAR" "foo" 0 3))
(test "string-ci<>" #t (string-ci<> "flobar" "BARFOO" 0 3 3))
(test "string-ci<>" #t (not (string-ci<> "foobar" "FOOBAR" 0 3 0 3)))

(test "string-ci<=" #t (string-ci<= "FOL" "foo"))
(test "string-ci<=" #t (string-ci<= "folBAR" "fOO" 0 3))
(test "string-ci<=" #t (string-ci<= "fOOBAR" "BARFOO" 0 3 3))
(test "string-ci<=" #t (not (string-ci<= "foobar" "BARFOO" 0 3 1 4)))

(test "string-ci<" #t (string-ci< "fol" "FOO"))
(test "string-ci<" #t (string-ci< "folbar" "FOO" 0 3))
(test "string-ci<" #t (string-ci< "folbar" "BARFOO" 0 3 3))
(test "string-ci<" #t (not (string-ci< "foobar" "BARFOO" 0 3 1 4)))

(test "string-ci>=" #t (string-ci>= "FOO" "fol"))
(test "string-ci>=" #t (string-ci>= "foo" "FOLBAR" 0 3 0 3))
(test "string-ci>=" #t (string-ci>= "BARFOO" "foo" 3 6 0))
(test "string-ci>=" #t (not (string-ci>= "barfoo" "FOOBAR" 1 4 0 3)))

(test "string-ci>" #t (string-ci> "FOO" "fol"))
(test "string-ci>" #t (string-ci> "foo" "FOLBAR" 0 3 0 3))
(test "string-ci>" #t (string-ci> "barfoo" "FOL" 3 6 0))
(test "string-ci>" #t (not (string-ci> "barfoo" "FOOBAR" 1 4 0 3)))

(test "string=?" #t (string=? "abcd" (string-append/shared "a" "b" "c" "d")))

(test "string-parse-start+end"
      #t
      (let-values (((rest start end) (string-parse-start+end #t "foo" '(1 3 fnord))))
        (and (= start 1)
             (= end 3)
             (equal? rest '(fnord)))))

(test "string-parse-start+end"
      #t
      (call-with-current-continuation
       (lambda (k)
         (with-exception-handler
             (lambda (e) (k #t))
           (lambda ()
             (string-parse-start+end #t "foo" '(1 4))
             #f)))))

(test "string-parse-start+end"
      #t
      (let-values (((start end) (string-parse-final-start+end #t "foo" '(1 3))))
        (and (= start 1)
             (= end 3))))

(test "string-parse-start+end"
      #t
      (let-string-start+end (start end rest) #t "foo" '(1 3 fnord)
                            (and (= start 1)
                                 (= end 3)
                                 (equal? rest '(fnord)))))

(test "check-substring-spec"
      #void ;; unpecified, but STklos returns void
      (check-substring-spec #t "foo" 1 3))

;; adapted from Chicken; our version uses with-exception-handler
(test "check-substring-spec"
      #t
      (call-with-current-continuation
       (lambda (k)
         (with-exception-handler
             (lambda (e) (k #t))
           (lambda ()
             (check-substring-spec #t "foo" 1 4)
             #f)))))

(test "substring-spec-ok?"
      #t
      (substring-spec-ok? "foo" 1 3))

(test "substring-spec-ok?"
      #t
      (not (substring-spec-ok? "foo" 1 4)))

(test "make-kmp-restart-vector" '#() (make-kmp-restart-vector ""))

(test "make-kmp-restart-vector" '#(-1) (make-kmp-restart-vector "a"))

(test "make-kmp-restart-vector" '#(-1 0) (make-kmp-restart-vector "ab"))

; The following is from an example in the code.  It is the "optimised"
; version; it's also valid to return #(-1 0 0 0 1 2), but that will
; needlessly check the "a" twice before giving up.
(test "make-kmp-restart-vector"
      '#(-1 0 0 -1 1 2)
      (make-kmp-restart-vector "abdabx"))

;; Each entry in kmp-cases is a pattern, a string to match against and
;; the expected run of the algorithm through the positions in the
;; pattern.  So for example 0 1 2 means it looks at position 0 first,
;; then at 1 and then at 2.
;;
;; This is easy to verify in simple cases; If there's a shared
;; substring and matching fails, you try matching again starting at
;; the end of the shared substring, otherwise you rewind.  For more
;; complex cases, it's increasingly difficult for humans to verify :)
(define kmp-cases
  '(("abc" "xx" #f 0 0)
    ("abc" "abc" #t 0 1 2)
    ("abcd" "abc" #f 0 1 2)
    ("abc" "abcd" #t 0 1 2)
    ("abc" "aabc" #t 0 1 1 2)
    ("ab" "aa" #f 0 1)
    ("ab" "aab" #t 0 1 1)
    ("abdabx" "abdbbabda" #f 0 1 2 3 0 0 1 2 3)
    ("aabc" "axaabc" #t 0 1 0 1 2 3)
    ("aabac" "aabaabac" #t 0 1 2 3 4 2 3 4)))

(for-each
 (lambda (test-case)
   (let* ((pat (car test-case))
      (n (string-length pat))
      (str (cadr test-case))
          (match? (caddr test-case))
      (steps (cdddr test-case))
      (rv (make-kmp-restart-vector pat)))
     (let ((p (open-input-string str)))
       (let lp ((i 0)
        (step 0)
        (steps steps))
     (cond
       ((or (= i n) (eof-object? (peek-char p)))
        (test (format #f "KMP match? ~S, case: ~S" match? test-case)
                  #t
          (eq? (= i n) match?))
        (test (format #f "KMP empty remaining steps: ~S, case: ~S"
               steps test-case)
                  #t
             (null? steps)))
       (else
        (let ((new-i (kmp-step pat rv (read-char p) i char=? 0))
          (expected-i (and (not (null? steps)) (car steps))))
          (test (format #f "KMP step ~S (exp: ~S, act: ~S), case: ~S"
              step expected-i i test-case)
            expected-i i)
          (lp new-i (+ 1 step) (cdr steps)))))))))
 kmp-cases)

; FIXME!  Implement tests for these:
;   string-kmp-partial-search
;   kmp-step


;;; Regression tests: check that reported bugs have been fixed

; From: Matthias Radestock <matthias@sorted.org>
; Date: Wed, 10 Dec 2003 21:05:22 +0100
;
; Chris Double has found the following bug in the reference implementation:
;
;  (string-contains "xabc" "ab") => 1    ;good
;  (string-contains "aabc" "ab") => #f   ;bad
;
; Matthias.

(test "string-contains" 1 (string-contains "aabc" "ab"))

(test "string-contains" 5 (string-contains "ababdabdabxxas" "abdabx"))

(test "string-contains-ci" 1 (string-contains-ci "aabc" "ab"))

; (message continues)
;
; PS: There is also an off-by-one error in the bounds check of the
; unoptimized version of string-contains that is included as commented out
; code in the reference implementation. This breaks things like
; (string-contains "xab" "ab") and (string-contains "ab" "ab").

; This off-by-one bug has been fixed in the comments of the version
; of SRFI-13 shipped with Larceny.  In a version of the code without
; the fix the following test will catch the bug:

(test "string-contains" 0 (string-contains "ab" "ab"))

;;; The comment below is outdated; the SRFI seems to have
;;; been corrected.
; From: dvanhorn@emba.uvm.edu
; Date: Wed, 26 Mar 2003 08:46:41 +0100
;
; The SRFI document gives,
;
;   string-filter s char/char-set/pred [start end] -> string
;   string-delete s char/char-set/pred [start end] -> string
;
; Yet the reference implementation switches the order giving,
;
;   ;;; string-delete char/char-set/pred string [start end]
;   ;;; string-filter char/char-set/pred string [start end]
;   ...
;   (define (string-delete criterion s . maybe-start+end)
;   ...
;   (define (string-filter criterion s . maybe-start+end)
;
; I reviewed the SRFI-13 mailing list and c.l.scheme, but found no mention of
; this issue.  Apologies if I've missed something.

(test "string=? + string-filter"
      #t
      (call-with-current-continuation
       (lambda (k)
         (with-exception-handler
             (lambda (e) (k #f))
           (lambda () (string=? "ADR" (string-filter char-set:upper-case "abrAcaDabRa")))))))

(test "string=? + string-delete"
      #t
      (call-with-current-continuation
       (lambda (k)
         (with-exception-handler
             (lambda (e) (k #f))
           (lambda () (string=? "abrcaaba" (string-delete char-set:upper-case "abrAcaDabRa")))))))


; http://srfi.schemers.org/srfi-13/post-mail-archive/msg00007.html
; From: David Van Horn <address@hidden>
; Date: Wed, 01 Nov 2006 07:53:34 +0100
;
; Both string-index-right and string-skip-right will continue to search
; left past a given start index.
;
;    (string-index-right "abbb" #\a 1) ;; => 0, but should be #f
;    (string-skip-right  "abbb" #\b 1) ;; => 0, but should be #f
;
; This also causes incorrect results for string-trim-right,
; string-trim-both and string-tokenize when given a non-zero start
; argument.

(test "string-index-right" #f (string-index-right "abbb" #\a 1))
(test "string-skip-right" #f (string-skip-right  "abbb" #\b 1))

;; Tests to check the string-trim-right issue found by Seth Alves
;; http://lists.gnu.org/archive/html/chicken-hackers/2014-01/msg00016.html
(test "string-trim-right" "" (string-trim-right "" char-whitespace? 0 0))
(test "string-trim-right" "" (string-trim-right "a" char-whitespace? 0 0))
(test "string-trim-right" "" (string-trim-right "a " char-whitespace? 0 0))
(test "string-trim-right" "bc" (string-trim-right "abc   " char-whitespace? 1))
(test "string-trim-right" "" (string-trim-right "abc   " char-whitespace? 4 4))


(test "string-trim empty"    "" (string-trim ""))
(test "string-trim nonempty" "abc" (string-trim " abc"))
(test "string-trim no-trimming" "abc" (string-trim "abc"))

;; FIXME: R7RS and SRFI-13 conflict. But when STklos run tests, it will run this
;; file, load the SRFI-13 string-map, shadowing the R7RS one, and fail the R7RS tests later.
;; The following is an ugly hack to  at least let the R7RS tests use the original
;; string-map procedure, but there should be a better way... -- jpellegrini
(set! string-map r7rs:string-map)


;; ;; ----------------------------------------------------------------------
;; ;;  SRFI 37 ...
;; ;; ----------------------------------------------------------------------
(test-subsection "SRFI 37 - args-fold: a program argument processor")

(require "srfi-37")

;; tests from Guile
;; Copyright (C) 2007, 2008, 2013 Free Software Foundation, Inc.
;; Released under the LGPL.
;; Adapted to STklos by Jeronimo Pellegrini

(test "empty calls with count-modified seeds"
      '(21 42)
      (call-with-values
      (lambda ()
        (args-fold '("1" "3" "4") '()
               (lambda (opt name arg seed seed2)
             (values 1 2))
               (lambda (op seed seed2)
             (values (+ 1 seed) (+ 2 seed2)))
               18 36))
    list))

;; Guile returns '(#t #t "doit" "whatev" #t #t)
;; Chicken, Gauche, SISC, Kawa return '(#t #t "doit" #f #t #t)
;; Guile seems correct.
(test "short opt params"
      '(#t #t "doit" "whatev" #t #t)
      (let ((a-set #f) (b-set #f) (c-val #f) (d-val #f) (no-fail #t) (no-operands #t))
        (args-fold '("-abcdoit" "-ad" "whatev")
           (list (option '(#\a) #f #f
                                 (lambda (opt name arg)
                   (set! a-set #t)
                   (values)))
                 (option '(#\b) #f #f
                                 (lambda (opt name arg)
                   (set! b-set #t)
                   (values)))
                 (option '("cdoit" #\c) #f #t
                     (lambda (opt name arg)
                   (set! c-val arg)
                   (values)))
                 (option '(#\d) #f #t
                     (lambda (opt name arg)
                   (set! d-val arg)
                   (values))))
           (lambda (opt name arg) (set! no-fail #f) (values))
           (lambda (oper) (set! no-operands #f) (values)))
        (list a-set b-set c-val d-val no-fail no-operands)))

(test "single unrecognized long-opt"
      "::fake"
      (args-fold '("--fake" "-i2")
             (list (option '(#\i) #t #f
                       (lambda (opt name arg k) k)))
             (lambda (opt name arg k) (string-append "::" name))
             (lambda (operand k) #f)
             #f))

(test "long req'd/optional"
      '(#f "bsquare" "apple")
      (args-fold '("--x=pple" "--y=square" "--y")
             (list (option '("x") #t #f
                       (lambda (opt name arg k)
                     (cons (string-append "a" arg) k)))
                   (option '("y") #f #t
                       (lambda (opt name arg k)
                     (cons (if arg
                           (string-append "b" arg)
                           #f) k))))
             (lambda (opt name arg k) #f)
             (lambda (opt name arg k) #f)
             '()))

;; this matches behavior of getopt_long in libc 2.4
(test "short options absorb special markers in the next arg"
      '((#\y . "-z") (#\x . "--") (#\z . #f))
      (let ((arg-proc (lambda (opt name arg k)
                    (cons (cons  name arg ) k))))
        (args-fold '("-zx" "--" "-y" "-z" "--")
               (list (option '(#\x) #f #t arg-proc)
                 (option '(#\z) #f #f arg-proc)
                 (option '(#\y) #t #f arg-proc))
               (lambda (opt name arg k) #f)
               (lambda (opt name arg k) #f)
               '())))

(test "short options without arguments"
      ;; In Guile 1.8.4 and earlier, using short names of argument-less options
      ;; would lead to a stack overflow.
      '((#\x . #f))
      (let ((arg-proc (lambda (opt name arg k)
                    (cons (cons name arg) k))))
        (args-fold '("-x")
               (list (option '(#\x) #f #f arg-proc))
               (lambda (opt name arg k) #f)
               (lambda (opt name arg k) #f)
               '())))

(test "short option with optional argument omitted"
      'good
      ;; This would trigger an infinite loop in Guile up to 2.0.7.
      ;; See <http://bugs.gnu.org/13176>.
      (args-fold '("-I")
                 (list (option '(#\I) #f #t
                               (lambda (opt name arg value)
                                 (and (eqv? name #\I) (not arg)
                                      'good))))
                 (lambda _ (error "unrecognized"))
                 (lambda args #f)
                 #f))

;; Gosh, Chicken, SISC, Kawa return #f,
;; but the Guile tests expect "the-argument", whicih, according to the
;; SRFI, should be the correct value.
(test "short option with optional argument provided"
      "the-argument"
      (args-fold '("-I" "the-argument")
                 (list (option '(#\I) #f #t
                               (lambda (opt name arg result)
                                 (and (eqv? name #\I) arg))))
                 (lambda args (error "unrecognized"))
                 (lambda args #f)
                 #f))


;; ----------------------------------------------------------------------
;;  SRFI 51 ...https://github.com/egallesio/STklos/pulls
;; ----------------------------------------------------------------------
(test-subsection "SRFI 51 - Handling rest list")

(require "srfi-51")


(define rest-list '(x 1))
(define caller values)

(test "rest-values" '(1 2 3)   (let-values (((a b c) ((lambda (. a-b) (rest-values a-b 5)) 1 2 3)))
                                 (list a b c)))

(test "rest-list"            '(x 1)       (receive (a b)  (rest-values rest-list) (list a b)))
(test "rest-list 2"          '(x 1)       (receive (a b)  (rest-values rest-list 2) (list a b)))
(test "caller rest-list"     '(x 1)       (receive (a b)  (rest-values caller rest-list) (list a b)))
(test "caller rest-list -3"  '(x 1)       (receive (a b)  (rest-values caller rest-list -3) (list a b)))
(test "rest-list -"          '(x 1 "str") (receive (a b c) (rest-values rest-list - 'y 100 "str") (list a b c)))
(test "rest-list +"          '(x 1 "str") (receive (a b c) (rest-values rest-list + `(x y z) `(100 . ,number?) `("str" . ,string?)) (list a b c)))
(test "rest-list #t"         '(x 1 "str") (receive (a b c) (rest-values rest-list #t `(x y z) `(100 . ,number?) `("str" . ,string?)) (list a b c)))
(test "rest-list #t"         '(1 "str" x) (receive (a b c) (rest-values rest-list #t `(100 . ,number?) `("str" . ,string?) `(x y z)) (list a b c)))
(test "rest-list #f"         '(1 "str" y x) (receive (a b c d) (rest-values rest-list #f `(100 . ,number?) `("str" . ,string?) `(y z)) (list a b c d)))


;; ----------------------------------------------------------------------
;;  SRFI 54 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 54 - Formatting")

(require "srfi-9")  ;; some tests use records
(require "srfi-13") ;; one test uses string-reverse
(require "srfi-14") ;; two tests use charsets
(require "srfi-26") ;; two tests use cut...

(require "srfi-54")

(define-macro (mute-cat expr)
  `(let ((res #f))
     (with-output-to-string (lambda () (set! res ,expr)))
     res))


(test "align left" "130.00    " (cat 129.995 -10 2.))
(test "align right, I" "    130.00" (cat 129.995 10 2.))
(test "align right, II" "    129.98" (cat 129.985 10 2.))
(test "align right, III" "    129.99" (cat 129.985001 10 2.))
(test "exact" "#e130.00"   (cat 129.995 2. 'exact))
(test "decimal places" "129.00"     (cat 129 -2.))
(test "exact, II"  "#e129.00"  (cat 129 2.))
(test "exact w/sign, I" "#e+0129.00" (cat 129 10 2. #\0 'sign))
(test "exact w/sign, II" "*#e+129.00" (cat 129 10 2. #\* 'sign))
(test "rational" "1/3" (cat 1/3))
(test "exact, III" "    #e0.33" (cat 1/3 10 2.))
(test "rational floating point" "      0.33" (cat 1/3 10 -2.))
(test "commas" " 1,29.99,5" (cat 129.995 10 '(#\, 2)))
(test "commas w/sign" "  +129,995" (cat 129995 10 '(#\,) 'sign))
(test "round" "130" (cat (cat 129.995 0.) '(0 -1)))
(test "octal" "#i#o+307/2" (cat 99.5 10 'sign 'octal))
(test "exact octal" "  #o+307/2" (cat 99.5 10 'sign 'octal 'exact))
(test "octal w/sign" "#o+443" (cat #x123 'octal 'sign))
(test "exact w/sign, III" "#e+291.00*" (cat #x123 -10 2. 'sign #\*))

;; changed "e15" to "e+15" in the following test, since this is how STklos
;; writes
(test "complex" "-1.234e+15+1.236e-15i" (cat -1.2345e+15+1.2355e-15i 3.))
;; Same for this, but also fixed it so the length includes the leading space
;; (was 10, changed to 11)
(test "exact w/sign, IV" " +1.234e+15" (cat 1.2345e+15 11 3. 'sign))

(test "string -10" "string    " (cat "string" -10))
(test "string upcase" "    STRING" (cat "string" 10 (list string-upcase)))
(test "string upcase -2" "      RING" (cat "string" 10 (list string-upcase) '(-2)))
(test "string titlecase" "     Sting" (cat "string" 10 `(,string-titlecase) '(2 3)))
(test "string reverse upcase" "GNIRTS" (cat "string" `(,string-reverse ,string-upcase)))
(test "char" "         a" (cat #\a 10))
(test "symbol" "    symbol" (cat 'symbol 10))
(test "vector" "#(#\\a \"str\" s)" (cat '#(#\a "str" s)))
(test "list" "(#\\a \"str\" s)" (cat '(#\a "str" s)))


;; Tests with output changed to ignore the string printed below.
;; They're not to useful as this, but will at least detect crashes.

;; (test "" (#\a "str" s)"(#\\a \"str\" s)" (cat '(#\a "str" s) #t))
(test "output I" "(#\\a \"str\" s)" (mute-cat (cat '(#\a "str" s) #t)))

;;(test "" (#\a "str" s)"(#\\a \"str\" s)" (cat '(#\a "str" s) (current-output-port)))
(test "output II" "(#\\a \"str\" s)" (mute-cat (cat '(#\a "str" s) (current-output-port))))

;; original ok:
(test "output III" "3s \"str\"" (mute-cat (cat 3 (cat 's) " " (cat "str" write))))

;;(test "" 3s "str""3s \"str\"" (cat 3 #t (cat 's) " " (cat "str" write)))
(test "output IV" "3s \"str\"" (mute-cat (cat 3 #t (cat 's) " " (cat "str" write))))

;;(test "" s3s "str""3s \"str\"" (cat 3 #t (cat 's #t) " " (cat "str" write)))
(test "output V" "3s \"str\"" (mute-cat (cat 3 #t (cat 's #t) " " (cat "str" write))))


;; records!
(define-record-type :example
    (make-example num str)
    example?
    (num get-num set-num!)
    (str get-str set-str!))

(define ex (make-example 123 "string"))

(define (record->string object)
  (cat (get-num object) "-" (get-str object)))

(define (record-writer object string-port)
    (if (example? object)
    (begin (display (get-num object) string-port)
           (display "-" string-port)
           (display (get-str object) string-port))
    ((or (and (or (string? object)
              (char? object)
              (boolean? object))
          display)
         write) object string-port)))

;; STklos includes a unique identifier in the object description,
;;
;; stklos> ex
;; #[struct example 140336922587072]
;;
;; so we neex to adapt these tests
;;(test "ex" '#{:example} ex)
;;(test "#{:example}" (cat ex))

(test "ex"     #t (example? ex))
(test "cat ex" "#[struct example " (substring (cat ex) 0 17))

(test "record-writer" "          123-string" (cat ex 20 record-writer))

;; I don't know why this test doesn't work. It fails with the
;; following:
;; string-filter: bad string #[<char-set> 7fba1cc7b0f0]
;;
;; * Larceny seems to not include this (they have a different
;; test set for this SRFI);
;; * Racket passes this, but fails the other test that uses cut
;;
;; Maybe we should leave this commented out for now.
;;
;; (test ""
;;       "--------------GNIRTS"
;;       (cat ex 20 record-writer
;;            `(,(cut string-delete char-set:digit <>)
;;              ,string-upcase ,string-reverse)
;;            '(0 -1) #\-))

(test "record-writer/string-upcase"
      "---------------STING"
      (cat "string" 20 record-writer (list string-upcase) '(2 3) #\-))
(test "record-writer/fpoint"
      "            #e12.000"
      (cat 12 20 record-writer 3.))
(test "record->string"
      "          123-string"
      (cat ex 20 (cons example? record->string)))

(test ""
      "----------123-string"
      (cat ex 20 (cons example? record->string)
           `(,(cut string-delete char-set:digit <>)
             ,string-upcase ,string-reverse)
           '(0 -1) #\-))

(test "record->string/string-upcase"
      "---------------STING"
      (cat "string" 20 (cons example? record->string)  (list string-upcase) '(2 3) #\-))
(test "record->string/fpoint"
       "              12.000"
       (cat 12 20 (cons example? record->string) -3.))



;; ----------------------------------------------------------------------
;;  SRFI 60 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 60 - Integers as Bits")

(require "srfi-60")
(test "logand" "1000" (number->string (logand #b1100 #b1010) 2))
(test "logior" "1110" (number->string (logior #b1100 #b1010) 2))
(test "logxor" "110"  (number->string (logxor #b1100 #b1010) 2))
(test "lognot.1" "-10000001" (number->string (lognot #b10000000) 2))
(test "lognot.2" "-1" (number->string (lognot #b0) 2))
(test "logtest.1" #f (logtest #b0100 #b1011))
(test "logtest.1" #t (logtest #b0100 #b0111))
(test "logcount.1" 4 (logcount #b10101010))
(test "logcount.2" 0 (logcount 0))
(test "logcount.3" 1 (logcount -2))
(test "integer-length.1" 8 (integer-length #b10101010))
(test "integer-length.2" 0 (integer-length 0))
(test "integer-length.2" 4 (integer-length #b1111))
(test "log2-binary-factors"
      '((-1 . -1) (0 . 0) (1 . 1) (0 . 0) (2 . 2) (0 . 0)
        (1 . 1) (0 . 0) (3 . 3) (0 . 0) (1 . 1) (0 . 0)
        (2 . 2) (0 . 0) (1 . 1) (0 . 0) (4 . 4))
      (let ((res '()))
        (do ((idx 0 (+ 1 idx)))
            ((> idx 16))
          (set! res (cons (cons (log2-binary-factors (- idx))
                                (log2-binary-factors (+ idx)))
                          res)))
        (reverse res)))
(test "logbit?.1" #t (logbit? 0 #b1101))
(test "logbit?.2" #f (logbit? 1 #b1101))
(test "logbit?.3" #t (logbit? 2 #b1101))
(test "logbit?.4" #t (logbit? 3 #b1101))
(test "logbit?.5" #f (logbit? 4 #b1101))
(test "copybit.1" "1"   (number->string (copy-bit 0 0 #t) 2))
(test "copybit.2" "100" (number->string (copy-bit 2 0 #t) 2))
(test "copybit.3" "1011" (number->string (copy-bit 2 #b1111 #f) 2))
(test "bit-field.1" "1010" (number->string (bit-field #b1101101010 0 4) 2))
(test "bit-field.2" "10110" (number->string (bit-field #b1101101010 4 9) 2))
(test "copy-bit-field.1" "1101100000"
      (number->string (copy-bit-field #b1101101010 0 0 4) 2))
(test "copy-bit-field.2" "1101101111"
      (number->string (copy-bit-field #b1101101010 -1 0 4) 2))
(test "copy-bit-field.3" "110100111110000"
      (number->string (copy-bit-field #b110100100010000 -1 5 9) 2))
(test "ash.1" "1000" (number->string (ash #b1 3) 2))
(test "ash.2" "101" (number->string (ash #b1010 -1) 2))
(test "rotate-bit-field.1"  "10"
      (number->string (rotate-bit-field #b0100 3 0 4) 2))
(test "rotate-bit-field.2" "110100010010000"
      (number->string (rotate-bit-field #b110100100010000 -1 5 9) 2))
(test "rotate-bit-field.3" "110100000110000"
      (number->string (rotate-bit-field #b110100100010000 1 5 9) 2))
(test  "reverse-bit-field" "e5"
       (number->string (reverse-bit-field #xa7 0 8) 16))
(test "integer->list.1" '(#t #t #t #f #t) (integer->list #b11101))
(test "integer->list.2" '(#f #f #f #f #f #t #t #t #f #t) (integer->list #b11101 10))
(test "list->integer"   #b11101 (list->integer '(#f #f #f #f #f #t #t #t #f #t)))
(test "booleans->integer"  #b11101
      (booleans->integer #f #f #f #f #f #t #t #t #f #t))

;; ----------------------------------------------------------------------
;;  SRFI 61 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 61 - A more general cond clause")

(require "srfi-61")

(define (get-nat) 10)
(define (get-sym) 'x)
(define (get-bool) #t)
(define (get-false) #f)

(test "basic 4-element => clause, succeeds"
      -10
      (cond ((get-nat) integer? => (lambda (x) (- x)))
            ((get-sym) 'y)))

(test "basic 4-element => clause, fails"
      'y
      (cond ((get-nat) negative? => (lambda (x) (- x)))
            ((get-sym) 'y)))

(test "mixed 4-element and 3-element => clauses, fails 4-element, succeeds 3-element clause"
      "x"
      (cond ((get-nat) string? => (lambda (x) (- x)))
            ((get-sym) => symbol->string)))

(test "mixed 4-element and 3-element => clauses, fails 3-element, succeeds 4-element clause"
      -10
      (cond   ((get-false) => not)
              ((get-nat) positive? => -)
              ((get-bool) 'no)))

(test "mixed 4-element and 3-element => clauses, fails both"
      'last
      (cond   ((get-false) => not)
              ((get-nat) boolean? => not)
              ((get-sym) 'last)))

(test/error "no 5-element => clause"
            (cond ((get-nat) integer? => (lambda (x) (- x)) 'extraneous)
                  ((get-sym) 'y)))

;; ----------------------------------------------------------------------
;;  SRFI 62 ...
;; ----------------------------------------------------------------------

;; Tests have been moved to the end since test 62.5 breaks emacs
;; fonctifiation unil EOF

;; ----------------------------------------------------------------------
;;  SRFI 64 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 64 - A Scheme API for test suites")

(require "srfi-64")

(load "test-srfi-64.stk")

;; ----------------------------------------------------------------------
;;  SRFI 71 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 70 - Numbers")

(test "complex?" #t (complex? +inf.0))
(test "real?" #t (real? -inf.0))
(test "rational?" #f (rational? +inf.0))
(test "integer?" #f (integer? -inf.0))

(test "inexact?" #t (inexact? +inf.0))

(test "=.1" #t (= +inf.0 +inf.0))
(test "=.2" #f (= -inf.0 +inf.0))
(test "=.3" #t (= -inf.0 -inf.0))

(test "positive?" #t (positive? +inf.0))
(test "negative?" #t (negative? -inf.0))
(test "finite?" #f (finite? -inf.0))
(test "infinite?" #t (infinite? +inf.0))

(test "max.1" +inf.0 (max 12 +inf.0))
(test "max.2" +inf.0 (max 12.0 +inf.0))
(test "max.3" +inf.0 (max -inf.0 +inf.0))
(test "min.1" -inf.0 (min 12 -inf.0))
(test "min.2" -inf.0 (min 12.0 -inf.0))
(test "min.3" -inf.0 (min -inf.0 +inf.0))

(test "+.1" +inf.0 (+ +inf.0 +inf.0))
(test "+.2" +nan.0 (+ +inf.0 -inf.0))

(test "*.1" +inf.0 (* 5 +inf.0))
(test "*.2" -inf.0 (* -5 +inf.0))
(test "*.3" +inf.0 (* +inf.0 +inf.0))
(test "*.4" -inf.0 (* +inf.0 -inf.0))
(test "*.5" +nan.0 (* 0 +inf.0))

(test "-" +nan.0 (- +inf.0 +inf.0))


(test "/.1" +inf.0 (/ 0.0))
(test "/.2" +inf.0 (/ 1.0 0))
(test "/.3" -inf.0 (/ -1 0.0))
(test "/.4" +nan.0 (/ 0 0.0))
(test "/.5" +nan.0 (/ 0.0 0))
(test "/.6" +nan.0 (/ 0.0 0.0))

(test "angle.1" #t (< (- (* 4 (atan 1))
             (angle -inf.0))
              0.00001))
(test "angle.2" 0.0 (angle +inf.0))

(test "string->number.1" +inf.0 (string->number "+inf.0"))
(test "string->number.2" -inf.0 (string->number "-inf.0"))
(test "number->string.1" "+inf.0" (number->string +inf.0))
(test "number->string.2" "-inf.0" (number->string -inf.0))

;; ----------------------------------------------------------------------
;;  SRFI 74 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 74 - BLOBs")

(require "srfi-74")

(define b1 (make-blob 16))

(test "blob-length" 16 (blob-length b1))

(blob-u8-set! b1 0 223)
(blob-s8-set! b1 1 123)
(blob-s8-set! b1 2 -123)
(blob-u8-set! b1 3 15)

(test "blob repr"
      '(223 123 123 -123 133 15)
      (list (blob-u8-ref b1 0)
        (blob-s8-ref b1 1)
        (blob-u8-ref b1 1)
        (blob-s8-ref b1 2)
        (blob-u8-ref b1 2)
        (blob-u8-ref b1 3)))

(blob-uint-set! 16 (endianness little) b1 0 (- (expt 2 128) 3))
(test "blob-uint-ref.1"
      (- (expt 2 128) 3)
      (blob-uint-ref 16 (endianness little) b1 0))
(test "blob-uint-ref.2"
      -3
      (blob-sint-ref 16 (endianness little) b1 0))

(test "blob->u8-list"
      '(253 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255)
      (blob->u8-list b1))

(blob-uint-set! 16 (endianness big) b1 0 (- (expt 2 128) 3))

(test "blob-uint-ref.3"
      (- (expt 2 128) 3)
      (blob-uint-ref 16 (endianness big) b1 0))

(test "blob-sint-ref"
      -3
      (blob-sint-ref 16 (endianness big) b1 0))

(test "blob->u8-list"
      '(255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 253)
      (blob->u8-list b1))

(test "blob-u16-ref"
      65023
      (blob-u16-ref (endianness little) b1 14))

(test "blob-s16-ref"
      -513
      (blob-s16-ref (endianness little) b1 14))

(test "blob-u16-ref"
      65533
      (blob-u16-ref (endianness big) b1 14))

(test "blob-s16-ref"
      -3
      (blob-s16-ref (endianness big) b1 14))


(blob-u16-set! (endianness little) b1 0 12345)
(blob-u16-native-set! b1 0 12345)

(test "blob-u16-native-ref"
      12345
      (blob-u16-native-ref b1 0))

(test "blob-u32-ref"
      4261412863
      (blob-u32-ref (endianness little) b1 12))
(test "blob-s32-ref"
      -33554433
      (blob-s32-ref (endianness little) b1 12))

(test "blob-u32-ref"
      4294967293
      (blob-u32-ref (endianness big) b1 12))
(test "blob-s32-ref"
      -3
      (blob-s32-ref(endianness big) b1 12))

(blob-u32-set! (endianness little) b1 0 12345)
(blob-u32-native-set! b1 0 12345)

(test "blob-u32-native-ref"
      12345
      (blob-u32-native-ref b1 0))
(test "blob-u64-ref"
      18302628885633695743
       (blob-u64-ref (endianness little) b1 8))
(test "(blob-s64-ref (endianness little) b1 8)"
      -144115188075855873
      (blob-s64-ref (endianness little) b1 8))
(test "(blob-u64-ref (endianness big) b1 8)"
      18446744073709551613
      (blob-u64-ref (endianness big) b1 8))
(test "(blob-s64-ref (endianness big) b1 8)"
      -3
      (blob-s64-ref (endianness big) b1 8))

(blob-u64-set! (endianness little) b1 0 12345)
(blob-u64-native-set! b1 0 12345)

(test "(blob-u64-native-ref b1 0)"
      12345
      (blob-u64-native-ref b1 0))

(define b2 (u8-list->blob '(1 2 3 4 5 6 7 8)))
(define b3 (blob-copy b2))

(test "(blob=? b2 b3)"
      #t
      (blob=? b2 b3))
(test "(blob=? b1 b2)"
      #f
      (blob=? b1 b2))

(blob-copy! b3 0 b3 4 4)
(test "(blob->u8-list b3)"
      '(1 2 3 4 1 2 3 4)
      (blob->u8-list b3))

(blob-copy! b3 0 b3 2 6)
(test "(blob->u8-list b3)"
      '(1 2 1 2 3 4 1 2)
      (blob->u8-list b3))

(blob-copy! b3 2 b3 0 6)
(test "(blob->u8-list b3)"
      '(1 2 3 4 1 2 1 2)
      (blob->u8-list b3))
(test "(blob->uint-list 1 (endianness little) b3)"
      '(1 2 3 4 1 2 1 2)
      (blob->uint-list 1 (endianness little) b3))
(test "(blob->uint-list 2 (endianness little) b3)"
      '(513 1027 513 513)
      (blob->uint-list 2 (endianness little) b3))

(define b4 (u8-list->blob '(0 0 0 0 0 0 48 57 255 255 255 255 255 255 255 253)))

(test "(blob->sint-list 2 (endianness little) b4)"
      '(0 0 0 14640 -1 -1 -1 -513)
      (blob->sint-list 2 (endianness little) b4))


;; ----------------------------------------------------------------------
;;  SRFI 87 and R7RS ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 87 - => in case clauses")

(test "=> else symbol" 'none (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else => (lambda (x) 'none))))
(test "=> choose non-procedure" *test-failed* (case 10 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else 'none)))
(test "=> don't choose non-procedure" 'none (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else 'none)))
(test "=> don't choose non-procedure, II"  -20 (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else => (lambda (x) (- x)))))
(test "=> else number" 60 (case 20 ((5) 'five) ((10) 'ten) ((15) 'fifteen) (else =>  (lambda (x) (* x 3)))))
(test "=> else -" -20 (case 20 ((5) 'five) ((10) 'ten) ((15) 'fifteen) (else =>  -)))
(test "=> only"  #\z (case #\Z ((#\a) => char-upcase)
                               ((#\c) => (lambda (x) (string x #\d)))
                               ((#\z) => char->integer)
                               ((#\Z) => char-downcase)
                               (else => #f)))

;; ----------------------------------------------------------------------
;;  SRFI 151 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 151 - Bitwise Operations")

(require "srfi-151")

;;bitwise/basic
(test "test-1" -1 (bitwise-not 0))
(test "test-122" 0 (bitwise-not -1))
(test "test-248" -11 (bitwise-not 10))
(test "test-249" 36 (bitwise-not -37))
(test "test-2" 0 (bitwise-and #b0 #b1))
(test "test-10" 1680869008 (bitwise-and -193073517 1689392892))
(test "test-20" 3769478 (bitwise-and 1694076839 -4290775858))
(test "test-115" 6 (bitwise-and 14 6))
(test "test-251" 10 (bitwise-and 11 26))
(test "test-254" 4 (bitwise-and 37 12))
(test "test-288" 1 (bitwise-and #b1 #b1))
(test "test-289" 0 (bitwise-and #b1 #b10))
(test "test-290" #b10 (bitwise-and #b11 #b10))
(test "test-291" #b101 (bitwise-and #b101 #b111))
(test "test-292" #b111 (bitwise-and -1 #b111))
(test "test-293" #b110 (bitwise-and -2 #b111))
(test "test-294" 3769478 (bitwise-and -4290775858 1694076839))
(test "test-11" -4294967295 (bitwise-ior 1 (- -1 #xffffffff)))
(test "test-12" -18446744073709551615 (bitwise-ior 1 (- -1 #xffffffffffffffff)))
(test "test-117" 14 (bitwise-ior 10 12))
(test "test-250" 11 (bitwise-ior 3  10))
(test "test-13" -4294967126 (bitwise-xor #b10101010 (- -1 #xffffffff)))
(test "test-15" -18446744073709551446 (bitwise-xor #b10101010 (- -1 #xffffffffffffffff)))
(test "test-16" -2600468497 (bitwise-ior 1694076839 -4290775858))
(test "test-17" -184549633 (bitwise-ior -193073517 1689392892))
(test "test-18" -2604237975 (bitwise-xor 1694076839 -4290775858))
(test "test-19" -1865418641 (bitwise-xor -193073517 1689392892))
(test "test-119" 6 (bitwise-xor 10 12))
(test "test-252" 9 (bitwise-xor 3 10))
(test "test-14" (bitwise-not -4294967126) (bitwise-eqv #b10101010 (- -1 #xffffffff)))
(test "test-253" -42 (bitwise-eqv 37 12))
(test "test-27" -1 (bitwise-nand 0 0))
(test "test-28" -1 (bitwise-nand 0 -1))
(test "test-29" -124 (bitwise-nand -1 123))
(test "test-326" -11 (bitwise-nand 11 26))
(test "test-327" -28 (bitwise-nor  11 26))
(test "test-317" 0 (bitwise-nor -1 123))
(test "test-328" 16 (bitwise-andc1 11 26))
(test "test-329" 1 (bitwise-andc2 11 26))
(test "test-330" -2 (bitwise-orc1 11 26))
(test "test-30" -1 (bitwise-nor 0 0))
(test "test-31" 0 (bitwise-nor 0 -1))
(test "test-22" 0 (bitwise-andc1 0 0))
(test "test-23" -1 (bitwise-andc1 0 -1))
(test "test-24" 123 (bitwise-andc1 0 123))
(test "test-25" 0 (bitwise-andc2 0 0))
(test "test-26" -1 (bitwise-andc2 -1 0))
(test "test-318" -1 (bitwise-orc1 0 0))
(test "test-319" -1 (bitwise-orc1 0 -1))
(test "test-320" 0 (bitwise-orc1 -1 0))
(test "test-321" -124 (bitwise-orc1 123 0))
(test "test-322" -1 (bitwise-orc2 0 0))
(test "test-323" -1 (bitwise-orc2 -1 0))
(test "test-324" 0 (bitwise-orc2 0 -1))
(test "test-325" -124 (bitwise-orc2 0 123))


;;bitwise/integer
(test "test-78" #x1000000000000000100000000000000000000000000000000
      (arithmetic-shift #x100000000000000010000000000000000 64))
(test "test-79" #x8e73b0f7da0e6452c810f32b809079e5
      (arithmetic-shift #x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b -64))
(test "test-196" 2 (arithmetic-shift 1 1))
(test "test-197" 0 (arithmetic-shift 1 -1))
(test "test-331" 1 (arithmetic-shift 1 0))
(test "test-333" 4 (arithmetic-shift 1 2))
(test "test-334" 8 (arithmetic-shift 1 3))
(test "test-335" 16 (arithmetic-shift 1 4))
(test "test-336" (expt 2 31) (arithmetic-shift 1 31))
(test "test-337" (expt 2 32) (arithmetic-shift 1 32))
(test "test-338" (expt 2 33) (arithmetic-shift 1 33))
(test "test-339" (expt 2 63) (arithmetic-shift 1 63))
(test "test-340" (expt 2 64) (arithmetic-shift 1 64))
(test "test-341" (expt 2 65) (arithmetic-shift 1 65))
(test "test-342" (expt 2 127) (arithmetic-shift 1 127))
(test "test-343" (expt 2 128) (arithmetic-shift 1 128))
(test "test-344" (expt 2 129) (arithmetic-shift 1 129))
(test "test-345" 3028397001194014464 (arithmetic-shift 11829675785914119 8))
(test "test-346" -1 (arithmetic-shift -1 0))
(test "test-347" -2 (arithmetic-shift -1 1))
(test "test-348" -4 (arithmetic-shift -1 2))
(test "test-349" -8 (arithmetic-shift -1 3))
(test "test-350" -16 (arithmetic-shift -1 4))
(test "test-351" (- (expt 2 31)) (arithmetic-shift -1 31))
(test "test-352" (- (expt 2 32)) (arithmetic-shift -1 32))
(test "test-353" (- (expt 2 33)) (arithmetic-shift -1 33))
(test "test-354" (- (expt 2 63)) (arithmetic-shift -1 63))
(test "test-355" (- (expt 2 64)) (arithmetic-shift -1 64))
(test "test-356" (- (expt 2 65)) (arithmetic-shift -1 65))
(test "test-357" (- (expt 2 127)) (arithmetic-shift -1 127))
(test "test-358" (- (expt 2 128)) (arithmetic-shift -1 128))
(test "test-359" (- (expt 2 129)) (arithmetic-shift -1 129))
(test "test-360" 0 (arithmetic-shift 1 -63))
(test "test-361" 0 (arithmetic-shift 1 -64))
(test "test-362" 0 (arithmetic-shift 1 -65))
(test "test-255" 32 (arithmetic-shift 8 2))
(test "test-256" 4 (arithmetic-shift 4 0))
(test "test-257" 4 (arithmetic-shift 8 -1))
(test "test-258" -79 (arithmetic-shift -100000000000000000000000000000000 -100))
(test "test-135" 2 (bit-count 12))
(test "test-263" 0 (integer-length  0))
(test "test-264" 1 (integer-length  1))
(test "test-265" 0 (integer-length -1))
(test "test-266" 3 (integer-length  7))
(test "test-267" 3 (integer-length -7))
(test "test-268" 4 (integer-length  8))
(test "test-269" 3 (integer-length -8))
(test "test-125" 9 (bitwise-if 3 1 8))
(test "test-126" 0 (bitwise-if 3 8 1))
(test "test-373" 3 (bitwise-if 1 1 2))
(test "test-378" #b00110011 (bitwise-if #b00111100 #b11110000 #b00001111))

;;bitwise/single
(test "test-160" #t (bit-set? 0 1))
(test "test-161" #f (bit-set? 1 1))
(test "test-162" #f (bit-set? 1 8))
(test "test-163" #t (bit-set? 10000 -1))
(test "test-167" #t (bit-set? 1000 -1))
(test "test-541" #t (bit-set? 64 #x10000000000000000))
(test "test-542" #f (bit-set? 64 1))
(test "test-272" #t (bit-set? 3 10))
(test "test-273" #t (bit-set? 2 6))
(test "test-274" #f (bit-set? 0 6))
(test "test-168" 0 (copy-bit 0 0 #f))
(test "test-169" 0 (copy-bit 30 0 #f))
(test "test-170" 0 (copy-bit 31 0 #f))
(test "test-171" 0 (copy-bit 62 0 #f))
(test "test-172" 0 (copy-bit 63 0 #f))
(test "test-173" 0 (copy-bit 128 0 #f))
(test "test-174" -1 (copy-bit 0 -1 #t))
(test "test-175" -1 (copy-bit 30 -1 #t))
(test "test-176" -1 (copy-bit 31 -1 #t))
(test "test-177" -1 (copy-bit 62 -1 #t))
(test "test-178" -1 (copy-bit 63 -1 #t))
(test "test-179" -1 (copy-bit 128 -1 #t))
(test "test-180" 1 (copy-bit 0 0 #t))
(test "test-181" #x106 (copy-bit 8 6 #t))
(test "test-182" 6 (copy-bit 8 6 #f))
(test "test-183" -2 (copy-bit 0 -1 #f))
(test "test-184" 0 (copy-bit 128 #x100000000000000000000000000000000 #f))
(test "test-185" #x100000000000000000000000000000000
         (copy-bit 128 #x100000000000000000000000000000000 #t))
(test "test-186" #x100000000000000000000000000000000
         (copy-bit 64 #x100000000000000000000000000000000 #f))
(test "test-187" #x-100000000000000000000000000000000
         (copy-bit 64 #x-100000000000000000000000000000000 #f))
(test "test-188" #x-100000000000000000000000000000000
         (copy-bit 256 #x-100000000000000000000000000000000 #t))
(test "test-276" #b100 (copy-bit 2 0 #t))
(test "test-277" #b1011 (copy-bit 2 #b1111 #f))
(test "test-379" #b1 (copy-bit 0 0 #t))
(test "test-100" #b1011 (bit-swap 1 2 #b1101))
(test "test-101" #b1011 (bit-swap 2 1 #b1101))
(test "test-382" #b1110 (bit-swap 0 1 #b1101))
(test "test-102" #b10000000101 (bit-swap 3 10 #b1101))
(test "test-278" 1 (bit-swap 0 2 4))
(test "test-129" #t (any-bit-set? 3 6))
(test "test-130" #f (any-bit-set? 3 12))
(test "test-133" #t (every-bit-set? 4 6))
(test "test-134" #f (every-bit-set? 7 6))
(test "test-141" -1 (first-set-bit 0))
(test "test-142" 0 (first-set-bit 1))
(test "test-143" 0 (first-set-bit 3))
(test "test-144" 2 (first-set-bit 4))
(test "test-145" 1 (first-set-bit 6))
(test "test-146" 0 (first-set-bit -1))
(test "test-147" 1 (first-set-bit -2))
(test "test-148" 0 (first-set-bit -3))
(test "test-149" 2 (first-set-bit -4))
(test "test-150" 128 (first-set-bit #x100000000000000000000000000000000))
(test "test-280" 1 (first-set-bit 2))
(test "test-282" 3 (first-set-bit 40))
(test "test-283" 2 (first-set-bit -28))
(test "test-284" 99 (first-set-bit (expt  2 99)))
(test "test-285" 99 (first-set-bit (expt -2 99)))

;; bitwise/field
(test "test-189" 0 (bit-field 6 0 1))
(test "test-190" 3 (bit-field 6 1 3))
(test "test-191" 1 (bit-field 6 2 999))
(test "test-192" 1 (bit-field #x100000000000000000000000000000000 128 129))
(test "test-363" #b1010 (bit-field #b1101101010 0 4))
(test "test-364" #b101101 (bit-field #b1101101010 3 9))
(test "test-365" #b10110 (bit-field #b1101101010 4 9))
(test "test-366" #b110110 (bit-field #b1101101010 4 10))
(test "test-367" #t (bit-field-any? #b101101 0 2))
(test "test-368" #t (bit-field-any? #b101101 2 4))
(test "test-369" #f (bit-field-any? #b101101 1 2))
(test "test-370" #f (bit-field-every? #b101101 0 2))
(test "test-371" #t (bit-field-every? #b101101 2 4))
(test "test-372" #t (bit-field-every? #b101101 0 1))
(test "test-374" #b100000 (bit-field-clear #b101010 1 4))
(test "test-375" #b101110 (bit-field-set #b101010 1 4))
(test "test-193" #b111 (bit-field-replace #b110 1 0 1))
(test "test-194" #b110 (bit-field-replace #b110 1 1 2))
(test "test-195" #b010 (bit-field-replace #b110 1 1 3))
(test "test-376" #b100100 (bit-field-replace #b101010 #b010 1 4))
(test "test-377" #b1001 (bit-field-replace-same #b1111 #b0000 1 3))
(test "test-200" #b110  (bit-field-rotate #b110 1 1 2))
(test "test-201" #b1010 (bit-field-rotate #b110 1 2 4))
(test "test-202" #b1011 (bit-field-rotate #b0111 -1 1 4))
(test "test-203" #b0  (bit-field-rotate #b0 128 0 256))
(test "test-204" #b1  (bit-field-rotate #b1 128 1 256))
    (test "test-205" #x100000000000000000000000000000000
        (bit-field-rotate #x100000000000000000000000000000000 128 0 64))
    (test "test-206" #x100000000000000000000000000000008
        (bit-field-rotate #x100000000000000000000000000000001 3 0 64))
    (test "test-207" #x100000000000000002000000000000000
        (bit-field-rotate #x100000000000000000000000000000001 -3 0 64))
(test "test-208" #b110 (bit-field-rotate #b110 0 0 10))
(test "test-209" #b110 (bit-field-rotate #b110 0 0 256))
(test "test-475" 1 (bit-field-rotate #x100000000000000000000000000000000 1 0 129))
(test "test-211" 6 (bit-field-reverse 6 1 3))
(test "test-212" 12 (bit-field-reverse 6 1 4))
(test "test-213" #x80000000 (bit-field-reverse 1 0 32))
(test "test-214" #x40000000 (bit-field-reverse 1 0 31))
(test "test-215" #x20000000 (bit-field-reverse 1 0 30))
(test "test-216" (bitwise-ior (arithmetic-shift -1 32) #xFBFFFFFF)
         (bit-field-reverse -2 0 27))
(test "test-217" (bitwise-ior (arithmetic-shift -1 32) #xF7FFFFFF)
         (bit-field-reverse -2 0 28))
(test "test-218" (bitwise-ior (arithmetic-shift -1 32) #xEFFFFFFF)
         (bit-field-reverse -2 0 29))
(test "test-219" (bitwise-ior (arithmetic-shift -1 32) #xDFFFFFFF)
         (bit-field-reverse -2 0 30))
(test "test-220" (bitwise-ior (arithmetic-shift -1 32) #xBFFFFFFF)
         (bit-field-reverse -2 0 31))
(test "test-221" (bitwise-ior (arithmetic-shift -1 32) #x7FFFFFFF)
         (bit-field-reverse -2 0 32))
(test "test-222" 5 (bit-field-reverse #x140000000000000000000000000000000 0 129))

;; bitwise/conversion
(test "test-103" '(#t #f #t #f #t #t #t) (bits->list #b1110101))
(test "test-104" '(#f #t #f #t) (bits->list #b111010 4))
(test "test-106" #b1110101 (list->bits '(#t #f #t #f #t #t #t)))
(test "test-107" #b111010100 (list->bits '(#f #f #t #f #t #f #t #t #t)))
(test "test-223" '(#t #t) (bits->list 3))
(test "test-224" '(#f #t #t #f) (bits->list 6 4))
(test "test-225" '(#f #t) (bits->list 6 2))
  (test "test-226" '(#t #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
         #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
         #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
         #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
         #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
         #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
         #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
         #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f)
        (bits->list 1 128))
(test "test-228" '(#f
             #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
             #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
             #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
             #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
             #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
             #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
             #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
             #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #t)
           (bits->list #x100000000000000000000000000000000))
(test "test-229" 6 (list->bits '(#f #t #t)))
(test "test-230" 12 (list->bits '(#f #f #t #t)))
(test "test-231" 6 (list->bits '(#f #t #t #f)))
(test "test-232" 2 (list->bits '(#f #t)))
(test "test-233" 1 (list->bits
         '(#t #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
          #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
          #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
          #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
          #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
          #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
          #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
          #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f)))
(test "test-234" #x100000000000000000000000000000000
         (list->bits
          '(#f
            #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
            #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
            #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
            #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
            #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
            #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
            #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
            #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #t)))
(test "test-235" #x03FFFFFF (list->bits '(#t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t)))
(test "test-236" #x07FFFFFF (list->bits '(#t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t)))
(test "test-237" #x0FFFFFFF (list->bits '(#t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t)))
(test "test-238" #x1FFFFFFF (list->bits '(#t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t)))
(test "test-239" #x3FFFFFFF (list->bits '(#t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t)))
(test "test-240" #x7FFFFFFF (list->bits '(#t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t)))
(test "test-241" #xFFFFFFFF (list->bits '(#t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t
                        #t #t #t #t #t #t #t #t)))
(test "test-242" #x1FFFFFFFF (list->bits '(#t
                          #t #t #t #t #t #t #t #t
                          #t #t #t #t #t #t #t #t
                          #t #t #t #t #t #t #t #t
                          #t #t #t #t #t #t #t #t)))
(test "test-490" 1 (list->bits '(#t #f)))
(test "test-108" #b1110101 (vector->bits '#(#t #f #t #f #t #t #t)))
(test "test-109" #b00011010100 (vector->bits '#(#f #f #t #f #t #f #t #t)))
(test "test-105" '#(#t #t #t #f #t #f #t #f #f) (bits->vector #b1010111 9))
(test "test-105" '#(#t #t #t #f #t #f #t #f #f) (bits->vector #b1010111 9))
(test "test-110" #b1110101 (bits #t #f #t #f #t #t #t))
(test "test-243" 0 (bits))
(test "test-111" #b111010100 (bits #f #f #t #f #t #f #t #t #t))

;; bitwise/fold
(test "test-112" '(#t #f #t #f #t #t #t) (bitwise-fold cons '() #b1010111))
(test "test-113" 5
      (let ((count 0))
        (bitwise-for-each (lambda (b) (if b (set! count (+ count 1))))
                          #b1010111)
        count))
(test "test-114" #b101010101
      (bitwise-unfold (lambda (i) (= i 10)) even? (lambda (i) (+ i 1)) 0))
(let ((g (make-bitwise-generator #b110)))
(test "test-244a" #f (g))
(test "test-244b" #t (g))
(test "test-244c" #t (g))
(test "test-244d" #f (g)))

;; ----------------------------------------------------------------------
;;  SRFI 113 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 113 - Sets and bags")

(require "srfi-113")

;;; Below are some default comparators provided by SRFI-114,
;;; but not SRFI-128, which this SRFI has transitioned to
;;; depend on. See the rationale for SRFI-128 as to why it is
;;; preferred in usage compared to SRFI-114.

;; Most if not all of this code is taken from SRFI-114

(define exact inexact->exact)

(define string-foldcase string-downcase)

(define (make-comparison=/< = <)
  (lambda (a b)
    (cond
      ((= a b) 0)
      ((< a b) -1)
      (else 1))))

;; Comparison procedure for real numbers only
(define (real-comparison a b)
  (cond
    ((< a b) -1)
    ((> a b) 1)
    (else 0)))

;; Comparison procedure for non-real numbers.
(define (complex-comparison a b)
  (let ((real-result (real-comparison (real-part a) (real-part b))))
    (if (= real-result 0)
      (real-comparison (imag-part a) (imag-part b))
      real-result)))

(define (number-hash obj) (exact (abs obj)))

(define number-comparator
  (make-comparator number? = complex-comparison number-hash))

(define char-comparison (make-comparison=/< char=? char<?))

;; not necesary, and interferes with SRFI-128:
;; (define (char-hash obj) (abs (char->integer obj)))

(define char-comparator
  (make-comparator char? char=? char-comparison char-hash))

;; Makes a hash function that works vectorwise
(define limit (expt 2 20))

(define (make-vectorwise-hash hash length ref)
  (lambda (obj)
    (let loop ((index (- (length obj) 1)) (result 5381))
      (if (= index 0)
        result
        (let* ((prod (modulo (* result 33) limit))
               (sum (modulo (+ prod (hash (ref obj index))) limit)))
          (loop (- index 1) sum))))))

;; not necesary, and interferes with SRFI-128:
;; (define string-hash
;;   (make-vectorwise-hash char-hash string-length string-ref))

(define string-comparison (make-comparison=/< string=? string<?))

(define string-ci-comparison (make-comparison=/< string-ci=? string-ci<?))

(define string-comparator
  (make-comparator string? string=? string-comparison string-hash))

(define (string-ci-hash obj) (string-hash (string-foldcase obj)))

(define string-ci-comparator
  (make-comparator string? string-ci=? string-ci-comparison string-ci-hash))

(define eq-comparator
  (make-comparator
    #t
    eq?
    #f
    default-hash))

(define eqv-comparator
  (make-comparator
    #t
    eqv?
    #f
    default-hash))

(define equal-comparator
  (make-comparator
    #t
    equal?
    #f
    default-hash))

;;;
;;; END of srfi-114 piece
;;;


;;; sets/simple

(define (big x) (> x 5))

(define nums (set number-comparator))
;; nums is now {}
(define syms (set eq-comparator 'a 'b 'c 'd))
;; syms is now {a, b, c, d}
(define nums2 (set-copy nums))
;; nums2 is now {}
(define syms2 (set-copy syms))
;; syms2 is now {a, b, c, d}
(define esyms (set eq-comparator))
;; esyms is now {}
(test "test/simple 1" #t (set-empty? esyms))
(define total 0)
(test "test/simple 2" #t (set? nums))
(test "test/simple 3" #t (set? syms))
(test "test/simple 4" #t (set? nums2))
(test "test/simple 5" #t (set? syms2))
(test "test/simple 6" #t (not (set? 'a)))
(set-adjoin! nums 2)
(set-adjoin! nums 3)
(set-adjoin! nums 4)
(set-adjoin! nums 4)
;; nums is now {2, 3, 4}
(test "test/simple 7" 4 (set-size (set-adjoin nums 5)))
(test "test/simple 8" 3 (set-size nums))
(test "test/simple 9" 3 (set-size (set-delete syms 'd)))
(test "test/simple 10" 2 (set-size (set-delete-all syms '(c d))))
(test "test/simple 11" 4 (set-size syms))
(set-adjoin! syms 'e 'f)
;; syms is now {a, b, c, d, e, f}
(test "test/simple 12" 4 (set-size (set-delete-all! syms '(e f))))
;; syms is now {a, b, c, d}
(test "test/simple 13" 0 (set-size nums2))
(test "test/simple 14" 4 (set-size syms2))
(set-delete! nums 2)
;; nums is now {3, 4}
(test "test/simple 15" 2 (set-size nums))
(set-delete! nums 1)
(test "test/simple 16" 2 (set-size nums))
(set! nums2 (set-map number-comparator (lambda (x) (* 10 x)) nums))
;; nums2 is now {30, 40}
(test "test/simple 17" #t (set-contains? nums2 30))
(test "test/simple 18" #t (not (set-contains? nums2 3)))
(set-for-each (lambda (x) (set! total (+ total x))) nums2)
(test "test/simple 19" 70 total)
(test "test/simple 20" 10 (set-fold + 3 nums))
(set! nums (set eqv-comparator 10 20 30 40 50))
;; nums is now {10, 20, 30, 40, 50}
(test "test/simple 21" #t
    (set=? nums (set-unfold
                 (lambda (i) (= i 0))
                 (lambda (i) (* i 10))
                 (lambda (i) (- i 1))
                 5
                 eqv-comparator)))
(test "test/simple 22" '(a) (set->list (set eq-comparator 'a)))
(set! syms2 (list->set eq-comparator '(e f)))
;; syms2 is now {e, f}
(test "test/simple 23" 2  (set-size syms2))
(test "test/simple 24" #t (set-contains? syms2 'e))
(test "test/simple 25" #t (set-contains? syms2 'f))
(list->set! syms2 '(a b))
(test "test/simple 26" 4 (set-size syms2))



;;; sets/search

(define yam (set char-comparator #\y #\a #\m))
(define (failure/insert insert ignore)
  (insert 1))
(define (failure/ignore insert ignore)
  (ignore 2))
(define (success/update element update remove)
  (update #\b 3))
(define (success/remove element update remove)
  (remove 4))
(define yam! (set char-comparator #\y #\a #\m #\!))
(define bam (set char-comparator #\b #\a #\m))
(define ym (set char-comparator #\y #\m))
(define set1 #f)
(define obj1 #f)
(define-values (set1 obj1)
  (set-search! (set-copy yam) #\! failure/insert error))
(test "sets/search 1" #t (set=? yam! set1))
(test "sets/search 2" 1 obj1)
(define-values (set2 obj2)
  (set-search! (set-copy yam) #\! failure/ignore error))
(test "sets/search 3" #t (set=? yam set2))
(test "sets/search 4" 2 obj2)
(define-values (set3 obj3)
  (set-search! (set-copy yam) #\y error success/update))
(test "sets/search 5" #t (set=? bam set3))
(test "sets/search 6" 3 obj3)
(define-values (set4 obj4)
  (set-search! (set-copy yam) #\a error success/remove))
(test "sets/search 7" #t (set=? ym set4))
(test "sets/search 8" 4 obj4)


;;; sets/subsets
  (define set2 (set number-comparator 1 2))
  (define other-set2 (set number-comparator 1 2))
  (define set3 (set number-comparator 1 2 3))
  (define set4 (set number-comparator 1 2 3 4))
  (define sety (set number-comparator 1 2 4 5))
  (define setx (set number-comparator 10 20 30 40))
  (test "sets/subsets 1" #t (set=? set2 other-set2))
  (test "sets/subsets 2" #t (not (set=? set2 set3)))
  (test "sets/subsets 3" #t (not (set=? set2 set3 other-set2)))
  (test "sets/subsets 4" #t (set<? set2 set3 set4))
  (test "sets/subsets 5" #t (not (set<? set2 other-set2)))
  (test "sets/subsets 6" #t (set<=? set2 other-set2 set3))
  (test "sets/subsets 7" #t (not (set<=? set2 set3 other-set2)))
  (test "sets/subsets 8" #t (set>? set4 set3 set2))
  (test "sets/subsets 9" #t (not (set>? set2 other-set2)))
  (test "sets/subsets 10" #t (set>=? set3 other-set2 set2))
  (test "sets/subsets 11" #t (not (set>=? other-set2 set3 set2)))
  (test "sets/subsets 12" #t (not (set<? set2 other-set2)))
  (test "sets/subsets 13" #t (not (set<? set2 setx)))
  (test "sets/subsets 14" #t (not (set<=? set2 setx)))
  (test "sets/subsets 15" #t (not (set>? set2 setx)))
  (test "sets/subsets 16" #t (not (set>=? set2 setx)))
  (test "sets/subsets 17" #t (not (set<?  set3 sety)))
  (test "sets/subsets 18" #t (not (set<=? set3 sety)))
  (test "sets/subsets 19" #t (not (set>?  set3 sety)))
  (test "sets/subsets 20" #t (not (set>=? set3 sety)))

;;; "sets/ops"
  ;; Potentially mutable
  (define abcd (set eq-comparator 'a 'b 'c 'd))
  (define efgh (set eq-comparator 'e 'f 'g 'h))
  (define abgh (set eq-comparator 'a 'b 'g 'h))
  ;; Never get a chance to be mutated
  (define other-abcd (set eq-comparator 'a 'b 'c 'd))
  (define other-efgh (set eq-comparator 'e 'f 'g 'h))
  (define other-abgh (set eq-comparator 'a 'b 'g 'h))
  (define all (set eq-comparator 'a 'b 'c 'd 'e 'f 'g 'h))
  (define none (set eq-comparator))
  (define ab (set eq-comparator 'a 'b))
  (define cd (set eq-comparator 'c 'd))
  (define ef (set eq-comparator 'e 'f))
  (define gh (set eq-comparator 'g 'h))
  (define cdgh (set eq-comparator 'c 'd 'g 'h))
  (define abcdgh (set eq-comparator 'a 'b 'c 'd 'g 'h))
  (define abefgh (set eq-comparator 'a 'b 'e 'f 'g 'h))
  (test "sets/ops 1" #t (set-disjoint? abcd efgh))
  (test "sets/ops 2" #t (not (set-disjoint? abcd ab)))

(define efgh2 #f)
(define abcd2 #f)
(define abcd3 #f)
(define abcd4 #f)

;; ;(parameterize ((current-test-comparator set=?))

(test "sets/ops 3" #t (set=? abcd (set-union abcd)))
(test "sets/ops 4" #t (set=? all (set-union abcd efgh)))
(test "sets/ops 5" #t (set=? abcdgh (set-union abcd abgh)))
(test "sets/ops 6" #t (set=? abefgh (set-union efgh abgh)))
(set! efgh2 (set-copy efgh))
(set-union! efgh2)
(test "sets/ops 7" #t (set=? efgh efgh2))
(set-union! efgh2 abgh)
(test "sets/ops 8" #t (set=? abefgh efgh2))
(test "sets/ops 9" #t (set=? abcd (set-intersection abcd)))
(test "sets/ops 10" #t (set=? none (set-intersection abcd efgh)))
(set! abcd2 (set-copy abcd))
(set-intersection! abcd2)
(test "sets/ops 11" #t (set=? abcd abcd2))
(set-intersection! abcd2 efgh)
(test "sets/ops 12" #t (set=? none abcd2))
(test "sets/ops 13" #t (set=? ab (set-intersection abcd abgh)))
(test "sets/ops 14" #t (set=? ab (set-intersection abgh abcd)))
(test "sets/ops 15" #t (set=? abcd (set-difference abcd)))
(test "sets/ops 16" #t (set=? cd (set-difference abcd ab)))
(test "sets/ops 17" #t (set=? abcd (set-difference abcd gh)))
(test "sets/ops 18" #t (set=? none (set-difference abcd abcd)))
(set! abcd3 (set-copy abcd))
(set-difference! abcd3)
(test "sets/ops 19" #t (set=? abcd abcd3))
(set-difference! abcd3 abcd)
(test "sets/ops 20" #t (set=? none abcd3))
(test "sets/ops 21" #t (set=? cdgh (set-xor abcd abgh)))
(test "sets/ops 22" #t (set=? all (set-xor abcd efgh)))
(test "sets/ops 23" #t (set=? none (set-xor abcd other-abcd)))
(set! abcd4 (set-copy abcd))
;; don't test xor! effect
(test "sets/ops 24" #t (set=? none (set-xor! abcd4 other-abcd)))
(test "sets/ops 25" #t (set=? other-abcd abcd)) ; "abcd smashed?"
(test "sets/ops 26" #t (set=? other-efgh efgh)) ; "efgh smashed?"
(test "sets/ops 27" #t (set=? other-abgh abgh)) ; "abgh smashed?"

;;; STklos test system won't catch syntax error; skip these
;; ;;; "sets/mismatch"
;;   (define nums (set number-comparator 1 2 3))
;;   (define syms (set eq-comparator 'a 'b 'c))
;;   (test/error (set=? nums syms))
;;   (test/error (set<? nums syms))
;;   (test/error (set<=? nums syms))
;;   (test/error (set>? nums syms))
;;   (test/error (set>=? nums syms))
;;   (test/error (set-union nums syms))
;;   (test/error (set-intersection nums syms))
;;   (test/error (set-difference nums syms))
;;   (test/error (set-xor nums syms))
;;   (test/error (set-union! nums syms))
;;   (test/error (set-intersection! nums syms))
;;   (test/error (set-difference! nums syms))
;;   (test/error (set-xor! nums syms))


;; ;;; "sets/whole"
  (define whole (set eqv-comparator 1 2 3 4 5 6 7 8 9 10))
  (define whole2 (set-copy whole))
  (define whole3 (set-copy whole))
  (define whole4 (set-copy whole))
  (define bottom (set eqv-comparator 1 2 3 4 5))
  (define top (set eqv-comparator 6 7 8 9 10))
(define-values (topx bottomx)
    (set-partition big whole))
  (set-partition! big whole4)
;;   (parameterize ((current-test-comparator set=?))
    (test "sets/whole 1" #t (set=? top (set-filter big whole)))
    (test "sets/whole 2" #t (set=? bottom (set-remove big whole)))
    (set-filter! big whole2)
    (test "sets/whole 3" #t (not (set-contains? whole2 1)))
    (set-remove! big whole3)
    (test "sets/whole 4" #t (not (set-contains? whole3 10)))
    (test "sets/whole 5" #t (set=? top topx))
    (test "sets/whole 6" #t (set=? bottom bottomx))
    (test "sets/whole 7" #t (set=? top whole4))
  (test "sets/whole 8" 5 (set-count big whole))
  (define hetero (set eqv-comparator 1 2 'a 3 4))
  (define homo (set eqv-comparator 1 2 3 4 5))
  (test "sets/whole 8" 'a (set-find symbol? hetero (lambda () (error "wrong"))))
  (test/error  "sets/whole 9" (set-find symbol? homo (lambda () (error "wrong"))))
  (test "sets/whole 10" #t (set-any? symbol? hetero))
  (test "sets/whole 11" #t (set-any? number? hetero))
  (test "sets/whole 12" #t (not (set-every? symbol? hetero)))
  (test "sets/whole 13" #t (not (set-every? number? hetero)))
  (test "sets/whole 14" #t (not (set-any? symbol? homo)))
  (test "sets/whole 15" #t (set-every? number? homo))


;;; "sets/lowlevel"
  (define bucket (set string-ci-comparator "abc" "def"))
  (test "sets/lowlevel 1" string-ci-comparator (set-element-comparator bucket))
  (test "sets/lowlevel 2" #t (set-contains? bucket "abc"))
  (test "sets/lowlevel 3" #t (set-contains? bucket "ABC"))
  (test "sets/lowlevel 4" "def" (set-member bucket "DEF" "fqz"))
  (test "sets/lowlevel 5" "fqz" (set-member bucket "lmn" "fqz"))
  (define nums (set number-comparator 1 2 3))
  ;; nums is now {1, 2, 3}
  (define nums2 (set-replace nums 2.0))
  ;; nums2 is now {1, 2.0, 3}
  (test "sets/lowlevel 6" #t (set-any? inexact? nums2))
  (set-replace! nums 2.0)
  ;; nums is now {1, 2.0, 3}
  (test "sets/lowlevel 6" #t (set-any? inexact? nums))
  (define sos
    (set set-comparator
      (set equal-comparator '(2 . 1) '(1 . 1) '(0 . 2) '(0 . 0))
      (set equal-comparator '(2 . 1) '(1 . 1) '(0 . 0) '(0 . 2))))
  (test "sets/lowlevel 5" 1 (set-size sos))


;;; "bags/simple"
  (define nums (bag number-comparator))
  ;; nums is now {}
  (define syms (bag eq-comparator 'a 'b 'c 'd))
  ;; syms is now {a, b, c, d}
  (define nums2 (bag-copy nums))
  ;; nums2 is now {}
  (define syms2 (bag-copy syms))
  ;; syms2 is now {a, b, c, d}
  (define esyms (bag eq-comparator))
  ;; esyms is now {}
  (test "bags/simple 1" #t (bag-empty? esyms))
  (define total 0)
  (test "bags/simple 2" #t (bag? nums))
  (test "bags/simple 3" #t (bag? syms))
  (test "bags/simple 4" #t (bag? nums2))
  (test "bags/simple 5" #t (bag? syms2))
  (test "bags/simple 6" #t (not (bag? 'a)))
  (bag-adjoin! nums 2)
  (bag-adjoin! nums 3)
  (bag-adjoin! nums 4)
  ;; nums is now {2, 3, 4}
  (test "bags/simple 7" 4 (bag-size (bag-adjoin nums 5)))
  (test "bags/simple 8" 3 (bag-size nums))
  (test "bags/simple 9" 3 (bag-size (bag-delete syms 'd)))
  (test "bags/simple 10" 2 (bag-size (bag-delete-all syms '(c d))))
  (test "bags/simple 11" 4 (bag-size syms))
  (bag-adjoin! syms 'e 'f)
  ;; syms is now {a, b, c, d, e, f}
  (test "bags/simple 12" 4 (bag-size (bag-delete-all! syms '(e f))))
  ;; syms is now {a, b, c, d}
  (test "bags/simple 13" 3 (bag-size nums))
  (bag-delete! nums 1)
  (test "bags/simple 14" 3 (bag-size nums))
  (set! nums2 (bag-map number-comparator (lambda (x) (* 10 x)) nums))
  ;; nums2 is now {20, 30, 40}
  (test "bags/simple 15" #t (bag-contains? nums2 30))
  (test "bags/simple 16" #t (not (bag-contains? nums2 3)))
  (bag-for-each (lambda (x) (set! total (+ total x))) nums2)
  (test "bags/simple 17" 90 total)
  (test "bags/simple 18" 12 (bag-fold + 3 nums))
  (set! nums (bag eqv-comparator 10 20 30 40 50))
  ;; nums is now {10, 20, 30, 40, 50}
  (test "bags/simple 19" #t
    (bag=? nums (bag-unfold
       (lambda (i) (= i 0))
       (lambda (i) (* i 10))
       (lambda (i) (- i 1))
       5
       eqv-comparator)))
  (test "bags/simple 20" '(a) (bag->list (bag eq-comparator 'a)))
  (set! syms2 (list->bag eq-comparator '(e f)))
  ;; syms2 is now {e, f}
  (test "bags/simple 21" 2 (bag-size syms2))
  (test "bags/simple 22" #t (bag-contains? syms2 'e))
  (test "bags/simple 23" #t (bag-contains? syms2 'f))
  (list->bag! syms2 '(e f))
  ;; syms2 is now {e, e, f, f}
  (test "bags/simple 24" 4 (bag-size syms2))


;;; "bags/search"
  (define yam (bag char-comparator #\y #\a #\m))
  (define (failure/insert insert ignore)
    (insert 1))
  (define (failure/ignore insert ignore)
    (ignore 2))
  (define (success/update element update remove)
    (update #\b 3))
  (define (success/remove element update remove)
    (remove 4))
  (define yam! (bag char-comparator #\y #\a #\m #\!))
  (define bam (bag char-comparator #\b #\a #\m))
  (define ym (bag char-comparator #\y #\m))
  (define-values (bag1 obj1)
    (bag-search! (bag-copy yam) #\! failure/insert error))
  (test "bags/search 1" #t (bag=? yam! bag1))
  (test "bags/search 2" 1 obj1)
  (define-values (bag2 obj2)
    (bag-search! (bag-copy yam) #\! failure/ignore error))
  (test "bags/search 3" #t (bag=? yam bag2))
  (test "bags/search 4" 2 obj2)
  (define-values (bag3 obj3)
    (bag-search! (bag-copy yam) #\y error success/update))
  (test "bags/search 5" #t (bag=? bam bag3))
  (test "bags/search 6" 3 obj3)
  (define-values (bag4 obj4)
    (bag-search! (bag-copy yam) #\a error success/remove))
  (test "bags/search 7" #t (bag=? ym bag4))
  (test "bags/search 8" 4 obj4)


;;; "bags/elemcount"
  (define mybag (bag eqv-comparator 1 1 1 1 1 2 2))
  (test "bags/elemcount 1" 5 (bag-element-count mybag 1))
  (test "bags/elemcount 2" 0 (bag-element-count mybag 3))


;;; "bags/subbags"
  (define bag2 (bag number-comparator 1 2))
  (define other-bag2 (bag number-comparator 1 2))
  (define bag3 (bag number-comparator 1 2 3))
  (define bag4 (bag number-comparator 1 2 3 4))
  (define bagx (bag number-comparator 10 20 30 40))
  (define bagy (bag number-comparator 10 20 20 30 40))
  (test "bags/subbags 1" #t (bag=? bag2 other-bag2))
  (test "bags/subbags 2" #t (not (bag=? bag2 bag3)))
  (test "bags/subbags 3" #t (not (bag=? bag2 bag3 other-bag2)))
  (test "bags/subbags 4" #t (bag<? bag2 bag3 bag4))
  (test "bags/subbags 5" #t (not (bag<? bag2 other-bag2)))
  (test "bags/subbags 6" #t (bag<=? bag2 other-bag2 bag3))
  (test "bags/subbags 7" #t (not (bag<=? bag2 bag3 other-bag2)))
  (test "bags/subbags 8" #t (bag>? bag4 bag3 bag2))
  (test "bags/subbags 9" #t (not (bag>? bag2 other-bag2)))
  (test "bags/subbags 10" #t (bag>=? bag3 other-bag2 bag2))
  (test "bags/subbags 11" #t (not (bag>=? other-bag2 bag3 bag2)))
  (test "bags/subbags 12" #t (not (bag<? bag2 other-bag2)))
  (test "bags/subbags 13" #t (bag<=? bagx bagy))
  (test "bags/subbags 14" #t (not (bag<=? bagy bagx)))
  (test "bags/subbags 15" #t (bag<? bagx bagy))
  (test "bags/subbags 16" #t (not (bag<? bagy bagx)))
  (test "bags/subbags 17" #t (bag>=? bagy bagx))
  (test "bags/subbags 18" #t (not (bag>=? bagx bagy)))
  (test "bags/subbags 19" #t (bag>? bagy bagx))
  (test "bags/subbags 20" #t (not (bag>? bagx bagy)))


;;; "bags/multi"
  (define one (bag eqv-comparator 10))
  (define two (bag eqv-comparator 10 10))
  (test "bags/multi 1" #t (not (bag=? one two)))
  (test "bags/multi 2" #t (bag<? one two))
  (test "bags/multi 3" #t (not (bag>? one two)))
  (test "bags/multi 4" #t (bag<=? one two))
  (test "bags/multi 5" #t (not (bag>? one two)))
  (test "bags/multi 6" #t (bag=? two two))
  (test "bags/multi 7" #t (not (bag<? two two)))
  (test "bags/multi 8" #t (not (bag>? two two)))
  (test "bags/multi 9"  #t (bag<=? two two))
  (test "bags/multi 10" #t (bag>=? two two))
  (test "bags/multi 11"
        '((10 . 2))
        (let ((result '()))
          (bag-for-each-unique
           (lambda (x y) (set! result (cons (cons x y) result)))
           two)
          result))
  (test "bags/multi 12" 25 (bag-fold + 5 two))
  (test "bags/multi 13" 12 (bag-fold-unique (lambda (k n r) (+ k n r)) 0 two))


;;; "bags/ops"
  ;; Potentially mutable
  (define abcd (bag eq-comparator 'a 'b 'c 'd))
  (define efgh (bag eq-comparator 'e 'f 'g 'h))
  (define abgh (bag eq-comparator 'a 'b 'g 'h))
  ;; Never get a chance to be mutated
  (define other-abcd (bag eq-comparator 'a 'b 'c 'd))
  (define other-efgh (bag eq-comparator 'e 'f 'g 'h))
  (define other-abgh (bag eq-comparator 'a 'b 'g 'h))
  (define all (bag eq-comparator 'a 'b 'c 'd 'e 'f 'g 'h))
  (define none (bag eq-comparator))
  (define ab (bag eq-comparator 'a 'b))
  (define cd (bag eq-comparator 'c 'd))
  (define ef (bag eq-comparator 'e 'f))
  (define gh (bag eq-comparator 'g 'h))
  (define cdgh (bag eq-comparator 'c 'd 'g 'h))
  (define abcdgh (bag eq-comparator 'a 'b 'c 'd 'g 'h))
  (define abefgh (bag eq-comparator 'a 'b 'e 'f 'g 'h))
  (test "bags/ops 1" #t (bag-disjoint? abcd efgh))
  (test "bags/ops 2" #t (not (bag-disjoint? abcd ab)))
;(parameterize ((current-test-comparator bag=?))
    (test "bags/ops " #t (bag=? abcd (bag-union abcd)))
    (test "bags/ops " #t (bag=? all (bag-union abcd efgh)))
    (test "bags/ops " #t (bag=? abcdgh (bag-union abcd abgh)))
    (test "bags/ops " #t (bag=? abefgh (bag-union efgh abgh)))
    (define efgh2 (bag-copy efgh))
    (bag-union! efgh2)
    (test "bags/ops " #t (bag=? efgh efgh2))
    (bag-union! efgh2 abgh)
    (test "bags/ops " #t (bag=? abefgh efgh2))
    (test "bags/ops " #t (bag=? abcd (bag-intersection abcd)))
    (test "bags/ops " #t (bag=? none (bag-intersection abcd efgh)))
    (define abcd2 (bag-copy abcd))
    (bag-intersection! abcd2)
    (test "bags/ops " #t (bag=? abcd abcd2))
    (bag-intersection! abcd2 efgh)
    (test "bags/ops " #t (bag=? none abcd2))
    (test "bags/ops " #t (bag=? ab (bag-intersection abcd abgh)))
    (test "bags/ops " #t (bag=? ab (bag-intersection abgh abcd)))
    (test "bags/ops " #t (bag=? abcd (bag-difference abcd)))
    (test "bags/ops " #t (bag=? cd (bag-difference abcd ab)))
    (test "bags/ops " #t (bag=? abcd (bag-difference abcd gh)))
    (test "bags/ops " #t (bag=? none (bag-difference abcd abcd)))
    (define abcd3 (bag-copy abcd))
    (bag-difference! abcd3)
    (test "bags/ops " #t (bag=? abcd abcd3))
    (bag-difference! abcd3 abcd)
    (test "bags/ops " #t (bag=? none abcd3))
    (test "bags/ops " #t (bag=? cdgh (bag-xor abcd abgh)))
    (test "bags/ops " #t (bag=? all (bag-xor abcd efgh)))
    (test "bags/ops " #t (bag=? none (bag-xor abcd other-abcd)))
    (define abcd4 (bag-copy abcd))
    (test "bags/ops " #t (bag=? none (bag-xor! abcd4 other-abcd)))
    (define abab (bag eq-comparator 'a 'b 'a 'b))
    (test "bags/ops " #t (bag=? ab (bag-sum ab)))
    (define ab2 (bag-copy ab))
    (test "bags/ops " #t (bag=? ab (bag-sum! ab2)))
    (test "bags/ops " #t (bag=? abab (bag-sum! ab2 ab)))
    (test "bags/ops " #t (bag=? abab ab2))
    (test "bags/ops " #t (bag=? abab (bag-product 2 ab)))
    (define ab3 (bag-copy ab))
    (bag-product! 2 ab3)
    (test "bags/ops " #t (bag=? abab ab3))
    (test "bags/ops " #t (bag=?  other-abcd abcd)) ; "abcd smashed?"
    (test "bags/ops " #t (bag=?  other-abcd abcd)) ; "abcd smashed?"
    (test "bags/ops " #t (bag=?  other-efgh efgh)) ; "efgh smashed?"
    (test "bags/ops " #t (bag=?  other-abgh abgh)) ; "abgh smashed?"

;;; STklos test system won't catch syntax error; skip these
;; (test-group "bags/mismatch"
;;   (define nums (bag number-comparator 1 2 3))
;;   (define syms (bag eq-comparator 'a 'b 'c))
;;   (test/error (bag=? nums syms))
;;   (test/error (bag<? nums syms))
;;   (test/error (bag<=? nums syms))
;;   (test/error (bag>? nums syms))
;;   (test/error (bag>=? nums syms))
;;   (test/error (bag-union nums syms))
;;   (test/error (bag-intersection nums syms))
;;   (test/error (bag-difference nums syms))
;;   (test/error (bag-xor nums syms))
;;   (test/error (bag-union! nums syms))
;;   (test/error (bag-intersection! nums syms))
;;   (test/error (bag-difference! nums syms))
;; ) ; end bags/mismatch

;;; "bags/whole"
  (define whole (bag eqv-comparator 1 2 3 4 5 6 7 8 9 10))
  (define whole2 (bag-copy whole))
  (define whole3 (bag-copy whole))
  (define whole4 (bag-copy whole))
  (define bottom (bag eqv-comparator 1 2 3 4 5))
  (define top (bag eqv-comparator 6 7 8 9 10))
  (define-values (topx bottomx)
    (bag-partition big whole))
  (bag-partition! big whole4)
;  (parameterize ((current-test-comparator bag=?))
    (test "bags/whole 1" #t (bag=? top (bag-filter big whole)))
    (test "bags/whole 2" #t (bag=? bottom (bag-remove big whole)))
    (bag-filter! big whole2)
    (test "bags/whole 3" #t (not (bag-contains? whole2 1)))
    (bag-remove! big whole3)
    (test "bags/whole 4" #t (not (bag-contains? whole3 10)))
    (test "bags/whole 5" #t (bag=? top topx))
    (test "bags/whole 6" #t (bag=? bottom bottomx))
    (test "bags/whole 7" #t (bag=? top whole4))
  (test "bags/whole 8" 5 (bag-count big whole))
  (define hetero (bag eqv-comparator 1 2 'a 3 4))
  (define homo (bag eqv-comparator 1 2 3 4 5))
  (test "bags/simple 9" 'a (bag-find symbol? hetero (lambda () (error "wrong"))))
  (test/error  "bags/simple 10" (bag-find symbol? homo (lambda () (error "wrong"))))
  (test "bags/simple 11" #t (bag-any? symbol? hetero))
  (test "bags/simple 12" #t (bag-any? number? hetero))
  (test "bags/simple 13" #t (not (bag-every? symbol? hetero)))
  (test "bags/simple 14" #t (not (bag-every? number? hetero)))
  (test "bags/simple 15" #t (not (bag-any? symbol? homo)))
  (test "bags/simple 16" #t (bag-every? number? homo))


;;; "bags/lowlevel"
  (define bucket (bag string-ci-comparator "abc" "def"))
  (test "bags/lowlevel 0"  string-ci-comparator (bag-element-comparator bucket))
  (test "bags/lowlevel 1" #t (bag-contains? bucket "abc"))
  (test "bags/lowlevel 2" #t (bag-contains? bucket "ABC"))
  (test "bags/lowlevel 3" "def" (bag-member bucket "DEF" "fqz"))
  (test "bags/lowlevel 4" "fqz" (bag-member bucket "lmn" "fqz"))
  (define nums (bag number-comparator 1 2 3))
  ;; nums is now {1, 2, 3}
  (define nums2 (bag-replace nums 2.0))
  ;; nums2 is now {1, 2.0, 3}
  (test "bags/lowlevel 5" #t (bag-any? inexact? nums2))
  (bag-replace! nums 2.0)
  ;; nums is now {1, 2.0, 3}
  (test "bags/lowlevel 6" #t (bag-any? inexact? nums))
  (define bob
    (bag bag-comparator
      (bag eqv-comparator 1 2)
      (bag eqv-comparator 1 2)))
  (test "bags/lowlevel 7" 2 (bag-size bob))



;;; "bags/semantics"
  (define mybag (bag number-comparator 1 2))
  ;; mybag is {1, 2}
  (test "bags/semantics 1" 2 (bag-size mybag))
  (bag-adjoin! mybag 1)
  ;; mybag is {1, 1, 2}
  (test "bags/semantics 2" 3 (bag-size mybag))
  (test "bags/semantics 3" 2 (bag-unique-size mybag))
  (bag-delete! mybag 2)
  ;; mybag is {1, 1}
  (bag-delete! mybag 2)
  (test "bags/semantics 4" 2 (bag-size mybag))
  (bag-increment! mybag 1 3)
  ;; mybag is {1, 1, 1, 1, 1}
  (test "bags/semantics 5" 5 (bag-size mybag))
  (test "bags/semantics 6" #t (not (not (bag-decrement! mybag 1 2))))
  ;; mybag is {1, 1, 1}
  (test "bags/semantics 7" 3 (bag-size mybag))
  (bag-decrement! mybag 1 5)
  ;; mybag is {}
  (test "bags/semantics 8" 0 (bag-size mybag))


;;; "bags/convert"
  (define multi (bag eqv-comparator 1 2 2 3 3 3))
  (define single (bag eqv-comparator 1 2 3))
  (define singleset (set eqv-comparator 1 2 3))
  (define minibag (bag eqv-comparator 'a 'a))
  (define alist '((a . 2)))
  (test "bags/convert 1" alist (bag->alist minibag))
  (test "bags/convert 2" #t (bag=? minibag (alist->bag eqv-comparator alist)))
  (test "bags/convert 3" #t (set=? singleset (bag->set single)))
  (test "bags/convert 4" #t (set=? singleset (bag->set multi)))
  (test "bags/convert 5" #t (bag=? single (set->bag singleset)))
  (test "bags/convert 6" #t (not (bag=? multi (set->bag singleset))))
  (set->bag! minibag singleset)
  ;; minibag is now {a, a, a, a, 1, 2, 3}
  (test "bags/convert 7" #t (bag-contains? minibag 1))


;;; "bags/sumprod"
  (define abb (bag eq-comparator 'a 'b 'b))
  (define aab (bag eq-comparator 'a 'a 'b))
  (define total (bag-sum abb aab))
  (test "bags/sumprod 1" 3 (bag-count (lambda (x) (eqv? x 'a)) total))
  (test "bags/sumprod 2" 3 (bag-count (lambda (x) (eqv? x 'b)) total))
  (test "bags/sumprod 3" 12 (bag-size (bag-product 2 total)))
  (define bag1 (bag eqv-comparator 1))
  (bag-sum! bag1 bag1)
  (test "bags/sumprod 4" 2 (bag-size bag1))
  (bag-product! 2 bag1)
  (test "bags/sumprod 5" 4 (bag-size bag1))


;;; "comparators"
  (define a (set number-comparator 1 2 3))
  (define b (set number-comparator 1 2 4))
  (define aa (bag number-comparator 1 2 3))
  (define bb (bag number-comparator 1 2 4))
  (test "bags/comparators 1" #t (not (=? set-comparator a b)))
  (test "bags/comparators 2" #t (=? set-comparator a (set-copy a)))
;;  (test/error (<? set-comparator a b))
  (test "bags/comparators 3" #t (not (=? bag-comparator aa bb)))
  (test "bags/comparators 4" #t (=? bag-comparator aa (bag-copy aa)))
;;  (test/error (<? bag-comparator aa bb))
  (test "bags/comparators 5" #t (not (=? (make-default-comparator) a aa)))


;; ----------------------------------------------------------------------
;;  SRFI 117 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 117 - Queues based on lists")

(require "srfi-117")

;; list-queues/simple
(test "make-list-queue"  '(1 1 1) (list-queue-list (make-list-queue '(1 1 1))))
(define x (list-queue 1 2 3))
(test "list-queue-list" '(1 2 3) (list-queue-list x))
(define x1 (list 1 2 3))
(define x2 (make-list-queue x1 (cddr x1)))
(test "list-queue-back" 3 (list-queue-back x2))
(define y (list-queue 4 5))
(test "list-queue?" #t (list-queue? y))
(define z (list-queue-append x y))
(test "list-queue-append" '(1 2 3 4 5) (list-queue-list z))
(define z2 (list-queue-append! x (list-queue-copy y)))
(test "list-queue-append-copy" '(1 2 3 4 5) (list-queue-list z2))
(test "list-queue-append-copy-front" 1 (list-queue-front z))
(test "list-queue-append-copy-back" 5 (list-queue-back z))
(list-queue-remove-front! y)
(test "list-queue-remove-front!" '(5) (list-queue-list y))
(list-queue-remove-back! y)
(test "list-queue-empty?" #t (list-queue-empty? y))
(test "list-queue don't remove-front from empty"
      'error-occurred
      (with-handler (lambda (e)
                      'error-occurred)
                    (list-queue-remove-front! y)))
(test "list-queue don't remove-back from empty"
      'error-occurred
      (with-handler (lambda (e)
                      'error-occurred)
                    (list-queue-remove-back! y)))
(test "list-queue-list II" '(1 2 3 4 5) (list-queue-list z))
(test "list-queue-remove-all!" '(1 2 3 4 5) (list-queue-remove-all! z2))
(test "list-queue-remove-all! -> empty" #t (list-queue-empty? z2))
(list-queue-remove-all! z)
(list-queue-add-front! z 1)
(list-queue-add-front! z 0)
(list-queue-add-back! z 2)
(list-queue-add-back! z 3)
(test "list-queue-remove-all-add-4" '(0 1 2 3) (list-queue-list z))

;; list-queues/whole
(define a (list-queue 1 2 3))
(define b (list-queue-copy a))
(test "list-queue-copy" '(1 2 3) (list-queue-list b))
(list-queue-add-front! b 0)
(test "list-queue-copy is not shared" '(1 2 3) (list-queue-list a))
(test "list-queue-copy size" 4 (length (list-queue-list b)))
(define c (list-queue-concatenate (list a b)))
(test "list-queue-concatenate" '(1 2 3 0 1 2 3) (list-queue-list c))

;; list-queues/map
(define r (list-queue 1 2 3))
(define s (list-queue-map (lambda (x) (* x 10)) r))
(test "list-queue-map" '(10 20 30) (list-queue-list s))
(list-queue-map! (lambda (x) (+ x 1)) r)
(test "list-queue-map!" '(2 3 4) (list-queue-list r))
(define sum 0)
(list-queue-for-each (lambda (x) (set! sum (+ sum x))) s)
(test "list-queue-for-each" 60 sum)

;; list-queues/conversion
(define n (list-queue 5 6))
(list-queue-set-list! n (list 1 2))
(test "list-queue-set-list!" '(1 2) (list-queue-list n))
(define d (list 1 2 3))
(define e (cddr d))
(define f (make-list-queue d e))
(define dx #f) ; redefined below
(define ex #f) ; redefined below
(let-values (((dxv exv) (list-queue-first-last f)))
  (set! dx dxv)
  (set! ex exv))
(test "list-queue-first-last" #t (eq? d dx))
(test "list-queue-first-last II" #t (eq? e ex))
(test "list-queue-first-last III" '(1 2 3) (list-queue-list f))
(list-queue-add-front! f 0)
(list-queue-add-back! f 4)
(test "list-queue-add-{front,back}!" '(0 1 2 3 4) (list-queue-list f))
(define g (make-list-queue d e))
(test "make-list-queue II" '(1 2 3 4) (list-queue-list g))
(define h (list-queue 5 6))
(list-queue-set-list! h d e)
(test "list-queue-set-list! II" '(1 2 3 4) (list-queue-list h))

;; list-queues/unfold
(define (double x) (* x 2))
(define (done? x) (> x 3))
(define (add1 x) (+ x 1))
(define x (list-queue-unfold done? double add1 0))
(test "list-queue-unfold" '(0 2 4 6) (list-queue-list x))
(define y (list-queue-unfold-right done? double add1 0))
(test "list-queue-unfold-right" '(6 4 2 0) (list-queue-list y))
(define x0 (list-queue 8))
(define x1 (list-queue-unfold done? double add1 0 x0))
(test "list-queue-unfold II" '(0 2 4 6 8) (list-queue-list x1))
(define y0 (list-queue 8))
(define y1 (list-queue-unfold-right done? double add1 0 y0))
(test "list-queue-unfold-right II" '(8 6 4 2 0) (list-queue-list y1))

;; ----------------------------------------------------------------------
;;  SRFI 118 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 118 - Simple adjustable-size strings")

(define-syntax set-mutable-string!
  (syntax-rules ()
    ((_ s v)
     (set! s (string-copy v)))))

(define a6  (string-copy "abcdef"))
(define b6  (string-copy "123456"))
(define b12 (string-copy "qwertyuiopas"))

(define au6  (string-copy "Ã¡bcdÃf"))
(define bu6  (string-copy "È ÈÈ¡Ç®Æ¶ã"))
(define bu12 (string-copy "è¡ãà¤å½Ø«ØØµ××°âxy"))

(test "string-append! single" "abcdef" (string-append! a6))
(set-mutable-string! a6 "abcdef")
(test "string-append! single length" 6  (string-length (string-append! a6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! single eq?" #t (eq? a6 (string-append! a6)))

(set-mutable-string! a6  "abcdef")
(define a6-copy (string-copy a6))
(test "string-append! = append" #t (string=? (string-append! a6 b6)
                                             (string-append  a6-copy b6)))
(set-mutable-string! a6 "abcdef")
(test "string-append!" "abcdef123456" (string-append! a6 b6))
(set-mutable-string! a6 "abcdef")
(test "string-append! length" 12 (string-length (string-append! a6 b6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! eq?" #t (eq? a6 (string-append! a6 b6)))

(set-mutable-string! a6 "abcdef")
(test "string-append! char" "abcdef123456" (string-append! a6 #\1 #\2 "345" #\6))
(set-mutable-string! a6 "abcdef")
(test "string-append! char length" 12 (string-length (string-append! a6 #\1 #\2 "345" #\6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! char eq?" #t (eq? a6 (string-append! a6 #\1 #\2 "345" #\6)))



(define au6-copy (string-copy au6))
(test "append! = append, unicode" #t (string=? (string-append! au6 bu6 bu12)
                                               (string-append au6-copy bu6 bu12)))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "append! = append, unicode, length" 24 (string-length (string-append! au6 bu6 bu12)))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "append! = append, unicode, eq?" #t (eq? au6 (string-append! au6 bu6 bu12)))
(set-mutable-string! au6  "Ã¡bcdÃf")

(set-mutable-string! a6 "abcdef")
(test "string-append! char, unicode" "abcdefà¦2345à¼«" (string-append! a6 #\à¦ #\2 "345" #\à¼«))
(set-mutable-string! a6 "abcdef")
(test "string-append! char, unicode, length" 12 (string-length (string-append! a6 #\à¦ #\2 "345" #\à¼«)))
(set-mutable-string! a6 "abcdef")
(test "string-append! char, unidoce, eq?" #t (eq? a6 (string-append! a6 #\à¦ #\2 "345" #\à¼«)))

(set-mutable-string! au6  "Ã¡bcdÃf")
(test "string-append! char, unicode" "Ã¡bcdÃfà¦2345à¼«" (string-append! au6 #\à¦ #\2 "345" #\à¼«))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "string-append! char, unicode, length" 12 (string-length (string-append! au6 #\à¦ #\2 "345" #\à¼«)))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "string-append! char, unidoce, eq?" #t (eq? au6 (string-append! au6 #\à¦ #\2 "345" #\à¼«)))


(test/error "string-append! args 1"  (string-append! a6 #t))
(test/error "string-append! args 2"  (string-append! a6 2))
(test/error "string-append! args 3"  (string-append! 3 10))
(test/error "string-append! args 4"  (string-append! 'a 'b))

(test/error "string-replace! args 1" (string-replace! 'a 0 6  b6 0 6))
(test/error "string-replace! args 2" (string-replace! a6 0 6  #t 0 6))
(test/error "string-replace! args 3" (string-replace! a6 -1 6  b6 0 6))
(test/error "string-replace! args 4" (string-replace! a6  0 50 b6 0 6))
(test/error "string-replace! args 5" (string-replace! a6  0  6  b6 -1 6))
(test/error "string-replace! args 6" (string-replace! a6  0  6  b6  0 50))

(test/error "string-replace! args 7" (string-replace! 'a 6 0  b6 0 6))
(test/error "string-replace! args 8" (string-replace! 'a 0 6  b6 6 0))

(set-mutable-string! a6 "abcdef")
(test "string-replace! all" "123456"  (string-replace! a6 0 6 b6 0 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! all length" 6  (string-length (string-replace! a6 0 6 b6 0 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! all eq?" #t  (eq? a6 (string-replace! a6 0 6 b6 0 6)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! part" "ab23ef"  (string-replace! a6 2 4 b6 1 3))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part length" 6  (string-length (string-replace! a6 2 4 b6 1 3)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part eq?" #t  (eq? a6 (string-replace! a6 2 4 b6 1 3)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2" "abpaef"  (string-replace! a6 2 4 b12 9 11))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2 length" 6  (string-length (string-replace! a6 2 4 b12 9 11)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2 eq?" #t  (eq? a6 (string-replace! a6 2 4 b12 9 11)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! delete" "abef" (string-replace! a6 2 4 b6 0 0))
(set-mutable-string! a6 "abcdef")
(test "string-replace! delete length" 4  (string-length (string-replace! a6 2 4 b6 0 0)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! delete eq?" #t  (eq? a6 (string-replace! a6 2 4 b6 0 0)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! insert" "abc123456def" (string-replace! a6 3 3 b6 0 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! insert length" 12  (string-length (string-replace! a6 3 3 b6 0 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! insert eq?" #t  (eq? a6 (string-replace! a6 3 3 b6 0 6)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap" "abefef" (string-replace! a6 2 4 a6 4 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap length" 6  (string-length (string-replace! a6 2 4 a6 4 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap eq?" #t  (eq? a6 (string-replace! a6 2 4 a6 4 6)))

;; ----------------------------------------------------------------------
;;  SRFI 128 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 128 - Comparators")

(require "srfi-128")

(define (vector-cdr vec)
    (let* ((len (vector-length vec))
           (result (make-vector (- len 1))))
      (let loop ((n 1))
        (cond
          ((= n len) result)
          (else (vector-set! result (- n 1) (vector-ref vec n))
                (loop (+ n 1)))))))

(test "vector-cdr"   '#(2 3 4) (vector-cdr '#(1 2 3 4)))
(test "vector-cdr 2" '#() (vector-cdr '#(1)))

(define default-comparator (make-default-comparator))
(define real-comparator (make-comparator real? = < number-hash))
(define degenerate-comparator (make-comparator (lambda (x) #t) equal? #f #f))
(define boolean-comparator
  (make-comparator boolean? eq? (lambda (x y) (and (not x) y)) boolean-hash))
(define bool-pair-comparator (make-pair-comparator boolean-comparator boolean-comparator))
(define num-list-comparator
  (make-list-comparator real-comparator list? null? car cdr))
(define num-vector-comparator
  (make-vector-comparator real-comparator vector? vector-length vector-ref))
(define vector-qua-list-comparator
  (make-list-comparator
   real-comparator
   vector?
   (lambda (vec) (= 0 (vector-length vec)))
   (lambda (vec) (vector-ref vec 0))
   vector-cdr))
(define list-qua-vector-comparator
  (make-vector-comparator default-comparator list? length list-ref))
(define eq-comparator (make-eq-comparator))
(define eqv-comparator (make-eqv-comparator))
(define equal-comparator (make-equal-comparator))
(define symbol-comparator
  (make-comparator
   symbol?
   eq?
   (lambda (a b) (string<? (symbol->string a) (symbol->string b)))
   symbol-hash))

;; comparators/predicates
(test "comparator? 1" #t (comparator? real-comparator))
(test "comparator? 2" #t (not (comparator? =)))
(test "ordered?" #t (comparator-ordered? real-comparator))
(test "hashtable?" #t (comparator-hashable? real-comparator))
(test "ordered? 2" #t (not (comparator-ordered? degenerate-comparator)))
(test "hashtable? 2" #t (not (comparator-hashable? degenerate-comparator)))

;; comparators/constructors

(test "1" #t (=? boolean-comparator #t #t))
(test "2" #t (not (=? boolean-comparator #t #f)))
(test "3" #t (<? boolean-comparator #f #t))
(test "4" #t (not (<? boolean-comparator #t #t)))
(test "5" #t (not (<? boolean-comparator #t #f)))

(test "6" #t (comparator-test-type bool-pair-comparator '(#t . #f)))
(test "7" #t (not (comparator-test-type bool-pair-comparator 32)))
(test "8" #t (not (comparator-test-type bool-pair-comparator '(32 . #f))))
(test "9" #t (not (comparator-test-type bool-pair-comparator '(#t . 32))))
(test "10" #t (not (comparator-test-type bool-pair-comparator '(32 . 34))))
(test "11" #t (=? bool-pair-comparator '(#t . #t) '(#t . #t)))
(test "12" #t (not (=? bool-pair-comparator '(#t . #t) '(#f . #t))))
(test "13" #t (not (=? bool-pair-comparator '(#t . #t) '(#t . #f))))
(test "14" #t (<? bool-pair-comparator '(#f . #t) '(#t . #t)))
(test "15" #t (<? bool-pair-comparator '(#t . #f) '(#t . #t)))
(test "16" #t (not (<? bool-pair-comparator '(#t . #t) '(#t . #t))))
(test "17" #t (not (<? bool-pair-comparator '(#t . #t) '(#f . #t))))
(test "18" #t (not (<? bool-pair-comparator '(#f . #t) '(#f . #f))))

(test "19" #t (comparator-test-type num-vector-comparator '#(1 2 3)))
(test "20" #t (comparator-test-type num-vector-comparator '#()))
(test "21" #t (not (comparator-test-type num-vector-comparator 1)))
(test "22" #t (not (comparator-test-type num-vector-comparator '#(a 2 3))))
(test "23" #t (not (comparator-test-type num-vector-comparator '#(1 b 3))))
(test "24" #t (not (comparator-test-type num-vector-comparator '#(1 2 c))))
(test "25" #t (=? num-vector-comparator '#(1 2 3) '#(1 2 3)))
(test "26" #t (not (=? num-vector-comparator '#(1 2 3) '#(4 5 6))))
(test "27" #t (not (=? num-vector-comparator '#(1 2 3) '#(1 5 6))))
(test "28" #t (not (=? num-vector-comparator '#(1 2 3) '#(1 2 6))))
(test "29" #t (<? num-vector-comparator '#(1 2) '#(1 2 3)))
(test "30" #t (<? num-vector-comparator '#(1 2 3) '#(2 3 4)))
(test "31" #t (<? num-vector-comparator '#(1 2 3) '#(1 3 4)))
(test "32" #t (<? num-vector-comparator '#(1 2 3) '#(1 2 4)))
(test "33" #t (<? num-vector-comparator '#(3 4) '#(1 2 3)))
(test "34" #t (not (<? num-vector-comparator '#(1 2 3) '#(1 2 3))))
(test "35" #t (not (<? num-vector-comparator '#(1 2 3) '#(1 2))))
(test "36" #t (not (<? num-vector-comparator '#(1 2 3) '#(0 2 3))))
(test "37" #t (not (<? num-vector-comparator '#(1 2 3) '#(1 1 3))))

(test "38" #t (not (<? vector-qua-list-comparator '#(3 4) '#(1 2 3))))
(test "39" #t (<? list-qua-vector-comparator '(3 4) '(1 2 3)))

(define bool-pair (cons #t #f))
(define bool-pair-2 (cons #t #f))
(define reverse-bool-pair (cons #f #t))

(test "40" #t (=? eq-comparator #t #t))
(test "41" #t (not (=? eq-comparator #f #t)))
(test "42" #t (=? eqv-comparator bool-pair bool-pair))
(test "43" #t (not (=? eqv-comparator bool-pair bool-pair-2)))
(test "44" #t (=? equal-comparator bool-pair bool-pair-2))
(test "45" #t (not (=? equal-comparator bool-pair reverse-bool-pair)))

;; comparators/hash
(test "46" #t (exact-integer? (boolean-hash #f)))
(test "47" #t (not (negative? (boolean-hash #t))))
(test "48" #t (exact-integer? (char-hash #\a)))
(test "49" #t (not (negative? (char-hash #\b))))
(test "50" #t (exact-integer? (char-ci-hash #\a)))
(test "51" #t (not (negative? (char-ci-hash #\b))))
(test "52" #t (= (char-ci-hash #\a) (char-ci-hash #\A)))
(test "53" #t (exact-integer? (string-hash "f")))
(test "54" #t (not (negative? (string-hash "g"))))
(test "55" #t (exact-integer? (string-ci-hash "f")))
(test "56" #t (not (negative? (string-ci-hash "g"))))
(test "57" #t (= (string-ci-hash "f") (string-ci-hash "F")))
(test "58" #t (exact-integer? (symbol-hash 'f)))
(test "59" #t (not (negative? (symbol-hash 't))))
(test "60" #t (exact-integer? (number-hash 3)))
(test "61" #t (not (negative? (number-hash 3))))
(test "62" #t (exact-integer? (number-hash -3)))
(test "63" #t (not (negative? (number-hash -3))))
(test "64" #t (exact-integer? (number-hash 3.0)))
(test "65" #t (not (negative? (number-hash 3.0))))

;; comparators/default
(test "66" #t (<? default-comparator '() '(a)))
(test "67" #t (not (=? default-comparator '() '(a))))
(test "68" #t (=? default-comparator #t #t))
(test "69" #t (not (=? default-comparator #t #f)))
(test "70" #t (<? default-comparator #f #t))
(test "71" #t (not (<? default-comparator #t #t)))
(test "72" #t (=? default-comparator #\a #\a))
(test "73" #t (<? default-comparator #\a #\b))

(test "74" #t (comparator-test-type default-comparator '()))
(test "75" #t (comparator-test-type default-comparator #t))
(test "76" #t (comparator-test-type default-comparator #\t))
(test "77" #t (comparator-test-type default-comparator '(a)))
(test "78" #t (comparator-test-type default-comparator 'a))
(test "79" #t (comparator-test-type default-comparator (make-bytevector 10)))
(test "80" #t (comparator-test-type default-comparator 10))
(test "81" #t (comparator-test-type default-comparator 10.0))
(test "82" #t (comparator-test-type default-comparator "10.0"))
(test "83" #t (comparator-test-type default-comparator '#(10)))

(test "84" #t (=? default-comparator '(#t . #t) '(#t . #t)))
(test "85" #t (not (=? default-comparator '(#t . #t) '(#f . #t))))
(test "86" #t (not (=? default-comparator '(#t . #t) '(#t . #f))))
(test "87" #t (<? default-comparator '(#f . #t) '(#t . #t)))
(test "88" #t (<? default-comparator '(#t . #f) '(#t . #t)))
(test "89" #t (not (<? default-comparator '(#t . #t) '(#t . #t))))
(test "90" #t (not (<? default-comparator '(#t . #t) '(#f . #t))))
(test "91" #t (not (<? default-comparator '#(#f #t) '#(#f #f))))

(test "92" #t (=? default-comparator '#(#t #t) '#(#t #t)))
(test "93" #t (not (=? default-comparator '#(#t #t) '#(#f #t))))
(test "94" #t (not (=? default-comparator '#(#t #t) '#(#t #f))))
(test "95" #t (<? default-comparator '#(#f #t) '#(#t #t)))
(test "96" #t (<? default-comparator '#(#t #f) '#(#t #t)))
(test "97" #t (not (<? default-comparator '#(#t #t) '#(#t #t))))
(test "98" #t (not (<? default-comparator '#(#t #t) '#(#f #t))))
(test "99" #t (not (<? default-comparator '#(#f #t) '#(#f #f))))

(test "100" #t (= (comparator-hash default-comparator #t) (boolean-hash #t)))
(test "101" #t (= (comparator-hash default-comparator #\t) (char-hash #\t)))
(test "102" #t
      (begin
        (let ((a (comparator-hash default-comparator "t"))
              (b (string-hash "t")))
          (= a b))))
(test "103" #t (= (comparator-hash default-comparator 't) (symbol-hash 't)))
(test "104" #t (= (comparator-hash default-comparator 10) (number-hash 10)))
(test "105" #t (= (comparator-hash default-comparator 10.0) (number-hash 10.0)))

(comparator-register-default!
 (make-comparator procedure? (lambda (a b) #t) (lambda (a b) #f) (lambda (obj) 200)))
(test "106" #t (=? default-comparator (lambda () #t) (lambda () #f)))
(test "107" #t (not (<? default-comparator (lambda () #t) (lambda () #f))))
(test "108" 200 (comparator-hash default-comparator (lambda () #t)))



;; SRFI 128 does not actually require a comparator's four procedures
;; to be eq? to the procedures originally passed to make-comparator.
;; For interoperability/interchangeability between the comparators
;; of SRFI 114 and SRFI 128, some of the procedures passed to
;; make-comparator may need to be wrapped inside another lambda
;; expression before they're returned by the corresponding accessor.
;;
;; So this next group of tests is incorrect, hence commented out
;; and replaced by a slightly less naive group of tests.

;; comparators/accessors"
;; (define ttp (lambda (x) #t))
;; (define eqp (lambda (x y) #t))
;; (define orp (lambda (x y) #t))
;; (define hf (lambda (x) 0))
;; (define comp (make-comparator ttp eqp orp hf))
;; (test "" ttp (comparator-type-test-predicate comp))
;; (test "" eqp (comparator-equality-predicate comp))
;; (test "" orp (comparator-ordering-predicate comp))
;; (test "" hf (comparator-hash-function comp))

;; comparators/accessors
(define x1 0)
(define x2 0)
(define x3 0)
(define x4 0)
(define ttp (lambda (x) (set! x1 111) #t))
(define eqp (lambda (x y) (set! x2 222) #t))
(define orp (lambda (x y) (set! x3 333) #t))
(define hf (lambda (x) (set! x4 444) 0))
(define comp (make-comparator ttp eqp orp hf))
(test "109" #t (and ((comparator-type-test-predicate comp) x1)   (= x1 111)))
(test "110" #t (and ((comparator-equality-predicate comp) x1 x2) (= x2 222)))
(test "111" #t (and ((comparator-ordering-predicate comp) x1 x3) (= x3 333)))
(test "112" #t (and (zero? ((comparator-hash-function comp) x1)) (= x4 444)))

;; comparators/invokers
(test "113" #t (comparator-test-type real-comparator 3))
(test "114" #t (comparator-test-type real-comparator 3.0))
(test "115" #t (not (comparator-test-type real-comparator "3.0")))
(test "116" #t (comparator-check-type boolean-comparator #t))
(test "117" *test-failed* (comparator-check-type boolean-comparator 't))

;; comparators/comparison
(test "118" #t (=? real-comparator 2 2.0 2))
(test "119" #t (<? real-comparator 2 3.0 4))
(test "120" #t (>? real-comparator 4.0 3.0 2))
(test "121" #t (<=? real-comparator 2.0 2 3.0))
(test "122" #t (>=? real-comparator 3 3.0 2))
(test "123" #t (not (=? real-comparator 1 2 3)))
(test "124" #t (not (<? real-comparator 3 1 2)))
(test "125" #t (not (>? real-comparator 1 2 3)))
(test "126" #t (not (<=? real-comparator 4 3 3)))
(test "127" #t (not (>=? real-comparator 3 4 4.0)))


;; comparators/syntax
(test "128" 'less (comparator-if<=> real-comparator 1 2 'less 'equal 'greater))
(test "129" 'equal (comparator-if<=> real-comparator 1 1 'less 'equal 'greater))
(test "130" 'greater (comparator-if<=> real-comparator 2 1 'less 'equal 'greater))
(test "131" 'less (comparator-if<=> "1" "2" 'less 'equal 'greater))
(test "132" 'equal (comparator-if<=> "1" "1" 'less 'equal 'greater))
(test "133" 'greater (comparator-if<=> "2" "1" 'less 'equal 'greater))

;; comparators/bound-salt"
(test "hash bound" #t (exact-integer? (hash-bound)))
(test "hash salt" #t (exact-integer? (hash-salt)))
(test "hash salt<hash bound" #t (< (hash-salt) (hash-bound)))

;; ----------------------------------------------------------------------
;;  SRFI 129 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 129 - Titlecase procedures")

(require "srfi-129")

(test "" #t (char-title-case? #\x01C5))
(test "" #t (char-title-case? #\x1FFC))
(test "" #f (char-title-case? #\Z))
(test "" #f (char-title-case? #\z))

(test "char 1" #\x01C5 (char-titlecase #\x01C4))
(test "char 2" #\x01C5 (char-titlecase #\x01C6))
(test "char 3" #\Z (char-titlecase #\Z))
(test "char 4" #\Z (char-titlecase #\z))

(test "string 1" "\x01C5;" (string-titlecase "\x01C5;"))
(test "string 2" "\x01C5;" (string-titlecase "\x01C4;"))    ;
(test "string 3" "Ss" (string-titlecase "\x00DF;"))         ;
(test "string 4" "Xi\x0307;" (string-titlecase "x\x0130;")) ;
(test "string 5" "\x1F88;" (string-titlecase "\x1F80;"))
(test "string 6" "\x1F88;" (string-titlecase "\x1F88;"))


(define Floo "\xFB02;oo")
(define Floo-bar "\xFB02;oo bar")
(define Baffle "Ba\xFB04;e")
(define LJUBLJANA "\x01C7;ub\x01C7;ana")
(define Ljubljana "\x01C8;ub\x01C9;ana")
(define ljubljana "\x01C9;ub\x01C9;ana")

(test "string 7" "Bar Baz" (string-titlecase "bAr baZ"))
(test "string 8" "Floo" (string-titlecase "floo"))
(test "string 9" "Floo" (string-titlecase "FLOO"))
(test "string 10" "Floo" (string-titlecase Floo))          ;
(test "string 11" "Floo Bar" (string-titlecase "floo bar"))
(test "string 12" "Floo Bar" (string-titlecase "FLOO BAR"))
(test "string 13" "Floo Bar" (string-titlecase Floo-bar))  ;
(test "string 14" Baffle (string-titlecase Baffle))
(test "string 15" Ljubljana (string-titlecase LJUBLJANA))  ;
(test "string 16" Ljubljana (string-titlecase Ljubljana))
(test "string 17" Ljubljana (string-titlecase ljubljana))  ;

(define str1 "abc")
(define str2 "def")
(test/error "string-append! constant 1" (string-append! "a" "b"))
(test/error "string-append! constant 2" (string-append! "Ã¡bÃ§, unicode!" "bÃ§dÃ©ï¬"))
(test/error "string-append! constant 3" (string-append! str1 "x"))
(test "string-append! constant 3" "abcdef" (string-append! (string-copy str1) str2)) ;  second arg may be constant
(test "string-append! constant 3" "xdef" (string-append! (string-copy "x") str2)) ;  second arg may be constant


;; ----------------------------------------------------------------------
;;  SRFI 141 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 141 - Integer division")

(require "srfi-141")

;; SRFI 141 comes with no tests, so I have ceated a few.

(define nums-dens '( (25 3)
                     (-25 3)
                     (17 3)
                     (-17 3)
                     (29 5)
                     (-29 5)
                     (30 3)
                     (-30 3)
                     (101 80)
                     (-101 80)
                     (101 -80)
                     (100 60)
                     (-100 60) ))

(for-each (lambda (num-den)
            (let ((n (car num-den))
                  (d (cadr num-den)))
              (let ((flq (floor-quotient n d))
                    (flr (floor-remainder n d))
                    (clq (ceiling-quotient n d))
                    (clr (ceiling-remainder n d))
                    (tcq (truncate-quotient n d))
                    (tcr (truncate-remainder n d))
                    (rdq (round-quotient n d))
                    (rdr (round-remainder n d))
                    (euq (euclidean-quotient n d))
                    (eur (euclidean-remainder n d))
                    (blq (balanced-quotient n d))
                    (blr (balanced-remainder n d)))

                (test (format "flq:~d:~d" n d)
                      (floor (/ n d))
                      flq)
                (test (format "flr:~d:~d" n d)
                     (- n (* flq d))
                     flr)

                (test (format "clq:~d:~d" n d)
                      (ceiling (/ n d))
                      clq)
                (test (format "clr:~d:~d" n d)
                      (- n (* clq d))
                      clr)

                (test (format "trlq:~d:~d" n d)
                      (truncate (/ n d))
                      tcq)
                (test (format "trr:~d:~d" n d)
                      (- n (* tcq d))
                      tcr)

                (test (format "rdq:~d:~d" n d)
                      (round (/ n d))
                      rdq)
                (test (format "rdr:~d:~d" n d)
                      (- n (* rdq d))
                      rdr)

                (test (format "euq:~d:~d" n d)
                      (if (positive? d)
                          (floor (/ n d))
                          (ceiling (/ n d)))
                      euq)
                (test (format "eur3:~d:~d" n d)
                      #t
                      (< eur (abs d)))
                (test (format "eur2:~d:~d" n d)
                      #t
                      (>= eur 0))
                (test (format "eur:~d:~d" n d)
                      (- n (* euq d))
                      eur)

                (test (format "blr1:~d:~d" n d)
                      #t
                      (< blr (abs (/ d 2))))
                (test (format "blr2:~d:~d" n d)
                      #t
                      (>= blr (- (abs (/ d 2)))))
                (test (format "blr:~d:~d" n d)
                      (- n (* blq d))
                      blr))))
          nums-dens)

;; ----------------------------------------------------------------------
;;  SRFI 156 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 156 - Syntactic combiners for binary predicates")

(require "srfi-156")


;; the tests were translated from the original SRFI reference implementation

(test "" #t
 (is 1 odd?))

(test "" #t
 (isnt 2 odd?))

(test "" #t
 (is '() null?))

(test "" #t
 (is procedure? procedure?))

(test "" #t
 (isnt 5 procedure?))

;; two arguments:

(test "" #t
 (is 1 < 2))

(test "" #t
 (isnt 1 < 1))

(test "" #t
 (is (+ 2 2) = 4))

(test "" #t
 (is 'x eq? 'x))

(test "" #t
 (is procedure? eq? procedure?))

(test "" #t
 (eq? (is eq? eq? eq?)
      (eq? eq? eq?)))

(test "" #t
 (is (is eq? eq? eq?) eq? (eq? eq? eq?)))

(test "" '(y z)
 (is 'y memq '(x y z)))

(test "" '((1) (2) (1 2))
 (is '(1) member '(() (1) (2) (1 2))))

(test "" #t
 (isnt 'x eq? 'y))

(test "" #t
 (is '(a b c) equal? '(a b c)))

(test "" #t
 (isnt '(a b c) equal? '(c b a)))

(test "" #t
 (is 0 = 0.0))

(test "" #t
 (is 1.0 = 1))

(test "" #t
 (isnt 1 = 0))

(define (divisible-by? x y)
  (is (modulo x y) = 0))

(test "" #t
 (is 9 divisible-by? 3))

(test "" #t
 (isnt 3 divisible-by? 9))

;; ending with unary predicate:

(test "" #t
 (is 1 < 2 even?))

(test "" #t
 (isnt 1 < 2 odd?))

(test "" #t
 (isnt 2 < 1 even?))

(test "" #t
 (is 0 = 0.0 zero?))

(test "" #t
 (isnt 1.0 = 1 zero?))

;; three arguments:

(test "" #t
 (is 1 < 2 <= 3))

(test "" #t
 (is 0 = 0.0 = 0+0i = 0.0+0.0i))

(test "" #t
 (isnt 1 <= 2 < 2))

;; predicates don't need to be transitive
;; (although that's not particularly elegant):

(test "" #t
 (is 1 < 2 > 1.5))

(test "" #t
 (isnt 1 < 2 > 3))

(test "" #t
 (isnt 3 < 2 < 1))

(test "" '((x y) (y x))
 (is 'x member '(x y) member '((x y) (y x))))

;; more arguments:

(test "" #t
 (is -0.4 < -0.1 <= 0 = 0.0 < 0.1 < 0.4))

(test "" #t
 (isnt -0.4 < -0.1 <= 0 = 0.0 < 0.1 < -0.1))

(test "" #t
 (is 0 = 0.0 = 0+0i = 0.0+0.0i = (+) < (*) = 1 = 1.0 = 1+0i = 1.0+0.0i))

;; ending with unary predicate:

(test "" #t
 (is -0.4 < -0.1 <= 0 <= 0.0 < 0.1 < 0.4 <= 2 even?))

(test "" #t
 (isnt -0.4 < -0.1 <= 0 <= 0.0 < 0.1 < 0.4 <= 2 odd?))

;; as procedures (with underscore):

(test "" #t
 (equal? (filter (isnt _ even?) '(2 4 5 6 7 8))
     '(5 7)))

(test "" #t
 (equal? (filter (is _ < 2) '(1 3 2 0))
     '(1 0)))

(test "" #t
 (equal? (filter (is 1 < _) '(1 3 2 0))
     '(3 2)))

(test "" #t
 (equal? (filter (is 3 < _ <= 5) '(2 3 4 5 6 7))
     '(4 5)))

(test "" #t
 (equal? (filter (is 'x memq _) '((a b) (x) (p q) (x y) (c d) (z x)))
     '((x) (x y) (z x))))

(test "" #t
 (equal? (filter (isnt 'x memq _) '((a b) (x) (p q) (x y) (c d) (z x)))
     '((a b) (p q) (c d))))

(test "" #t
 (equal? (filter (isnt 3 < _ <= 5) '(2 3 4 5 6 7))
     '(2 3 6 7)))

(test "" #t
 (equal? (filter (is _ eq? 'a) '(m a m a))
     '(a a)))

(test "" #t
 (equal? (filter (isnt 'a eq? _) '(m a m a))
     '(m m)))

;; multiple underscores:

(test "" #t
 ((is _ < 2 < _) 1 3))

(test "" #t
 ((isnt 1 < _ <= _ < 3) 2 4))

(test "" #t
 ((is _ < _ even?) 1 2))

(test "" #t
 ((isnt _ < _ odd?) 1 2))

(test "" #t
 ((is 1 < _ <= 3 < _ <= 5 < _) 3 5 6))

(test "" #t
 ((isnt 1 < _ <= 3 < _ <= 5 < _) 3 3 6))

(test "" #t
 ((is 1 < _ <= 3 < _ <= 5 < _ even?) 3 5 6))

(test "" #t
 ((isnt 1 < _ <= 3 < _ <= 5 < _ odd?) 3 5 6))

;; ----------------------------------------------------------------------
;;  SRFI 158 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 158 - generators")

(require "srfi-158")


(test "iota-simple" (generator->list (make-iota-generator 3 8)) '(8 9 10))
(test "iota-step" (generator->list (make-iota-generator 3 8 2)) '(8 10 12))
(test "range-simple" (generator->list (make-range-generator 3) 4) '(3 4 5 6))
(test "range-upper-limit" (generator->list (make-range-generator 3 8)) '(3 4 5 6 7))
(test "range-upper-limit-step" (generator->list (make-range-generator 3 8 2)) '(3 5 7))

(define g
  (make-coroutine-generator
   (lambda (yield) (let loop ((i 0))
                (when (< i 3) (yield i) (loop (+ i 1)))))))
(test "coroutine-generator" (generator->list g) '(0 1 2))

(test "list->generator" (generator->list (list->generator '(1 2 3 4 5))) '(1 2 3 4 5))
(test "vector->generator" (generator->list (vector->generator '#(1 2 3 4 5))) '(1 2 3 4 5))
(test "reverse-vector->generator" (generator->list (reverse-vector->generator '#(1 2 3 4 5))) '(5 4 3 2 1))
(test "string->generator" (generator->list (string->generator "abcde")) '(#\a #\b #\c #\d #\e))
(test "vector->generator-start" (generator->list (vector->generator '#(a b c d e) 2)) '(c d e))
(test "vector->generator-start-end" (generator->list (vector->generator '#(a b c d e) 2 4)) '(c d))
(test "reverse-vector->generator-start" (generator->list (reverse-vector->generator '#(a b c d e) 2)) '(e d c))
(test "reverse-vector->generator-start-end" (generator->list (reverse-vector->generator '#(a b c d e) 2 4)) '(d c))
(test "reverse-vector->generator-start-end-2" (generator->list (reverse-vector->generator '#(a b c d e) 0 2)) '(b a))

(test "make-unfold-generator" (generator->list (make-unfold-generator
                                                (lambda (s) (> s 5))
                                                (lambda (s) (* s 2))
                                                (lambda (s) (+ s 1))
                                                0))
      '(0 2 4 6 8 10))

(test "gcons*" (generator->list (gcons* 'a 'b (make-range-generator 0 2))) '(a b 0 1))
(test "gappend" (generator->list (gappend (make-range-generator 0 3) (make-range-generator 0 2))) '(0 1 2 0 1))
(test "gappend-2" (generator->list (gappend)) '())
(test "gmap"    (generator->list (gmap - (make-range-generator 0 3))) '(0 -1 -2))
(test "gmap-2"  (generator->list (gmap cons (generator 1 2 3) (generator 4 5))) '((1 . 4) (2 . 5)))
(test "gdelete" (generator->list (gdelete 3 (generator 1 2 3 4 5 3 6 7))) '(1 2 4 5 6 7))
(test "gdelete-neighbor-dups" (generator->list (gdelete-neighbor-dups (list->generator '(a a b c a a a d c)))) '(a b c a d c))
(test "gindex" (generator->list (gindex (list->generator '(a b c d e f))
                                        (list->generator '(0 2 4))))
      '(a c e))
(test "gselect" (generator->list (gselect (list->generator '(a b c d e f))
                                          (list->generator '(#t #f #f #t #t #f))))
      '(a d e))


;; ----------------------------------------------------------------------
;;  SRFI 161 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 161 - Unifiable Boxes")

(require "srfi-161")

(define a (ubox 'a))
(define b (ubox 'b))
(define c (ubox 'c))
(define d (ubox 'd))
(define e (ubox 'e))
(define f (ubox 'f))


(test "ubox?" #t (ubox? (ubox 'g)))

(test "ubox?, 2" #f (ubox? (vector 'h)))

(test "ubox=?" #f (ubox=? a b))

(test "ubox-ref"
      #t
      (eq? 'a (ubox-ref a)))

(ubox-link! a b)
(ubox-union! a c)
(ubox-unify! cons d e)
(ubox-link! b f)

(test "ubox=?" #t (ubox=? a b))
(test "ubox=?" #t (ubox=? b c))
(test "ubox=?" #t (ubox=? c f))
(test "ubox=?" #t (ubox=? a f))
(test "ubox=?" #t (ubox=? d e))
(test "ubox=?" #f (ubox=? a e))

(test "ubox-ref, eq?" #t (eq? (ubox-ref a) 'f))
(test "ubox-ref, equal?" #t (equal? (ubox-ref d) '(d . e)))

(ubox-set! b 'i)

(test "ubox-set!" #t (eq? (ubox-ref a) 'i))

(ubox-link! a e)

(test "ubox-link!" #t (ubox=? c e))


;; ----------------------------------------------------------------------
;;  SRFI 169 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 169 - Underscores in numbers")

;; bin
(test "binary" 201 (read-from-string "#b11001001"))
(test "binary" 201 (read-from-string "#b1_1_0_0_1_0_0_1"))
(test "binary" 201 (read-from-string "#b1_1001001"))
(test "binary" 201 (read-from-string "#b110_01001"))
(test "binary" 201 (read-from-string "#b1100100_1"))

(test/error "binary, leading _"  (read-from-string "#b_11001001"))
(test/error "binary, trailing _" (read-from-string "#b11001001_"))
(test/error "binary, #_b"        (read-from-string "#_b11001001"))
(test/error "binary, double _"   (read-from-string "#b1100__1001"))

;; if it begins with _, it's a symbol!
(test "binary, _#b"  #t (symbol? (read-from-string "_#b11001001")))

;; hex
(test "hex" 4194308277 (read-from-string "#xfa0010b5"))
(test "hex, several _" 4194308277 (read-from-string "#xf_a_0_0_1_0_b_5"))
(test "hex, left _" 4194308277 (read-from-string "#xf_a0010b5"))
(test "hex, right _" 4194308277 (read-from-string "#xfa0010b_5"))
(test "hex, middle _" 4194308277 (read-from-string "#xfa0_010b5"))

(test/error "hex, leading _"  (read-from-string "#x_fa0010b5"))
(test/error "hex, trailing _" (read-from-string "#xfa0010b5_"))
(test/error "hex, #_x"        (read-from-string "#_xfa0010b5"))
(test/error "hex, double _"   (read-from-string "#xfa0__010b5"))

;; if it begins with _, it's a symbol!
(test "hex, _#x" #t (symbol? (read-from-string "_#xfa0010b5")))

;; from the SRFI
;; integers
(test "int" 123 (read-from-string "0123"))
(test "int, three underscores" 123 (read-from-string "0_1_2_3"))
(test "int, one underscore I" 123 (read-from-string "0_123"))
(test "int, one underscore II" 123 (read-from-string "01_23"))
(test "int, one underscore III" 123 (read-from-string "012_3"))
(test "int, signed+, no underscore" 123 (read-from-string "+0123"))
(test "int, signed+, one underscore" 123 (read-from-string "+0_123"))
(test "int, signed-, no underscore" -123 (read-from-string "-0123"))
(test "int, signed-, one underscore" -123 (read-from-string "-0_123"))


(test "int, leading _" #f (number? (read-from-string "_0123")))
(test "int, trailing _" #f (number? (read-from-string "0123_")))
(test "int, trailing double _" #f (number? (read-from-string "0123__")))
(test "int, double _" #f (number? (read-from-string "01__23")))
(test "int, several _" #f (number? (read-from-string "0_1__2___3")))
(test "int, _ after sign+" #f (number? (read-from-string "+_0123")))
(test "int, signed+, trailing _" #f (number? (read-from-string "+0123_")))
(test "int, after sign-" #f (number? (read-from-string "-_0123")))
(test "int, signed-, trailing _" #f (number? (read-from-string "-0123_")))

;; reals
(test "real" 123.456 (read-from-string "123.456"))
(test "real, 4 underscores" 123.456 (read-from-string "0_1_23.4_5_6"))
(test "real, exp-notation" 123.5e6 (read-from-string "1_2_3.5e6"))
(test "real, exp-notation" 12e12 (read-from-string "1_2e1_2"))

(test "real, leading _" #f (number? (read-from-string "_0123.456")))
(test "real, _." #f (number? (read-from-string "0123_.456")))
(test "real, ._" #f (number? (read-from-string "0123._456")))
(test "real, trailing _" #f (number? (read-from-string "0123.456_")))
(test "real, _., exp-notation" #f (number? (read-from-string "123_.5e6" )))
(test "real, ._, exp-notation" #f (number? (read-from-string "123._5e6" )))
(test "real, _e" #f (number? (read-from-string "123.5_e6" )))
(test "real, e_" #f (number? (read-from-string "123.5e_6" )))
(test "real, trailing _, exp-notation" #f (number? (read-from-string "123.5e6_" )))
(test "real, _e, no dot" #f (number? (read-from-string "12_e12"   )))
(test "real e_, no dot" #f (number? (read-from-string "12e_12"   )))
(test "real, trailing _, no dot" #f (number? (read-from-string "12e12_"   )))

(test "octal, two _"  80247 (read-from-string "#o23_45_67"))
(test "int, #d, two _" 456789 (read-from-string "#d45_67_89"))
(test "hex, negative" -32 (read-from-string "#x-2_0"))
(test "octal, signed, two _" 10030 (read-from-string "#o+2_345_6"))

(test/error "hex, #x-_"  (read-from-string "#x-_2"))
(test "_#x-_"  #t (symbol? (read-from-string "_#x-_2")))
(test/error "#d_"   (read-from-string "#d_45_67_89"))
(test/error "#e_"  (read-from-string "#e_45/67_89"))
(test/error "#i#o_"  (read-from-string "#i#o_1234"))
(test/error "#i_#o_" (read-from-string "#i_#o_1234"))
(test/error "trailing _" (read-from-string "#e#x1234_"))

;; ---------------------------------------------------------------------
;;  SRFI 171 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 171 - Transducers")

(require "srfi-1")
(require "srfi-66")
(require "srfi-69")
(require "srfi-171")

(define (add1 x) (+ x 1))

(define numeric-list (iota 5))
(define numeric-vec (list->vector numeric-list))
(define bv (list->u8vector numeric-list))
(define test-string "0123456789abcdef")
(define list-of-chars (string->list test-string))

;; for testing all treplace variations
(define replace-alist '((1 . s) (2 . c) (3 . h) (4 . e) (5 . m)))
(define stklos-hashtable (%old-alist->hash-table replace-alist eq? md5sum))
(define srfi69-hashtable (alist->hash-table replace-alist))
;;(define rnrs-hashtable (rnrs:make-eq-hashtable))

;; No rnrs hashtables
;; (rnrs:hashtable-set! rnrs-hashtable 1 's)
;; (rnrs:hashtable-set! rnrs-hashtable 2 'c)
;; (rnrs:hashtable-set! rnrs-hashtable 3 'h)
;; (rnrs:hashtable-set! rnrs-hashtable 4 'e)
;; (rnrs:hashtable-set! rnrs-hashtable 5 'm)

(define (replace-function val)
  (case val
    ((1) 's)
    ((2) 'c)
    ((3) 'h)
    ((4) 'e)
    ((5) 'm)
    (else val)))

;; Test procedures for port-transduce
;; broken out to properly close port
(define (port-transduce-test)
  (let* ((port (open-input-string "0 1 2 3 4"))
        (res (equal? 15 (port-transduce (tmap add1) + read
                                        (open-input-string "0 1 2 3 4")))))
    (close-port port)
    res))
(define (port-transduce-with-identity-test)
  (let* ((port (open-input-string "0 1 2 3 4"))
         (res (equal? 15 (port-transduce (tmap add1)
                                         +
                                         0
                                         read
                                         (open-input-string "0 1 2 3 4")))))
    (close-port port)
    res))


;;; helpers:


  (define (compose . functions)
    (define (make-chain thunk chain)
      (lambda args
        (call-with-values (lambda () (apply thunk args)) chain)))
    (if (null? functions)
        values
        (fold make-chain (car functions) (cdr functions))))


;; "transducers"


(test "tmap"
      '(1 2 3 4 5)
      (list-transduce (tmap add1)
                      rcons
                      numeric-list))

(test "tfilter"
      '(0 2 4)
      (list-transduce (tfilter even?)
                      rcons
                      numeric-list))

(test "tfilter+tmap"
      '(1 3 5)
      (list-transduce (compose (tfilter even?) (tmap add1))
                      rcons
                      numeric-list))

(test "tfilter-map"
      '(1 3 5)
      (list-transduce (tfilter-map
                       (lambda (x)
                         (if (even? x)
                             (+ x 1)
                             #f)))
                      rcons numeric-list))

(test "tremove"
      (list-transduce (tremove char-alphabetic?)
                      rcount
                      list-of-chars)
      (string-transduce (tremove char-alphabetic?)
                        rcount
                        test-string))

(test "treplace with alist"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace replace-alist)
                      rcons
                      '(1 2 3 4 5 4 r o c k s) ))

(test "treplace with replace-function"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace replace-function)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

(test "treplace with STklos hash-table"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace stklos-hashtable)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

(test "treplace with srfi-69 hash-table"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace srfi69-hashtable)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

;; STklos has no RNRS hashtables, so we comment this out.
;;
;; (test "treplace with rnrs hash-table"
;;       '(s c h e m e  r o c k s)
;;       (list-transduce (treplace rnrs-hashtable)
;;                       rcons
;;                       '(1 2 3 4 5 4 r o c k s)))

(test "ttake"
      6 (list-transduce (ttake 4) + numeric-list))

(test "tdrop"
      7 (list-transduce (tdrop 3) + numeric-list))

(test "tdrop-while"
      '(3 4)
      (list-transduce (tdrop-while (lambda (x) (< x 3)))
                      rcons
                      numeric-list))

(test "ttake-while"
      '(0 1 2)
      (list-transduce (ttake-while (lambda (x) (< x 3)))
                      rcons
                      numeric-list))

(test "tconcatenate"
      '(0 1 2 3 4) (list-transduce tconcatenate
                                   rcons
                                   '((0 1) (2 3) (4))))

(test "tappend-map"
      '(1 2 2 4 3 6)
      (list-transduce (tappend-map (lambda (x) (list x (* x 2))))
                      rcons
                      '(1 2 3)))

(test "tdelete-neighbor-duplicates"
      '(1 2 1 2 3)
      (list-transduce (tdelete-neighbor-duplicates)
                      rcons
                      '(1 1 1 2 2 1 2 3 3)))

(test "tdelete-neighbor-duplicates with equality predicate"
      '(a b c "hej" "hej")
      (list-transduce (tdelete-neighbor-duplicates eq?)
                      rcons
                      (list 'a 'a 'b 'c 'c "hej" (string #\h #\e #\j))))

(test "tdelete-duplicates"
      '(1 2 3 4)
      (list-transduce (tdelete-duplicates)
                      rcons
                      '(1 1 2 1 2 3 3 1 2 3 4)))

(test "tdelete-duplicates with predicate"
      '("hej" "hopp")
      (list-transduce (tdelete-duplicates string-ci=?)
                      rcons
                      (list "hej" "HEJ" "hopp" "HOPP" "heJ")))

;; added by jpellegrini:
(test "tdelete-duplicates with string=?"
      '("hej" "HEJ" "hopp" "HOPP")
      (list-transduce (tdelete-duplicates string=?)
                      rcons
                      (list "hej" "HEJ" "hopp" "HOPP" "hej")))

(test "tflatten"
      '(1 2 3 4 5 6 7 8 9)
      (list-transduce tflatten rcons '((1 2) 3 (4 (5 6) 7) 8 (9))))

(test "tpartition"
      '((1 1 1 1) (2 2 2 2) (3 3 3) (4 4 4 4))
      (list-transduce (tpartition even?)
                      rcons
                      '(1 1 1 1 2 2 2 2 3 3 3 4 4 4 4)))

(test "tsegment"
      '((0 1) (2 3) (4))
      (vector-transduce (tsegment 2) rcons numeric-vec))

(test "tadd-between"
      '(0 and 1 and 2 and 3 and 4)
      (list-transduce (tadd-between 'and) rcons numeric-list))

(test "tenumerate"
      '((-1 . 0) (0 . 1) (1 . 2) (2 . 3) (3 . 4))
      (list-transduce (tenumerate (- 1)) rcons numeric-list))


;; "x-transduce"

(test "list-transduce"
      15 (list-transduce (tmap add1) + numeric-list))

(test "list-transduce with identity"
      15 (list-transduce (tmap add1) + 0 numeric-list))

(test "vector-transduce"
      15 (vector-transduce (tmap add1) + numeric-vec))

(test "vector-transduce with identity"
      15
      (vector-transduce (tmap add1) + 0 numeric-vec))

(test "port-transduce" #t (port-transduce-test))
(test "port-transduce with identity" #t (port-transduce-with-identity-test))

;; Converts each numeric char to it's corresponding integer  and sums them.
(test "string-transduce"
      15
      (string-transduce (tmap (lambda (x) (- (char->integer x) 47))) + "01234"))

(test "string-transduce with identity"
      15
      (string-transduce  (tmap (lambda (x) (- (char->integer x) 47)))
                         +
                         0
                         "01234"))

(test "generator-transduce"
      '(1 2 3)
      (with-input-from-string "1 2 3"
        (lambda () (generator-transduce (tmap (lambda (x) x)) rcons read))))

(test "generator-transduce with identity"
      '(1 2 3)
      (with-input-from-string "1 2 3"
        (lambda () (generator-transduce (tmap (lambda (x) x)) rcons '() read))))

(test "bytevector-u8-transduce"
      15 (bytevector-u8-transduce (tmap add1) + bv))

(test "bytevector-u8-transduce with identity"
      15 (bytevector-u8-transduce (tmap add1) + 0 bv))

;; ----------------------------------------------------------------------
;;  SRFI 173 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 173 - Hooks")

(require "srfi-173")

(test "make-hook type" (hook? (make-hook 2)) #t)

(define hook (make-hook 2))
(define hook-sum-var 0)
(define hook-prod-var 1)
(define (hook-prod x y)
  (set! hook-prod-var (* x y)))

(hook-add! hook (lambda (x y) (set! hook-sum-var (+ x y))))
(hook-add! hook hook-prod)

(test "add-hook!+run-hook" '(8 15)
      (begin
        (hook-run hook 3 5)
        (list hook-sum-var hook-prod-var)))

(define list-from-hook (hook->list hook))

(test "hook->list" #t (list? list-from-hook))
(test "hook->list length" 2 (length list-from-hook))
(test "hook->list element types" #f (member #f (map procedure? list-from-hook)))

(hook-delete! hook hook-prod)
(set! list-from-hook (hook->list hook))
(test "hook-delete!" #f (member hook-prod (hook->list hook)))
(test "hook->list length after delete 1 proc" 1 (length list-from-hook))

(hook-reset! hook)
(set! list-from-hook (hook->list hook))
(test "hook-reset!" 0 (length list-from-hook))

;; these three will be changed by the hook:
(define hook-arith-var 0)
(define hook-geom-var 0)
(define hook-harmo-var 0)
;; define the following two as zero. the procs that changed their values
;; were removed, so they should NOT be altered.
(set! hook-sum-var 0)
(set! hook-prod-var 1)

;; three procedures:
(define (arith-mean x y) (set! hook-arith-var (/ (+ x y) 2)))
(define (geom-mean x y)  (set! hook-geom-var  (sqrt (* x y))))
(define (harmo-mean x y) (set! hook-harmo-var (/ 1 (+ x y))))

(list->hook! hook (list arith-mean geom-mean harmo-mean))
(test "list->hook! - length of list" 3 (length (hook->list hook)))
(test "add-hook!+run-hook after list->hook"  (list 4 (sqrt 15) 1/8 0 1)
      (begin
        (hook-run hook 3 5)
        (list hook-arith-var
              hook-geom-var
              hook-harmo-var
              hook-sum-var
              hook-prod-var)))

;;  SRFI 176 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 176 - Version flag")

(test "version-alist is list" #t (list? (version-alist)))
(test "scheme.id stklos" 'stklos (cadr (assoc 'scheme.id (version-alist))))
(test "version" (version) (cadr (assoc 'version (version-alist))))
(test "version" (features) (cdr (assoc 'scheme.features (version-alist))))

;; ----------------------------------------------------------------------
;;  SRFI 174 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 174 - POSIX Timespecs")

(require "srfi-174")

(define ts1 (timespec 1 2))
(define ts2 (timespec 1 2))
(define ts3 (timespec 1 3))
(define ts4 (timespec 2 2))
(define ts-neg1 (timespec -1 2))
(define ts-neg2 (timespec -1 5))
(define ts-neg3 (timespec -2 0))


(test "timespec?" #t (timespec? ts1))
(test "not timespec?" #t (not (timespec? #f)))
(test "seconds" 1 (timespec-seconds ts1))
(test "nanos" 2 (timespec-nanoseconds ts1))
(test "equal" #t (timespec=? ts1 ts2))
(test "less nanos" #t (timespec<? ts1 ts3))
(test "less seconds" #t (timespec<? ts1 ts4))
(test "less -nanos" #t (timespec<? ts-neg2 ts-neg1))
(test "less -seconds" #t (timespec<? ts-neg3 ts-neg2))
(test "positive hash" #t (positive? (timespec-hash ts-neg1)))
(test "to inexact" #i1.1 (timespec->inexact (timespec 1 #e1e8)))
(let ((t (timespec 1 1))
      (u (inexact->timespec #i1.000000001)))
  (test "from inexact" t u))

;; ----------------------------------------------------------------------
;;  SRFI 175 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 175 - ASCII character library")

(require "srfi-175")


(test "ascii 1" #f (ascii-codepoint? -1))
(test "ascii 2" #t (ascii-codepoint? 0))
(test "ascii 3" #t (ascii-codepoint? #x7f))
(test "ascii 4" #f (ascii-codepoint? #x80))

(test "ascii 5" #t (ascii-char? (integer->char 0)))
(test "ascii 6" #t (ascii-char? (integer->char #x7f)))
(test "ascii 7" #f (ascii-char? (integer->char #x80)))

(test "ascii 8" #t (ascii-string? ""))
(test "ascii 9" #t (ascii-string? "a"))
(test "ascii 10" #t (ascii-string? "a b c"))
(test "ascii 11" #f (ascii-string? "Ã¥ b o"))
(test "ascii 12" #t (ascii-string? (make-string 1 (integer->char #x7f))))
(test "ascii 13" #f (ascii-string? (make-string 1 (integer->char #x80))))

(test "ascii 14" #t (ascii-bytevector? (string->utf8 "")))
(test "ascii 15" #t (ascii-bytevector? (string->utf8 "a")))
(test "ascii 16" #t (ascii-bytevector? (string->utf8 "a b c")))
(test "ascii 17" #f (ascii-bytevector? (string->utf8 "Ã¥ b o")))
(test "ascii 18" #t (ascii-bytevector?
          (string->utf8 (make-string 1 (integer->char #x7f)))))
(test "ascii 19" #f (ascii-bytevector?
          (string->utf8 (make-string 1 (integer->char #x80)))))

(test "ascii 20" #t (ascii-non-control? #\space))
(test "ascii 21" #f (ascii-non-control? #\tab))
(test "ascii 22" #f (ascii-non-control? #\newline))
(test "ascii 23" #f (ascii-non-control? (integer->char #x0d)))

(test "ascii 24" #t (ascii-space-or-tab? #\space))
(test "ascii 25" #t (ascii-space-or-tab? #\tab))
(test "ascii 26" #f (ascii-space-or-tab? #\newline))
(test "ascii 27" #f (ascii-non-control? (integer->char #x0d)))

(test "ascii 28" #f (ascii-non-control? (integer->char #x00)))
(test "ascii 29" #f (ascii-non-control? (integer->char #x1f)))
(test "ascii 30" #t (ascii-non-control? (integer->char #x20)))
(test "ascii 31" #t (ascii-non-control? (integer->char #x7e)))
(test "ascii 32" #f (ascii-non-control? (integer->char #x7f)))
(test "ascii 33" #f (ascii-non-control? (integer->char #x80)))

(let ((lowers "abcdefghijklmnopqrstuvwxyz")
      (uppers "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
  (let loop ((i 0))
    (when (< i 26)
      (let ((lower (string-ref lowers i))
            (upper (string-ref uppers i)))
        (test "ascii 34" upper (ascii-upcase upper))
        (test "ascii 35" upper (ascii-upcase lower))
        (test "ascii 36" lower (ascii-downcase upper))
        (test "ascii 37" lower (ascii-downcase lower))
        (loop (+ i 1))))))

(let loop ((cc 0))
  (when (< cc #x80)
    (unless (ascii-alphabetic? cc)
      (test "ascii 38" cc (ascii-upcase cc))
      (test "ascii 39" cc (ascii-downcase cc)))
    (loop (+ cc 1))))

(let loop ((cc 0))
  (when (< cc #x80)
    (test "ascii 40" #f (ascii-char? cc))
    (test "ascii 41" #t (ascii-char? (integer->char cc)))
    (cond ((ascii-alphabetic? cc)
           (test "ascii 42" #t (ascii-upper-case? (ascii-upcase cc)))
           (test "ascii 43" #t (ascii-lower-case? (ascii-downcase cc)))
           (test "ascii 44" #f (ascii-lower-case? (ascii-upcase cc)))
           (test "ascii 45" #f (ascii-upper-case? (ascii-downcase cc)))
           (test "ascii 46" #t (ascii-alphanumeric? cc))
           (test "ascii 47" #t (ascii-non-control? cc))
           (test "ascii 48" #f (ascii-other-graphic? cc))
           (test "ascii 49" #f (ascii-control? cc))
           (test "ascii 50" #f (ascii-numeric? cc))
           (test "ascii 51" #f (ascii-whitespace? cc))
           (test "ascii 52" #f (ascii-space-or-tab? cc)))
          ((ascii-control? cc)
           (test "ascii 53" #f (ascii-non-control? cc))
           (test "ascii 54" #f (ascii-other-graphic? cc))
           (test "ascii 55" cc
                 (ascii-graphic->control
                  (ascii-control->graphic cc)))
           (test "ascii 56" (integer->char cc)
                 (ascii-graphic->control
                  (ascii-control->graphic (integer->char cc)))))
          ((member cc '(#\( #\) #\[ #\] #\{ #\} #\< #\>))
           (test "ascii 57" cc (ascii-mirror-bracket (ascii-mirror-bracket cc)))))
    (loop (+ cc 1))))

(let outer ((a 0))
  (when (< a 26)
    (let inner ((b 0))
      (if (= b 26)
          (outer (+ a 1))
          (begin (test "ascii 58" (= a b)  (ascii-ci=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 59" (< a b)  (ascii-ci<?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 60" (<= a b) (ascii-ci<=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 61" (> a b)  (ascii-ci>?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 62" (>= a b) (ascii-ci>=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (inner (+ b 1)))))))

(ascii-ci>? #\A #\_)
(ascii-ci>? #\Z #\_)

(test "ascii 63" #f (ascii-char? -1))
(test "ascii 64" #f (ascii-char? #x80))
(test "ascii 65" #f (ascii-char? (integer->char #x80)))

(test "ascii 66" #f (ascii-control? -1))
(test "ascii 67" #t (ascii-control? #x00))
(test "ascii 68" #t (ascii-control? #x1f))
(test "ascii 69" #f (ascii-control? #x20))
(test "ascii 70" #f (ascii-control? #x7e))
(test "ascii 71" #t (ascii-control? #x7f))
(test "ascii 72" #f (ascii-control? #x80))

(test "ascii 73" 0 (ascii-digit-value #\0 10))
(test "ascii 74" 0 (ascii-digit-value #\0 1))
(test "ascii 75" #f (ascii-digit-value #\0 0))
(test "ascii 76" #f (ascii-digit-value #\0 -1))
(test "ascii 77" 7 (ascii-digit-value #\7 8))
(test "ascii 78" #f (ascii-digit-value #\7 7))
(test "ascii 79" #f (ascii-digit-value #\: 10))

(test "ascii 80" 0 (ascii-upper-case-value #\A 0 26))
(test "ascii 81" 25 (ascii-upper-case-value #\Z 0 26))
(test "ascii 82" #f (ascii-upper-case-value #\Z 0 25))

(test "ascii 83" 0 (ascii-lower-case-value #\a 0 26))
(test "ascii 84" 25 (ascii-lower-case-value #\z 0 26))
(test "ascii 85" #f (ascii-lower-case-value #\z 0 25))

(test "ascii 86" 0 (ascii-lower-case-value #\a 0 1))
(test "ascii 87" #f (ascii-lower-case-value #\a 0 0))
(test "ascii 88" #f (ascii-lower-case-value #\a 0 -1))
(test "ascii 89" 9001 (ascii-lower-case-value #\b 9000 2))

(test "ascii 90" #f (ascii-nth-digit -1))
(test "ascii 91" #\0 (ascii-nth-digit 0))
(test "ascii 92" #\9 (ascii-nth-digit 9))
(test "ascii 93" #f (ascii-nth-digit 10))

(test "ascii 94" #\Z (ascii-nth-upper-case -1))
(test "ascii 95" #\A (ascii-nth-upper-case 0))
(test "ascii 96" #\Z (ascii-nth-upper-case 25))
(test "ascii 97" #\A (ascii-nth-upper-case 26))

(test "ascii 98" #\z (ascii-nth-lower-case -1))
(test "ascii 99" #\a (ascii-nth-lower-case 0))
(test "ascii 100" #\z (ascii-nth-lower-case 25))
(test "ascii 101" #\a (ascii-nth-lower-case 26))

(define (count-matching predicates value)
  (let loop ((ps predicates) (n 0))
    (if (null? ps) n (loop (cdr ps) (if ((car ps) value) (+ n 1) n)))))

(define (union? whole . parts)
  (let check ((cc 0))
    (or (= cc #x80)
        (if (and (whole cc) (not (= 1 (count-matching parts cc))))
            #f (check (+ cc 1))))))

(define (subset? small-set . bigger-sets)
  (let check ((cc 0))
    (or (= cc #x80)
        (if (and (small-set cc) (= 0 (count-matching bigger-sets cc)))
            #f (check (+ cc 1))))))

(define (disjoint? . predicates)
  (let check ((cc 0))
    (or (= cc #x80) (and (<= (count-matching predicates cc) 1)
                         (check (+ cc 1))))))

(test "ascii 102" #t (union? ascii-alphanumeric? ascii-alphabetic? ascii-numeric?))
(test "ascii 103" #t (union? ascii-alphabetic? ascii-upper-case? ascii-lower-case?))

(test "ascii 104" #t (subset? ascii-space-or-tab? ascii-whitespace?))
(test "ascii 105" #t (subset? ascii-other-graphic? ascii-non-control?))
(test "ascii 106" #t (subset? ascii-upper-case?   ascii-alphabetic? ascii-non-control?))
(test "ascii 107" #t (subset? ascii-lower-case?   ascii-alphabetic? ascii-non-control?))
(test "ascii 108" #t (subset? ascii-alphabetic?   ascii-alphanumeric? ascii-non-control?))
(test "ascii 109" #t (subset? ascii-numeric?      ascii-alphanumeric? ascii-non-control?))
(test "ascii 110" #t (subset? ascii-alphanumeric? ascii-non-control?))

(test "ascii 111" #t (disjoint? ascii-control? ascii-non-control?))
(test "ascii 112" #t (disjoint? ascii-whitespace?
                    ascii-other-graphic?
                    ascii-upper-case?
                    ascii-lower-case?
                    ascii-numeric?))
(test "ascii 113" #t (disjoint? ascii-control?
                    ascii-other-graphic?
                    ascii-upper-case?
                    ascii-lower-case?
                    ascii-numeric?))

(define (check-string-ci a b cmp)
  (test "ascii 114" (= cmp 0) (ascii-string-ci=? a b))
  (test "ascii 115" (< cmp 0) (ascii-string-ci<? a b))
  (test "ascii 116" (> cmp 0) (ascii-string-ci>? a b))
  (test "ascii 117" (<= cmp 0) (ascii-string-ci<=? a b))
  (test "ascii 118" (>= cmp 0) (ascii-string-ci>=? a b)))

(check-string-ci "" "" 0)
(check-string-ci "a" "a" 0)
(check-string-ci "A" "a" 0)
(check-string-ci "a" "A" 0)

(check-string-ci "a" "b" -1)
(check-string-ci "b" "a" 1)

(check-string-ci "a" "B" -1)
(check-string-ci "B" "a" 1)

(check-string-ci "aa" "aa" 0)
(check-string-ci "aa" "ab" -1)
(check-string-ci "ab" "aa" 1)
(check-string-ci "aa" "aaa" -1)
(check-string-ci "aaa" "aa" 1)


;; ----------------------------------------------------------------------
;;  SRFI 185 ...
;; ----------------------------------------------------------------------

(require "srfi-185")


(test "string-append! ok"  #t (eq? string-append! string-append-linear!))
(test "string-replace! ok" #t (eq? string-replace! string-replace-linear!))

;; srting-append! and string-replace! should now be macros, and they should
;; NOT expand to themselves!
(test "string-append! expansion"
      #f
      (equal? '(string-append! a b c)
              (macro-expand '(string-append! a b c))))

(test "string-replace! expansion"
      #f
      (equal? '(string-replace! dst dst-start dst-end src src-start src-end)
              (macro-expand '(string-replace! dst dst-start dst-end src src-start src-end))))

;; repeat part of SRFI-118 tests here, although nothing should go wrong --
;; the procedures being used here were already tested!
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "(linear) string-append! char, unicode" "Ã¡bcdÃfà¦2345à¼«"
      (begin (string-append! au6 #\à¦ #\2 "345" #\à¼«) au6))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "(linear) string-append! char, unicode, length" 12
      (begin (string-append! au6 #\à¦ #\2 "345" #\à¼«) (string-length au6)))
;; FIXME: Delete this test
;; (set-mutable-string! au6  "Ã¡bcdÃf")
;; (test "(linear) string-append! char, unidoce, eq?" #t (eq? au6 (string-append! au6 #\à¦ #\2 "345" #\à¼«)))

(set-mutable-string! a6 "abcdef")
(test "(linear) string-replace! overlap" "abefef" (begin (string-replace! a6 2 4 a6 4 6) a6))
(set-mutable-string! a6 "abcdef")
(test "(linear) string-replace! overlap length" 6  (begin (string-replace! a6 2 4 a6 4 6)
                                                          (string-length a6)))
;; FIXME: Delete this test
;; (set-mutable-string! a6 "abcdef")
;; (test "(linear) string-replace! overlap eq?" #t  (eq? a6 (string-replace! a6 2 4 a6 4 6)))


;; ----------------------------------------------------------------------
;;  SRFI 180 ...
;;
;; The tests here are a small part of the tests from the sample
;; implementation.
;;
;; Other tests (only for json-read and json-write) are also available
;; in the file "./test-json.stk".
;; ----------------------------------------------------------------------
(test-subsection "SRFI 180 - JSON")

(require "srfi-180")

(test "json-generator.1"
      '(42)
      (call-with-input-string "42 101 1337"
                              (lambda (port) (generator->list (json-generator port)))))
(test "json-generator.2"
      '(array-start 42 array-end)
      (call-with-input-string "[42] 101 1337"
                              (lambda (port) (generator->list (json-generator port)))))
(test "json-error"
      #t
      (with-handler (lambda (e) (json-error? e))
                    (call-with-input-string "{" json-read)))

;; ----------------------------------------------------------------------
;;  SRFI 189 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 189 - Maybe and Either: optional container types")

(require "srfi-189")

(define (identity x) x)


(define-syntax constantly
  (syntax-rules ()
    ((_ obj) (lambda _ obj))))

(define-syntax values->list
  (syntax-rules ()
    ((_ expr)
     (call-with-values (lambda () expr) list))))

(define always (constantly #t))
(define never (constantly #f))


;; Verify that a Maybe is a Just of 'z, a dummy object.
(define (just-of-z? m)
  (and (maybe? m) (maybe= eqv? m (just 'z))))

;; Verify that an Either is a Right of 'z, a dummy object.
(define (right-of-z? e)
  (and (either? e) (either= eqv? e (right 'z))))

;; Verify that an Either is a Left of 'z, a dummy object.
(define (left-of-z? e)
  (and (either? e) (either= eqv? e (left 'z))))

;; CONSTRUCTORS

;; Uniqueness of the Nothing object.
(test "eq? nothing" #t (eq? (nothing) (nothing)))

;; list->just and list->right
(test "list->just and list->right 1" #t (maybe= eqv? (just #t #t) (list->just '(#t #t))))
(test "list->just and list->right 2" #t (either= eqv? (right #t #t) (list->right '(#t #t))))
(test "list->just and list->right 3" #t (either= eqv? (left #t #t) (list->left '(#t #t))))

;; maybe->either and either->maybe
(test "maybe->either and either->maybe 1" #t (left-of-z? (maybe->either (nothing) 'z)))
(test "maybe->either and either->maybe 2" #t (right-of-z? (maybe->either (just 'z) #f)))
(test "maybe->either and either->maybe 3" #t (either= eqv? (right #t #t) (maybe->either (just #t #t) #f)))
(test "maybe->either and either->maybe 4" #t (nothing? (either->maybe (left #t))))
(test "maybe->either and either->maybe 5" #t (just-of-z? (either->maybe (right 'z))))
(test "maybe->either and either->maybe 6" #t (maybe= eqv? (just #t #t) (either->maybe (right #t #t))))

;; either-swap
(test "either-swap 1" #t (either= eqv? (right #t #t) (either-swap (left #t #t))))
(test "either-swap 2" #t (either= eqv? (left #t #t) (either-swap (right #t #t))))

;;;; Predicates

(test "predicates 1" #t (just? (just 'z)))
(test "predicates 2" #f (just? (nothing)))
(test "predicates 3" #f (nothing? (just 'z)))
(test "predicates 4" #t (nothing? (nothing)))
(test "predicates 5" #t (maybe? (just 'z)))
(test "predicates 6" #t (maybe? (nothing)))

(test "predicates 7" #t (right? (right 'z)))
(test "predicates 8" #f (right? (left 'z)))
(test "predicates 9" #f (left? (right 'z)))
(test "predicates 10" #t (left? (left 'z)))
(test "predicates 11" #t (either? (right 'z)))
(test "predicates 12" #t (either? (left 'z)))

(test "predicates 13" #t (maybe= eqv? (just #t) (just #t)))
(test "predicates 14" #f (maybe= eqv? (just #t) (just #f)))
(test "predicates 15" #t (maybe= eqv? (nothing) (nothing)))
(test "predicates 16" #f (maybe= eqv? (just #t) (nothing)))

(test "predicates 17" #t (maybe= eqv? (just #t #f) (just #t #f)))
(test "predicates 18" #f (maybe= eqv? (just #t #f) (just #t 'z)))
(test "predicates 19" #f (maybe= eqv? (just #t #f) (just #t)))

(test "predicates 20" #t (maybe= eqv? (just #t) (just #t) (just #t)))
(test "predicates 21" #t (maybe= eqv? (nothing) (nothing) (nothing)))
(test "predicates 22" #f (maybe= eqv? (just #t) (just #t) (nothing)))
(test "predicates 23" #f (maybe= eqv? (just #t) (just #t) (just #f)))
(test "predicates 24" #t (maybe= eqv? (just #t 'z) (just #t 'z) (just #t 'z)))

(test "predicates 25" #t (either= eqv? (right #t) (right #t)))
(test "predicates 26" #f (either= eqv? (right #t) (right #f)))
(test "predicates 27" #t (either= eqv? (left #t) (left #t)))
(test "predicates 28" #f (either= eqv? (left #t) (left #f)))
(test "predicates 29" #f (either= eqv? (right #t) (left #t)))

(test "predicates 30" #t (either= eqv? (right #t #f) (right #t #f)))
(test "predicates 31" #f (either= eqv? (right #t #f) (right #t 'z)))
(test "predicates 32" #f (either= eqv? (right #t #f) (right #t)))
(test "predicates 33" #t (either= eqv? (left #t #f) (left #t #f)))
(test "predicates 34" #f (either= eqv? (left #t #f) (left #t 'z)))
(test "predicates 35" #f (either= eqv? (left #t #f) (left #t)))
(test "predicates 36" #f (either= eqv? (left #t #f) (right #t #f)))

(test "predicates 37" #t (either= eqv? (right #t) (right #t) (right #t)))
(test "predicates 38" #t (either= eqv? (left #t) (left #t) (left #t)))
(test "predicates 39" #f (either= eqv? (right #t) (right #t) (left #t)))
(test "predicates 40" #f (either= eqv? (right #t) (right #t) (right #f)))
(test "predicates 41" #t (either= eqv? (right #t 'z) (right #t 'z) (right #t 'z)))

;;;; Accessors

(test "accessors 1" #f (maybe-ref (nothing) (lambda () #f)))
(test "accessors 2" #t (maybe-ref (just #t) (lambda () #f) values))
(test "accessors 3" #f (maybe-ref (nothing) (lambda () #f) values))

(test "accessors 4" '(#t #f) (values->list (maybe-ref (just #t #f) (lambda () #f))))
(test "accessors 5" '(#t #f) (maybe-ref (just #t #f) (lambda () #f) list))

(test "accessors 6" #f (either-ref (left #t) (constantly #f)))
(test "accessors 7" #t (either-ref (right #t) (constantly #f) values))
(test "accessors 8" #t (either-ref (left #t) values (constantly #f)))

(test "accessors 9" '(#t #f) (either-ref (right #t #f) (constantly #f) list))
(test "accessors 10" '(#t #f) (either-ref (left #t #f) list (constantly #f)))

(test "accessors 11" #t (maybe-ref/default (just #t) #f))
(test "accessors 12" #f (maybe-ref/default (nothing) #f))
(test "accessors 13" '(#t #t) (values->list (maybe-ref/default (just #t #t) #f #f)))
(test "accessors 14" '(#f #f) (values->list (maybe-ref/default (nothing) #f #f)))

(test "accessors 15" #t (either-ref/default (right #t) #f))
(test "accessors 16" #f (either-ref/default (left #t) #f))
(test "accessors 17" '(#t #t) (values->list (either-ref/default (right #t #t) #f #f)))
(test "accessors 18" '(#f #f) (values->list (either-ref/default (left #t) #f #f)))

;;;; Join and bind

  ;; maybe-join
(test "maybe-join 1" #t (just-of-z? (maybe-join (just (just 'z)))))
(test "maybe-join 2" #t (nothing? (maybe-join (just (nothing)))))
(test "maybe-join 3" #t (nothing? (maybe-join (nothing))))

  ;; either-join
(test "either-join 1" #t (right-of-z? (either-join (right (right 'z)))))
(test "either-join 2" #t (left-of-z? (either-join (right (left 'z)))))
(test "either-join 3" #t (left-of-z? (either-join (left 'z))))

;; maybe-bind
(test "maybe-bind 1" #t (nothing? (maybe-bind (nothing) just)))

(test "maybe-bind 2" #t (just-of-z? (maybe-bind (just 'z) just)))

(test "maybe-bind 3" #t (let ((m (just #t #f)))
           (maybe= eqv? m (maybe-bind m just))))


;; Associativity of bind.
(let ((k (lambda (n) (just (* n 2))))
      (h (lambda (n) (just (+ n 5))))
      (m (just 1)))
  (test "Associativity of bind" #t (maybe= eqv?
                      (maybe-bind m (lambda (n) (maybe-bind (k n) h)))
                      (maybe-bind (maybe-bind m k) h))))


;; Bind with multiple mprocs.
(let ((neg (lambda (b) (just (not b)))))
  (test "Bind with multiple mprocs 1" #t (maybe= eqv? (just #f) (maybe-bind (just #t) neg neg neg)))
  (test "Bind with multiple mprocs 2" #t (nothing? (maybe-bind (just #t) neg (constantly (nothing)) neg))))

;; maybe-compose
(test "maybe-compose 1" #t (nothing? ((maybe-compose (constantly (nothing))) 'z)))
(test "maybe-compose 2" #t (just-of-z? ((maybe-compose just) 'z)))

;; Compose with multiple mprocs.
(let ((neg (lambda (b) (just (not b)))))
  (test "Compose with multiple mprocs" #t (maybe= eqv? (just #t) ((maybe-compose neg neg neg) #f))))

;; either-bind
(test "either-bind 1" #t (left? (either-bind (left #f) right)))

(test "either-bind 2" #t (right-of-z? (either-bind (right 'z) right)))

(test "either-bind 3" #t (let ((e (right #t #f)))
              (either= eqv? e (either-bind e right))))

;; Associativity of bind.
(let ((k (lambda (n) (right (* n 2))))
      (h (lambda (n) (right (+ n 5))))
      (e (right 1)))
  (test "Associativity of bind 2" #t
     (either= eqv? (either-bind e (lambda (n) (either-bind (k n) h)))
                   (either-bind (either-bind e k) h))))

;; Bind with multiple mprocs.
(let ((neg (lambda (b) (right (not b)))))
  (test "Bind with multiple mprocs 3" #t (either= eqv? (right #f) (either-bind (right #t) neg neg neg)))
  (test "Bind with multiple mprocs 4" #t (either= eqv? (left #f) (either-bind (right #t) neg left neg))))

;; either-compose
(test "either-compose" #t (left-of-z? ((either-compose left) 'z)))
(test "either-compose 2" #t (either= eqv? (right #t) ((either-compose right) #t)))

;; Compose with multiple mprocs.
(let ((neg (lambda (b) (right (not b)))))
  (test "Compose with multiple mprocs" #t (either= eqv? (right #t) ((either-compose neg neg neg) #f))))


;;;; Sequence operations

(define (both b c) (and b c))

(test "maybe-length 0" 0 (maybe-length (nothing)))
(test "maybe-length 1" 1 (maybe-length (just #t)))

(test "either-length 0" 0 (either-length (left #t)))
(test "either-length 1" 1 (either-length (right #t)))

;; maybe-filter & maybe-remove
(test "maybe-filter & maybe-remove 1" #t (just-of-z? (maybe-filter always (just 'z))))
(test "maybe-filter & maybe-remove 2" #t (nothing? (maybe-filter never (just #t))))
(test "maybe-filter & maybe-remove 3" #t (nothing? (maybe-filter always (nothing))))

(test "maybe-filter & maybe-remove 4" #t (maybe= eqv? (just #t #t) (maybe-filter both (just #t #t))))

(test "maybe-filter & maybe-remove 5" #t (just-of-z? (maybe-remove never (just 'z))))
(test "maybe-filter & maybe-remove 6" #t (nothing? (maybe-remove always (just #t))))
(test "maybe-filter & maybe-remove 7" #t (nothing? (maybe-remove always (nothing))))

(test "maybe-filter & maybe-remove 8" #t (maybe= eqv? (just #t #f) (maybe-remove both (just #t #f))))

;; maybe-sequence
(test "maybe-sequence" #t
      (maybe= equal? (maybe-sequence (map just '(#t #f)) map identity)
              (just '(#t #f))))

(test "maybe-sequence 2" #t
      (maybe= equal? (maybe-sequence (list (just 1 #t) (just 2 #f))
                                     map
                                     list)
              (just '((1 #t) (2 #f)))))

(test "maybe-sequence 3" #t
      (nothing? (maybe-sequence (list (just #t) (nothing)) map identity)))

;; either-filter & either-remove
(test "either-filter & either-remove" #t (right-of-z? (either-filter always (right 'z) #f)))
(test "either-filter & either-remove 2" #t (left-of-z? (either-filter never (right #t) 'z)))
(test "either-filter & either-remove 3" #t (left-of-z? (either-filter always (left #t) 'z)))

(test "either-filter & either-remove 4" #t
      (either= eqv? (right #t #t) (either-filter both (right #t #t) #f)))

(test "either-filter & either-remove 5" #t (right-of-z? (either-remove never (right 'z) #f)))
(test "either-filter & either-remove 6" #t (left-of-z? (either-remove always (right #t) 'z)))
(test "either-filter & either-remove 7" #t (left-of-z? (either-remove never (left #t) 'z)))

(test "either-filter & either-remove 8"  #t
      (either= eqv? (right #t #f) (either-remove both (right #t #f) #f)))

;; either-sequence
(test "either-sequence 1" #t
      (either= equal? (either-sequence (map right (list 1 2)) map identity)
               (right (list 1 2))))
(test "either-sequence 2" #t
      (left-of-z? (either-sequence (list (right #t) (left 'z)) map identity)))
(test "either-sequence 3" #t
      (either= equal? (either-sequence (list (right 1 #t) (right 2 #f))
                                       map
                                       list)
               (right '((1 #t) (2 #f)))))


;;;; Protocol conversion procedures

(test "maybe->list (nothing)" '() (maybe->list (nothing)))
(test "conversion 2" '(#t #t) (maybe->list (just #t #t)))
(test "conversion 3" '(#t #t) (either->list (right #t #t)))
(test "conversion 4" '(#t #t) (either->list (left #t #t)))

(test "conversion 5" #t (nothing? (list->maybe '())))
(test "conversion 6" #t (just-of-z? (list->maybe '(z))))
(test "conversion 7" #t (left-of-z? (list->either '() 'z)))
(test "conversion 8" #t (right-of-z? (list->either '(z) #f)))

(test "conversion 9" #f (maybe->truth (nothing)))
(test "maybe->truth, just" 'z (maybe->truth (just 'z)))
(test "conversion 11" #f (either->truth (left 'z)))
(test "maybe->truth, right" 'z (either->truth (right 'z)))

(test "conversion 13" #t (nothing? (truth->maybe #f)))
(test "conversion 14" #t (just-of-z? (truth->maybe 'z)))
(test "conversion 15" #t (left-of-z? (truth->either #f 'z)))
(test "conversion 16" #t (right-of-z? (truth->either 'z #f)))

(test "conversion 17" '(z #t) (maybe->list-truth (just 'z #t)))
(test "conversion 18" #f (maybe->list-truth (nothing)))
(test "conversion 19" '(z #t) (either->list-truth (right 'z #t)))
(test "conversion 20" #f (either->list-truth (left 'z)))

(test "conversion 21" #t (just-of-z? (list-truth->maybe '(z))))
(test "conversion 22" #t (nothing? (list-truth->maybe #f)))
(test "conversion 23" #t (right-of-z? (list-truth->either '(z))))
(test "conversion 24" #t (left-of-z? (list-truth->either #f 'z)))

(test "conversion 25" #t (eof-object? (maybe->generation (nothing))))
(test "conversion 26" #t (maybe->generation (just #t)))
(test "conversion 27" #t (nothing? (generation->maybe (eof-object))))
(test "conversion 28" #t (just-of-z? (generation->maybe 'z)))

(test "conversion 29" #t (eof-object? (either->generation (left))))
(test "conversion 30" #t (either->generation (right #t)))
(test "conversion 31" #t (left-of-z? (generation->either (eof-object) 'z)))
(test "conversion 32" #t (right-of-z? (generation->either 'z #f)))

;; maybe->values and friends
(test "maybe->values and friends 1" #t (maybe->values (just #t)))
(test "maybe->values and friends 2" '() (values->list (maybe->values (nothing))))

(test "maybe->values and friends 3" '(#f #f) (values->list (maybe->two-values (nothing))))
(test "maybe->values and friends 4" '(#t #t) (values->list (maybe->two-values (just #t))))

(test "maybe->values and friends 5" #t (just-of-z? (two-values->maybe (lambda () (values 'z #t)))))
(test "maybe->values and friends 6" #t (nothing? (two-values->maybe (lambda () (values 'z #f)))))

(test "maybe->values and friends 7" #t (nothing? (values->maybe (lambda () (values)))))
(test "maybe->values and friends 8" #t (just-of-z? (values->maybe (lambda () 'z))))
(test "maybe->values and friends 9" #t (maybe->values (values->maybe (lambda () #t))))
(test "maybe->values and friends 10" #t (just-of-z? (values->maybe (lambda ()
                                         (maybe->values (just 'z))))))

;; either->values and friends
(test "either->values and friends 1" #t (either->values (right #t)))
(test "either->values and friends 2" '() (values->list (either->values (left 'z))))

(test "either->values and friends 3" #t (left-of-z? (values->either (lambda () (values)) 'z)))
(test "either->values and friends 4" #t (right-of-z? (values->either (lambda () 'z) #f)))
(test "either->values and friends 5" #t (either->values (values->either (lambda () #t) #f)))
(test "either->values and friends 6" #t (right-of-z? (values->either (lambda () (either->values (right 'z))) #f)))

(test "either->values and friends 7" #t (left-of-z? (exception->either symbol? (lambda () (raise 'z)))))
(test "either->values and friends 8" #t (right-of-z? (exception->either symbol? (lambda () 'z))))

(test "guarded" 'z (guard (obj ((symbol? obj) obj))
                     (exception->either number?
                                        (lambda () (raise-continuable 'z)))))

(test "exception->either" #t (either= eqv?
                                      (with-exception-handler
                                          not
                                        (lambda ()
                                          (exception->either string?
                                                             (lambda ()
                                                               (not (raise-continuable #t))))))
                                      (right #t)))


;;;; Map, fold, and unfold

  ;; maybe-map
(test "Map, fold, and unfold 1" #t (nothing? (maybe-map not (nothing))))
(test "Map, fold, and unfold 2" #t (maybe= eqv? (just #f) (maybe-map not (just #t))))

(test "Map, fold, and unfold 3" #t (maybe= eqv? (just #t #f) (maybe-map values (just #t #f))))

;; either-map
  ;; Verify that the result is the same Left (in the sense of eqv?).
(test "Map, fold, and unfold 4" #t (let ((e (left #t))) (eqv? e (either-map not e))))
(test "Map, fold, and unfold 5" #t (either= eqv? (right #f) (either-map not (right #t))))

(test "Map, fold, and unfold 6" #t (let ((e (right #t #f)))
              (either= eqv? e (either-map values e))))

;; maybe-for-each
(test "maybe-for-each 1" #t (let ((x #f))
              (maybe-for-each (lambda (y) (set! x y)) (just #t))
              x))

;; Given Nothing, ensure the proc argument is not executed.
(test "maybe-for-each 2" #f
      (let ((x #f))
        (maybe-for-each (lambda (_) (set! x #t)) (nothing))
        x))

;; either-for-each
(test "either-for-each" #t (let ((x #f))
              (either-for-each (lambda (y) (set! x y)) (right #t))
              x))

;; Given a Left, ensure the proc argument is not executed.
(test "Map, fold, and unfold 10" #f (let ((x #f))
              (either-for-each (lambda (_) (set! x #t)) (left 'z))
              x))

(test "Map, fold, and unfold 11" '() (maybe-fold cons '() (nothing)))
(test "Map, fold, and unfold 12" '(#t) (maybe-fold cons '() (just #t)))
(test "Map, fold, and unfold 13" 24 (maybe-fold * 2 (just 3 4)))

(test "Map, fold, and unfold 14" '() (either-fold cons '() (left #t)))
(test "Map, fold, and unfold 15" '(#t) (either-fold cons '() (right #t)))
(test "Map, fold, and unfold 16" 24 (either-fold * 2 (right 3 4)))

(test "Map, fold, and unfold 17" #t (nothing? (maybe-unfold always not always #f)))
(test "Map, fold, and unfold 18" #t (maybe= eqv? (just #t) (maybe-unfold values not not #f)))
(test "Map, fold, and unfold 19" #t (maybe= eqv? (just #t 'z)
                         (maybe-unfold (lambda (b _) (not b))
                                       values
                                       (lambda (b x) (values (not b) x))
                                       #t
                                       'z)))

(test "Map, fold, and unfold 20" #t (left-of-z? (either-unfold always not always 'z)))
(test "Map, fold, and unfold 21" #t (either= eqv? (right #t) (either-unfold values not not #f)))
(test "Map, fold, and unfold 22" #t (either= eqv? (right #t 'z)
                       (either-unfold (lambda (b _) (not b))
                                      values
                                      (lambda (b x) (values (not b) x))
                                      #t
                                      'z)))





;;;; Trivalent logic

(define (tri-true? m)
  (and (just? m) (maybe-ref/default m 'z)))

(define (tri-false? m)
  (and (just? m) (not (maybe-ref/default m 'z))))

(test "trivalent 1" #t (tri-true? (tri-not (just #f))))
(test "trivalent 2" #t (tri-false? (tri-not (just #t))))
(test "trivalent 3" #t (nothing? (tri-not (nothing))))

(test "trivalent 4" #t (tri-true? (tri=? (just #t) (just 1) (just 'x))))
(test "trivalent 5" #t (tri-true? (tri=? (just #f) (just #f))))
(test "trivalent 6" #t (tri-true? (tri=? (just #f) (just #f))))
(test "trivalent 7" #t (tri-false? (tri=? (just #f) (just #t))))
(test "trivalent 8" #t (tri-false? (tri=? (just #f) (nothing))))

(test "trivalent 9" #t (tri-true? (tri-and (just #t) (just 1) (just 'x))))
(test "trivalent 10" #t (nothing? (tri-and (just #t) (nothing))))
(test "trivalent 11" #t (tri-false? (tri-and (just #f) (just #t))))
(test "trivalent 12" #t (tri-true? (tri-and)))

(test "trivalent 13" #t (tri-false? (tri-or (just #f) (just #f) (just #f))))
(test "trivalent 14" #t (nothing? (tri-or (just #f) (nothing))))
(let ((m-true (just 'x)))
  (test "trivalent 15" #t (maybe= eqv? m-true (tri-or (just #f) m-true))))
(test "trivalent 16" #t (tri-false? (tri-or)))

(test "trivalent 17" #t (nothing? (tri-merge (nothing) (nothing) (nothing))))
(let ((m-true (just 'x)))
  (test "trivalent 18" #t (maybe= eqv? m-true (tri-merge (nothing) m-true))))
(let ((m-false (just #f)))
  (test "trivalent 19" #t (maybe= eqv? m-false (tri-merge (nothing) m-false))))
(test "trivalent 20" #t (nothing? (tri-merge)))

;; ----------------------------------------------------------------------
;;  SRFI 190 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 190 - Coroutine Generators")

(require "srfi-190")

(let ()
  (define g1 (coroutine-generator
           (do ((i 0 (+ i 1)))
               ((<= 5 i))
             (yield i))))

  (define g2 (let ((yield-square (lambda (yield i) (yield (* i i)))))
               (coroutine-generator
                (do ((i 0 (+ i 1)))
                    ((<= 5 i))
                  (yield-square yield i)))))

  (define-coroutine-generator (g3 n)
    (do ((i 0 (+ i 1)))
        ((<= n i))
      (yield i)))

  (test "Coroutine generator.1" '(0 1 2 3 4)
        (generator->list g1))
  (test "Coroutine generator.2" '(0 1 4 9 16)
        (generator->list g2))
  (test "Coroutine generator.3" '(0 1 2 3 4 5 6)
        (generator->list (g3 7))))

;; ----------------------------------------------------------------------
;;  SRFI 193 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI-193 - Command Line")

(let ((val (command-line)))
  (test "command-line validate" #t
        (and (list? val)
               (not (null? val))
               (or (boolean? (car val))
                   (string? (car val)))
               (every string? (cdr val))))
  (test "command-args"
        #t
        (eq? (cdr val)
             (command-args))))

(parameterize ((command-line '("" "1" "2")))
  (test "new command line.1"
        #t
        (let ((val (command-line)))
          (and (not (command-name))
               (equal? '("1" "2")
                       (command-args))))))

(parameterize ((command-line '("../../foo.stk" "1" "2" "3")))
  (test "new command line.2 (suffix must be supressed)"
        #t
        (let ((val (command-line)))
          (and (string=? (command-name) "foo")
               (equal? '("1" "2" "3")
                       (command-args))))))

(parameterize ((command-line '("../../foo.keep" "1" "2" "3")))
  (test "new command line.3 (suddix must be kept)"
        #t
        (let ((val (command-line)))
          (and (string=? (command-name) "foo.keep")
               (equal? '("1" "2" "3")
                       (command-args))))))

;; ----------------------------------------------------------------------
;;  SRFI 195 ...
;; ----------------------------------------------------------------------
;; Tests are in the file test-box.stk


;; ----------------------------------------------------------------------
;;  SRFI 62 ...
;; ----------------------------------------------------------------------
;; Tests have been moved here because test 62.5 breaks Emacs fontification

(test-subsection "SRFI 62 - S-expression comments")

(test "srfi-62.1" 5 (+ 1 #;(* 2 3) 4))
(test "srfi-62.2" '(x z) (list 'x #;'y 'z))
(test "srfi-62.3" 12 (* 3 4 #;(+ 1 2)))
(test "srfi-62.4" 16 (#;sqrt abs -16))

(test "srfi-62.5" '(a e) (list 'a #;(list 'b #;c 'd) 'e))
(test "srfi-62.6" '(a . c) '(a . #;b c))
(test "srfi-62.7" '(a . b) '(a . b #;c))


;; ----------------------------------------------------------------------
(test-section-end)
