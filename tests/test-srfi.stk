;;;;
;;;; test-srfi.stk  -- Test of various SRFIs
;;;;
;;;; Copyright Â© 2005-2020 Erick Gallesio - I3S-CNRS/ESSI <eg@essi.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@essi.fr]
;;;;    Creation date:  4-Aug-2005 10:34 (eg)
;;;; Last file update:  3-Jul-2020 12:17 (jpellegrini) 
;;;;

(require "test")

(test-section "SRFIs")

;; ----------------------------------------------------------------------
;;  SRFI 5 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 5 - A compatible let form ...")

;; A binding list must be a sequence of pairs, and with SRFI-5,
;; these mayy be followed by a SYMBOL and a free list.
;; But it MUST be a symbol!
(test/error "error in bindings"
            (let ((a 1)
                  (b 2)
                  3 4 5)))

;; ;; The two following tests are Andy Gaynor's examples from the SRFI:
 (test "fibonacci"
       55
       (let (fibonacci (n 10) (i 0) (f0 0) (f1 1))
         (if (= i n)
             f0
             (fibonacci n (+ i 1) f1 (+ f0 f1)))))

(test "contrived"
      "345"
      (with-output-to-string
        (lambda ()
          (let (blast (port (current-output-port)) . (x (+ 1 2) 4 5))
            (if (null? x)
                'just-a-silly-contrived-example
                (begin
                  (write (car x) port)
                  (apply blast port (cdr x))))))))

(test "recursive list sum"
      21
      (let (loop (sum 0) (lst '(1 2 3 4 5 6)))
        (if (null? lst)
            sum
            (loop (+ (car lst) sum) (cdr lst)))))

(test "recursive list sum with rest arguments"
      21
      (let (loop (sum 0) . (lst 1 2 3 4 5 6))
        (if (null? lst)
            sum
            (apply loop (+ (car lst) sum) (cdr lst)))))



;; ----------------------------------------------------------------------
;;  SRFI 13 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 13 - String Libraries")

(require "srfi-13")
(require "srfi-14")


(define (fill text)
  (let* ((len (string-length text))
         (max-text-len 60)
         (last-col 70)
         (text (if (> len max-text-len)
                   (begin
                     (set! len max-text-len)
                     (substring text 0 max-text-len))
                   text)))
    (string-append text (make-string (- last-col len) #\.))))

; Tests for SRFI-13 as implemented by the Gauche scheme system.
;;
;;   Copyright (c) 2000-2003 Shiro Kawai, All rights reserved.
;;
;;   Redistribution and use in source and binary forms, with or without
;;   modification, are permitted provided that the following conditions
;;   are met:
;;
;;    1. Redistributions of source code must retain the above copyright
;;       notice, this list of conditions and the following disclaimer.
;;
;;    2. Redistributions in binary form must reproduce the above copyright
;;       notice, this list of conditions and the following disclaimer in the
;;       documentation and/or other materials provided with the distribution.
;;
;;    3. Neither the name of the authors nor the names of its contributors
;;       may be used to endorse or promote products derived from this
;;       software without specific prior written permission.
;;
;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;
;; See http://sourceforge.net/projects/gauche/

(test "string-null?" #f (string-null? "abc"))
(test "string-null?" #t (string-null? ""))
(test "string-every" #t (string-every #\a ""))
(test "string-every" #t (string-every #\a "aaaa"))
(test "string-every" #f (string-every #\a "aaba"))
(test "string-every" #t (string-every char-set:lower-case "aaba"))
(test "string-every" #f (string-every char-set:lower-case "aAba"))
(test "string-every" #t (string-every char-set:lower-case ""))
(test "string-every" #t (string-every (lambda (x) (char-ci=? x #\a)) "aAaA"))
(test "string-every" #f (string-every (lambda (x) (char-ci=? x #\a)) "aAbA"))
(test "string-every" (char->integer #\A)
       (string-every (lambda (x) (char->integer x)) "aAbA"))
(test "string-every" #t
       (string-every (lambda (x) (error "hoge")) ""))
(test "string-any" #t (string-any #\a "aaaa"))
(test "string-any" #f (string-any #\a "Abcd"))
(test "string-any" #f (string-any #\a ""))
(test "string-any" #t (string-any char-set:lower-case "ABcD"))
(test "string-any" #f (string-any char-set:lower-case "ABCD"))
(test "string-any" #f (string-any char-set:lower-case ""))
(test "string-any" #t (string-any (lambda (x) (char-ci=? x #\a)) "CAaA"))
(test "string-any" #f (string-any (lambda (x) (char-ci=? x #\a)) "ZBRC"))
(test "string-any" #f (string-any (lambda (x) (char-ci=? x #\a)) ""))
(test "string-any" (char->integer #\a)
       (string-any (lambda (x) (char->integer x)) "aAbA"))
(test "string-tabulate" "0123456789"
       (string-tabulate (lambda (code)
                          (integer->char (+ code (char->integer #\0))))
                        10))
(test "string-tabulate" ""
       (string-tabulate (lambda (code)
                          (integer->char (+ code (char->integer #\0))))
                        0))
(test "reverse-list->string" "cBa"
       (reverse-list->string '(#\a #\B #\c)))
(test "reverse-list->string" ""
       (reverse-list->string '()))
; string-join : Gauche builtin.
(test "substring/shared" "cde" (substring/shared "abcde" 2))
(test "substring/shared" "cd"  (substring/shared "abcde" 2 4))
(test "string-copy!" "abCDEfg"
       (let ((x (string-copy "abcdefg")))
         (string-copy! x 2 "CDE")
         x))
(test "string-copy!" "abCDEfg"
       (let ((x (string-copy "abcdefg")))
         (string-copy! x 2 "ZABCDE" 3)
         x))
(test "string-copy!" "abCDEfg"
       (let ((x (string-copy "abcdefg")))
         (string-copy! x 2 "ZABCDEFG" 3 6)
         x))

;; From Guile.  Thanks to Mark H Weaver.
(test "string-copy!: overlapping src and dest, moving right"
      "aabce"
      (let ((str (string-copy "abcde")))
	(string-copy! str 1 str 0 3) str))

(test "string-copy!: overlapping src and dest, moving left"
      "bcdde"
      (let ((str (string-copy "abcde")))
	(string-copy! str 0 str 1 4) str))

(test "string-take" "Pete S"  (string-take "Pete Szilagyi" 6))
(test "string-take" ""        (string-take "Pete Szilagyi" 0))
(test "string-take" "Pete Szilagyi" (string-take "Pete Szilagyi" 13))
(test "string-drop" "zilagyi" (string-drop "Pete Szilagyi" 6))
(test "string-drop" "Pete Szilagyi" (string-drop "Pete Szilagyi" 0))
(test "string-drop" ""        (string-drop "Pete Szilagyi" 13))

(test "string-take-right" "rules" (string-take-right "Beta rules" 5))
(test "string-take-right" ""      (string-take-right "Beta rules" 0))
(test "string-take-right" "Beta rules" (string-take-right "Beta rules" 10))
(test "string-drop-right" "Beta " (string-drop-right "Beta rules" 5))
(test "string-drop-right" "Beta rules" (string-drop-right "Beta rules" 0))
(test "string-drop-right" ""      (string-drop-right "Beta rules" 10))

(test "string-pad" "  325" (string-pad "325" 5))
(test "string-pad" "71325" (string-pad "71325" 5))
(test "string-pad" "71325" (string-pad "8871325" 5))
(test "string-pad" "~~325" (string-pad "325" 5 #\~))
(test "string-pad" "~~~25" (string-pad "325" 5 #\~ 1))
(test "string-pad" "~~~~2" (string-pad "325" 5 #\~ 1 2))
(test "string-pad-right" "325  " (string-pad-right "325" 5))
(test "string-pad-right" "71325" (string-pad-right "71325" 5))
(test "string-pad-right" "88713" (string-pad-right "8871325" 5))
(test "string-pad-right" "325~~" (string-pad-right "325" 5 #\~))
(test "string-pad-right" "25~~~" (string-pad-right "325" 5 #\~ 1))
(test "string-pad-right" "2~~~~" (string-pad-right "325" 5 #\~ 1 2))

(test "string-trim"  "a b c d  \n"
       (string-trim "  \t  a b c d  \n"))
(test "string-trim"  "\t  a b c d  \n"
       (string-trim "  \t  a b c d  \n" #\space))
(test "string-trim"  "a b c d  \n"
       (string-trim "4358948a b c d  \n" char-set:digit))

(test "string-trim-right"  "  \t  a b c d"
       (string-trim-right "  \t  a b c d  \n"))
(test "string-trim-right"  "  \t  a b c d  "
       (string-trim-right "  \t  a b c d  \n" (char-set #\newline)))
(test "string-trim-right"  "349853a b c d"
       (string-trim-right "349853a b c d03490" char-set:digit))

(test "string-trim-both"  "a b c d"
       (string-trim-both "  \t  a b c d  \n"))
(test "string-trim-both"  "  \t  a b c d  "
       (string-trim-both "  \t  a b c d  \n" (char-set #\newline)))
(test "string-trim-both"  "a b c d"
       (string-trim-both "349853a b c d03490" char-set:digit))

;; string-fill - in string.scm

(test "string-compare" 5
       (string-compare "The cat in the hat" "abcdefgh"
                       values values values
                       4 6 2 4))
(test "string-compare-ci" 5
       (string-compare-ci "The cat in the hat" "ABCDEFGH"
                          values values values
                          4 6 2 4))

;; TODO: bunch of string= families

(test "string-prefix-length" 5
       (string-prefix-length "cancaNCAM" "cancancan"))
(test "string-prefix-length-ci" 8
       (string-prefix-length-ci "cancaNCAM" "cancancan"))
(test "string-suffix-length" 2
       (string-suffix-length "CanCan" "cankancan"))
(test "string-suffix-length-ci" 5
       (string-suffix-length-ci "CanCan" "cankancan"))

(test "string-prefix?" #t    (string-prefix? "abcd" "abcdefg"))
(test "string-prefix?" #f    (string-prefix? "abcf" "abcdefg"))
(test "string-prefix-ci?" #t (string-prefix-ci? "abcd" "aBCDEfg"))
(test "string-prefix-ci?" #f (string-prefix-ci? "abcf" "aBCDEfg"))
(test "string-suffix?" #t    (string-suffix? "defg" "abcdefg"))
(test "string-suffix?" #f    (string-suffix? "aefg" "abcdefg"))
(test "string-suffix-ci?" #t (string-suffix-ci? "defg" "aBCDEfg"))
(test "string-suffix-ci?" #f (string-suffix-ci? "aefg" "aBCDEfg"))

(test "string-index #1" 4
       (string-index "abcd:efgh:ijkl" #\:))
(test "string-index #2" 4
       (string-index "abcd:efgh;ijkl" (char-set-complement char-set:letter)))
(test "string-index #3" #f
       (string-index "abcd:efgh;ijkl" char-set:digit))
(test "string-index #4" 9
       (string-index "abcd:efgh:ijkl" #\: 5))
(test "string-index-right #1" 4
       (string-index-right "abcd:efgh;ijkl" #\:))
(test "string-index-right #2" 9
       (string-index-right "abcd:efgh;ijkl" (char-set-complement char-set:letter)))
(test "string-index-right #3" #f
       (string-index-right "abcd:efgh;ijkl" char-set:digit))
(test "string-index-right #4" 4
       (string-index-right "abcd:efgh;ijkl" (char-set-complement char-set:letter) 2 5))

(test "string-count #1" 2
       (string-count "abc def\tghi jkl" #\space))
(test "string-count #2" 3
       (string-count "abc def\tghi jkl" char-set:whitespace))
(test "string-count #3" 2
       (string-count "abc def\tghi jkl" char-set:whitespace 4))
(test "string-count #4" 1
       (string-count "abc def\tghi jkl" char-set:whitespace 4 9))
(test "string-contains" 3
       (string-contains "Ma mere l'oye" "mer"))
(test "string-contains" #f
       (string-contains "Ma mere l'oye" "Mer"))
(test "string-contains-ci" 3
       (string-contains-ci "Ma mere l'oye" "Mer"))
(test "string-contains-ci" #f
       (string-contains-ci "Ma mere l'oye" "Meer"))

(test "string-titlecase" "--Capitalize This Sentence."
       (string-titlecase "--capitalize tHIS sentence."))
(test "string-titlecase" "3Com Makes Routers."
       (string-titlecase "3com makes routers."))
(test "string-titlecase!" "alSo Whatever"
       (let ((s (string-copy "also whatever")))
         (string-titlecase! s 2 9)
         s))

(test "string-upcase" "SPEAK LOUDLY"
       (string-upcase "speak loudly"))
(test "string-upcase" "PEAK"
       (string-upcase "speak loudly" 1 5))
(test "string-upcase!" "sPEAK loudly"
       (let ((s (string-copy "speak loudly")))
         (string-upcase! s 1 5)
         s))

(test "string-downcase" "speak softly"
       (string-downcase "SPEAK SOFTLY"))
(test "string-downcase" "peak"
       (string-downcase "SPEAK SOFTLY" 1 5))
(test "string-downcase!" "Speak SOFTLY"
       (let ((s (string-copy "SPEAK SOFTLY")))
         (string-downcase! s 1 5)
         s))

(test "string-reverse" "nomel on nolem on"
       (string-reverse "no melon no lemon"))
(test "string-reverse" "nomel on"
       (string-reverse "no melon no lemon" 9))
(test "string-reverse" "on"
       (string-reverse "no melon no lemon" 9 11))
(test "string-reverse!" "nomel on nolem on"
       (let ((s (string-copy "no melon no lemon")))
         (string-reverse! s) s))
(test "string-reverse!" "no melon nomel on"
       (let ((s (string-copy "no melon no lemon")))
         (string-reverse! s 9) s))
(test "string-reverse!" "no melon on lemon"
       (let ((s (string-copy "no melon no lemon")))
         (string-reverse! s 9 11) s))

(test "string-append" #f
       (let ((s "test")) (eq? s (string-append s))))
(test "string-concatenate" #f
       (let ((s "test")) (eq? s (string-concatenate (list s)))))
(test "string-concatenate" "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
       (string-concatenate
        '("A" "B" "C" "D" "E" "F" "G" "H"
          "I" "J" "K" "L" "M" "N" "O" "P"
          "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
          "a" "b" "c" "d" "e" "f" "g" "h"
          "i" "j" "k" "l" "m" "n" "o" "p"
          "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))
(test "string-concatenate/shared" "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
       (string-concatenate/shared
        '("A" "B" "C" "D" "E" "F" "G" "H"
          "I" "J" "K" "L" "M" "N" "O" "P"
          "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
          "a" "b" "c" "d" "e" "f" "g" "h"
          "i" "j" "k" "l" "m" "n" "o" "p"
          "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))
(test "string-concatenate-reverse" "zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA"
       (string-concatenate-reverse
        '("A" "B" "C" "D" "E" "F" "G" "H"
          "I" "J" "K" "L" "M" "N" "O" "P"
          "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
          "a" "b" "c" "d" "e" "f" "g" "h"
          "i" "j" "k" "l" "m" "n" "o" "p"
          "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))
(test "string-concatenate-reverse" #f
       (let ((s "test"))
         (eq? s (string-concatenate-reverse (list s)))))
(test "string-concatenate-reverse/shared" "zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA"
       (string-concatenate-reverse/shared
        '("A" "B" "C" "D" "E" "F" "G" "H"
          "I" "J" "K" "L" "M" "N" "O" "P"
          "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
          "a" "b" "c" "d" "e" "f" "g" "h"
          "i" "j" "k" "l" "m" "n" "o" "p"
          "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))

(test "string-map" "svool"
       (string-map (lambda (c)
                     (integer->char (- 219 (char->integer c))))
                   "hello"))
(test "string-map" "vool"
       (string-map (lambda (c)
                     (integer->char (- 219 (char->integer c))))
                   "hello" 1))
(test "string-map" "vo"
       (string-map (lambda (c)
                     (integer->char (- 219 (char->integer c))))
                   "hello" 1 3))
(test "string-map!" "svool"
       (let ((s (string-copy "hello")))
         (string-map! (lambda (c)
                        (integer->char (- 219 (char->integer c))))
                      s)
         s))
(test "string-map!" "hvool"
       (let ((s (string-copy "hello")))
         (string-map! (lambda (c)
                        (integer->char (- 219 (char->integer c))))
                      s 1)
         s))
(test "string-map!" "hvolo"
       (let ((s (string-copy "hello")))
         (string-map! (lambda (c)
                        (integer->char (- 219 (char->integer c))))
                      s 1 3)
         s))

(test "string-fold" '(#\o #\l #\l #\e #\h . #t)
       (string-fold cons #t "hello"))
(test "string-fold" '(#\l #\e . #t)
       (string-fold cons #t "hello" 1 3))
(test "string-fold-right" '(#\h #\e #\l #\l #\o . #t)
       (string-fold-right cons #t "hello"))
(test "string-fold-right" '(#\e #\l . #t)
       (string-fold-right cons #t "hello" 1 3))

(test "string-unfold" "hello"
       (string-unfold null? car cdr '(#\h #\e #\l #\l #\o)))
(test "string-unfold" "hi hello"
       (string-unfold null? car cdr '(#\h #\e #\l #\l #\o) "hi "))
(test "string-unfold" "hi hello ho"
       (string-unfold null? car cdr
                      '(#\h #\e #\l #\l #\o) "hi "
                      (lambda (x) " ho")))

(test "string-unfold-right" "olleh"
       (string-unfold-right null? car cdr '(#\h #\e #\l #\l #\o)))
(test "string-unfold-right" "olleh hi"
       (string-unfold-right null? car cdr '(#\h #\e #\l #\l #\o) " hi"))
(test "string-unfold-right" "ho olleh hi"
       (string-unfold-right null? car cdr
                            '(#\h #\e #\l #\l #\o) " hi"
                            (lambda (x) "ho ")))

(test "string-for-each" "CLtL"
       (let ((out (open-output-string))
             (prev #f))
         (string-for-each (lambda (c)
                            (if (or (not prev)
                                    (char-whitespace? prev))
                                (write-char c out))
                            (set! prev c))
                          "Common Lisp, the Language")

         (get-output-string out)))
(test "string-for-each" "oLtL"
       (let ((out (open-output-string))
             (prev #f))
         (string-for-each (lambda (c)
                            (if (or (not prev)
                                    (char-whitespace? prev))
                                (write-char c out))
                            (set! prev c))
                          "Common Lisp, the Language" 1)
         (get-output-string out)))
(test "string-for-each" "oL"
       (let ((out (open-output-string))
             (prev #f))
         (string-for-each (lambda (c)
                            (if (or (not prev)
                                    (char-whitespace? prev))
                                (write-char c out))
                            (set! prev c))
                          "Common Lisp, the Language" 1 10)
         (get-output-string out)))
(test "string-for-each-index" '(4 3 2 1 0)
       (let ((r '()))
         (string-for-each-index (lambda (i) (set! r (cons i r))) "hello")
         r))
(test "string-for-each-index" '(4 3 2 1)
       (let ((r '()))
         (string-for-each-index (lambda (i) (set! r (cons i r))) "hello" 1)
         r))
(test "string-for-each-index" '(2 1)
       (let ((r '()))
         (string-for-each-index (lambda (i) (set! r (cons i r))) "hello" 1 3)
         r))

(test "xsubstring" "cdefab"
       (xsubstring "abcdef" 2))
(test "xsubstring" "efabcd"
       (xsubstring "abcdef" -2))
(test "xsubstring" "abcabca"
       (xsubstring "abc" 0 7))
;; (test "xsubstring" "abcabca"
;;        (xsubstring "abc"
;;                    30000000000000000000000000000000
;;                    30000000000000000000000000000007))
(test "xsubstring" "defdefd"
       (xsubstring "abcdefg" 0 7 3 6))
(test "xsubstring" ""
       (xsubstring "abcdefg" 9 9 3 6))

(test "string-xcopy!" "ZZcdefabZZ"
       (let ((s (make-string 10 #\Z)))
         (string-xcopy! s 2 "abcdef" 2)
         s))
(test "string-xcopy!" "ZZdefdefZZ"
       (let ((s (make-string 10 #\Z)))
         (string-xcopy! s 2 "abcdef" 0 6 3)
         s))

(test "string-replace" "abcdXYZghi"
       (string-replace "abcdefghi" "XYZ" 4 6))
(test "string-replace" "abcdZghi"
       (string-replace "abcdefghi" "XYZ" 4 6 2))
(test "string-replace" "abcdZefghi"
       (string-replace "abcdefghi" "XYZ" 4 4 2))
(test "string-replace" "abcdefghi"
       (string-replace "abcdefghi" "XYZ" 4 4 1 1))
(test "string-replace" "abcdhi"
       (string-replace "abcdefghi" "" 4 7))

(test "string-tokenize" '("Help" "make" "programs" "run," "run," "RUN!")
       (string-tokenize "Help make programs run, run, RUN!"))
(test "string-tokenize" '("Help" "make" "programs" "run" "run" "RUN")
       (string-tokenize "Help make programs run, run, RUN!"
                        char-set:letter))
(test "string-tokenize" '("programs" "run" "run" "RUN")
       (string-tokenize "Help make programs run, run, RUN!"
                        char-set:letter 10))
(test "string-tokenize" '("elp" "make" "programs" "run" "run")
       (string-tokenize "Help make programs run, run, RUN!"
                        char-set:lower-case))

(test "string-filter" "rrrr"
       (string-filter #\r "Help make programs run, run, RUN!"))
(test "string-filter" "HelpmakeprogramsrunrunRUN"
       (string-filter char-set:letter "Help make programs run, run, RUN!"))

(test "string-filter" "programsrunrun"
       (string-filter (lambda (c) (char-lower-case? c))
                      "Help make programs run, run, RUN!"
                      10))
(test "string-filter" ""
       (string-filter (lambda (c) (char-lower-case? c)) ""))
(test "string-delete" "Help make pogams un, un, RUN!"
       (string-delete #\r "Help make programs run, run, RUN!"))
(test "string-delete" "   , , !"
       (string-delete char-set:letter "Help make programs run, run, RUN!"))
(test "string-delete" " , , RUN!"
       (string-delete (lambda (c) (char-lower-case? c))
                      "Help make programs run, run, RUN!"
                      10))
(test "string-delete" ""
       (string-delete (lambda (c) (char-lower-case? c)) ""))

;;; Additional tests so that the suite at least touches all
;;; the functions.

(test "string-hash" #t (<= 0 (string-hash "abracadabra" 20) 19))

(test "string-hash" #t (= (string-hash "abracadabra" 20) (string-hash "abracadabra" 20)))

(test "string-hash" #t (= (string-hash "abracadabra" 20 2 7)
                          (string-hash (substring "abracadabra" 2 7) 20)))

(test "string-hash-ci" #t (= (string-hash-ci "aBrAcAdAbRa" 20)
                             (string-hash-ci "AbRaCaDaBrA" 20)))

(test "string-hash-ci" #t (= (string-hash-ci "aBrAcAdAbRa" 20 2 7)
                             (string-hash-ci (substring "AbRaCaDaBrA" 2 7) 20)))

(test "string=" #t (string= "foo" "foo"))
(test "string=" #t (string= "foobar" "foo" 0 3))
(test "string=" #t (string= "foobar" "barfoo" 0 3 3))
(test "string=" #t (not (string= "foobar" "barfoo" 0 3 2 5)))

(test "string<>" #t (string<> "flo" "foo"))
(test "string<>" #t (string<> "flobar" "foo" 0 3))
(test "string<>" #t (string<> "flobar" "barfoo" 0 3 3))
(test "string<>" #t (not (string<> "foobar" "foobar" 0 3 0 3)))

(test "string<=" #t (string<= "fol" "foo"))
(test "string<=" #t (string<= "folbar" "foo" 0 3))
(test "string<=" #t (string<= "foobar" "barfoo" 0 3 3))
(test "string<=" #f (string<= "foobar" "barfoo" 0 3 1 4))

(test "string<" #t (string< "fol" "foo"))
(test "string<" #t (string< "folbar" "foo" 0 3))
(test "string<" #t (string< "folbar" "barfoo" 0 3 3))
(test "string<" #t (not (string< "foobar" "barfoo" 0 3 1 4)))

(test "string>=" #t (string>= "foo" "fol"))
(test "string>=" #t (string>= "foo" "folbar" 0 3 0 3))
(test "string>=" #t (string>= "barfoo" "foo" 3 6 0))
(test "string>=" #t (not (string>= "barfoo" "foobar" 1 4 0 3)))

(test "string>" #t (string> "foo" "fol"))
(test "string>" #t (string> "foo" "folbar" 0 3 0 3))
(test "string>" #t (string> "barfoo" "fol" 3 6 0))
(test "string>" #t (not (string> "barfoo" "foobar" 1 4 0 3)))

(test "string-ci=" #t (string-ci= "Foo" "foO"))
(test "string-ci=" #t (string-ci= "Foobar" "fOo" 0 3))
(test "string-ci=" #t (string-ci= "Foobar" "bArfOo" 0 3 3))
(test "string-ci=" #t (not (string-ci= "foobar" "BARFOO" 0 3 2 5)))

(test "string-ci<>" #t (string-ci<> "flo" "FOO"))
(test "string-ci<>" #t (string-ci<> "FLOBAR" "foo" 0 3))
(test "string-ci<>" #t (string-ci<> "flobar" "BARFOO" 0 3 3))
(test "string-ci<>" #t (not (string-ci<> "foobar" "FOOBAR" 0 3 0 3)))

(test "string-ci<=" #t (string-ci<= "FOL" "foo"))
(test "string-ci<=" #t (string-ci<= "folBAR" "fOO" 0 3))
(test "string-ci<=" #t (string-ci<= "fOOBAR" "BARFOO" 0 3 3))
(test "string-ci<=" #t (not (string-ci<= "foobar" "BARFOO" 0 3 1 4)))

(test "string-ci<" #t (string-ci< "fol" "FOO"))
(test "string-ci<" #t (string-ci< "folbar" "FOO" 0 3))
(test "string-ci<" #t (string-ci< "folbar" "BARFOO" 0 3 3))
(test "string-ci<" #t (not (string-ci< "foobar" "BARFOO" 0 3 1 4)))

(test "string-ci>=" #t (string-ci>= "FOO" "fol"))
(test "string-ci>=" #t (string-ci>= "foo" "FOLBAR" 0 3 0 3))
(test "string-ci>=" #t (string-ci>= "BARFOO" "foo" 3 6 0))
(test "string-ci>=" #t (not (string-ci>= "barfoo" "FOOBAR" 1 4 0 3)))

(test "string-ci>" #t (string-ci> "FOO" "fol"))
(test "string-ci>" #t (string-ci> "foo" "FOLBAR" 0 3 0 3))
(test "string-ci>" #t (string-ci> "barfoo" "FOL" 3 6 0))
(test "string-ci>" #t (not (string-ci> "barfoo" "FOOBAR" 1 4 0 3)))

(test "string=?" #t (string=? "abcd" (string-append/shared "a" "b" "c" "d")))

(test "string-parse-start+end"
      #t
      (let-values (((rest start end) (string-parse-start+end #t "foo" '(1 3 fnord))))
        (and (= start 1)
             (= end 3)
             (equal? rest '(fnord)))))

(test "string-parse-start+end"
      #t
      (call-with-current-continuation
       (lambda (k)
         (with-exception-handler
             (lambda (e) (k #t))
           (lambda ()
             (string-parse-start+end #t "foo" '(1 4))
             #f)))))

(test "string-parse-start+end"
      #t
      (let-values (((start end) (string-parse-final-start+end #t "foo" '(1 3))))
        (and (= start 1)
             (= end 3))))

(test "string-parse-start+end"
      #t
      (let-string-start+end (start end rest) #t "foo" '(1 3 fnord)
                            (and (= start 1)
                                 (= end 3)
                                 (equal? rest '(fnord)))))

(test "check-substring-spec"
      #void ;; unpecified, but STklos returns void
      (check-substring-spec #t "foo" 1 3))

;; adapted from Chicken; our version uses with-exception-handler
(test "check-substring-spec"
      #t
      (call-with-current-continuation
       (lambda (k)
         (with-exception-handler
             (lambda (e) (k #t))
           (lambda ()
             (check-substring-spec #t "foo" 1 4)
             #f)))))

(test "substring-spec-ok?"
      #t
      (substring-spec-ok? "foo" 1 3))

(test "substring-spec-ok?"
      #t
      (not (substring-spec-ok? "foo" 1 4)))

(test "make-kmp-restart-vector" '#() (make-kmp-restart-vector ""))

(test "make-kmp-restart-vector" '#(-1) (make-kmp-restart-vector "a"))

(test "make-kmp-restart-vector" '#(-1 0) (make-kmp-restart-vector "ab"))

; The following is from an example in the code.  It is the "optimised"
; version; it's also valid to return #(-1 0 0 0 1 2), but that will
; needlessly check the "a" twice before giving up.
(test "make-kmp-restart-vector"
      '#(-1 0 0 -1 1 2)
      (make-kmp-restart-vector "abdabx"))

;; Each entry in kmp-cases is a pattern, a string to match against and
;; the expected run of the algorithm through the positions in the
;; pattern.  So for example 0 1 2 means it looks at position 0 first,
;; then at 1 and then at 2.
;;
;; This is easy to verify in simple cases; If there's a shared
;; substring and matching fails, you try matching again starting at
;; the end of the shared substring, otherwise you rewind.  For more
;; complex cases, it's increasingly difficult for humans to verify :)
(define kmp-cases
  '(("abc" "xx" #f 0 0)
    ("abc" "abc" #t 0 1 2)
    ("abcd" "abc" #f 0 1 2)
    ("abc" "abcd" #t 0 1 2)
    ("abc" "aabc" #t 0 1 1 2)
    ("ab" "aa" #f 0 1)
    ("ab" "aab" #t 0 1 1)
    ("abdabx" "abdbbabda" #f 0 1 2 3 0 0 1 2 3)
    ("aabc" "axaabc" #t 0 1 0 1 2 3)
    ("aabac" "aabaabac" #t 0 1 2 3 4 2 3 4)))

(for-each
 (lambda (test-case)
   (let* ((pat (car test-case))
	  (n (string-length pat))
	  (str (cadr test-case))
          (match? (caddr test-case))
	  (steps (cdddr test-case))
	  (rv (make-kmp-restart-vector pat)))
     (let ((p (open-input-string str)))
       (let lp ((i 0)
		(step 0)
		(steps steps))
	 (cond
	   ((or (= i n) (eof-object? (peek-char p)))
	    (test (format #f "KMP match? ~S, case: ~S" match? test-case)
                  #t
		  (eq? (= i n) match?))
	    (test (format #f "KMP empty remaining steps: ~S, case: ~S"
			   steps test-case)
                  #t
			 (null? steps)))
	   (else
	    (let ((new-i (kmp-step pat rv (read-char p) i char=? 0))
		  (expected-i (and (not (null? steps)) (car steps))))
	      (test (format #f "KMP step ~S (exp: ~S, act: ~S), case: ~S"
		      step expected-i i test-case)
		    expected-i i)
	      (lp new-i (+ 1 step) (cdr steps)))))))))
 kmp-cases)

; FIXME!  Implement tests for these:
;   string-kmp-partial-search
;   kmp-step


;;; Regression tests: check that reported bugs have been fixed

; From: Matthias Radestock <matthias@sorted.org>
; Date: Wed, 10 Dec 2003 21:05:22 +0100
;
; Chris Double has found the following bug in the reference implementation:
;
;  (string-contains "xabc" "ab") => 1    ;good
;  (string-contains "aabc" "ab") => #f   ;bad
;
; Matthias.

(test "string-contains" 1 (string-contains "aabc" "ab"))

(test "string-contains" 5 (string-contains "ababdabdabxxas" "abdabx"))

(test "string-contains-ci" 1 (string-contains-ci "aabc" "ab"))

; (message continues)
;
; PS: There is also an off-by-one error in the bounds check of the
; unoptimized version of string-contains that is included as commented out
; code in the reference implementation. This breaks things like
; (string-contains "xab" "ab") and (string-contains "ab" "ab").

; This off-by-one bug has been fixed in the comments of the version
; of SRFI-13 shipped with Larceny.  In a version of the code without
; the fix the following test will catch the bug:

(test "string-contains" 0 (string-contains "ab" "ab"))

;;; The comment below is outdated; the SRFI seems to have
;;; been corrected.
; From: dvanhorn@emba.uvm.edu
; Date: Wed, 26 Mar 2003 08:46:41 +0100
;
; The SRFI document gives,
;
;   string-filter s char/char-set/pred [start end] -> string
;   string-delete s char/char-set/pred [start end] -> string
;
; Yet the reference implementation switches the order giving,
;
;   ;;; string-delete char/char-set/pred string [start end]
;   ;;; string-filter char/char-set/pred string [start end]
;   ...
;   (define (string-delete criterion s . maybe-start+end)
;   ...
;   (define (string-filter criterion s . maybe-start+end)
;
; I reviewed the SRFI-13 mailing list and c.l.scheme, but found no mention of
; this issue.  Apologies if I've missed something.

(test "string=? + string-filter"
      #t
      (call-with-current-continuation
       (lambda (k)
         (with-exception-handler
             (lambda (e) (k #f))
           (lambda () (string=? "ADR" (string-filter char-set:upper-case "abrAcaDabRa")))))))

(test "string=? + string-delete"
      #t
      (call-with-current-continuation
       (lambda (k)
         (with-exception-handler
             (lambda (e) (k #f))
           (lambda () (string=? "abrcaaba" (string-delete char-set:upper-case "abrAcaDabRa")))))))


; http://srfi.schemers.org/srfi-13/post-mail-archive/msg00007.html
; From: David Van Horn <address@hidden>
; Date: Wed, 01 Nov 2006 07:53:34 +0100
;
; Both string-index-right and string-skip-right will continue to search
; left past a given start index.
;
;    (string-index-right "abbb" #\a 1) ;; => 0, but should be #f
;    (string-skip-right  "abbb" #\b 1) ;; => 0, but should be #f
;
; This also causes incorrect results for string-trim-right,
; string-trim-both and string-tokenize when given a non-zero start
; argument.

(test "string-index-right" #f (string-index-right "abbb" #\a 1))
(test "string-skip-right" #f (string-skip-right  "abbb" #\b 1))

;; Tests to check the string-trim-right issue found by Seth Alves
;; http://lists.gnu.org/archive/html/chicken-hackers/2014-01/msg00016.html
(test "string-trim-right" "" (string-trim-right "" char-whitespace? 0 0))
(test "string-trim-right" "" (string-trim-right "a" char-whitespace? 0 0))
(test "string-trim-right" "" (string-trim-right "a " char-whitespace? 0 0))
(test "string-trim-right" "bc" (string-trim-right "abc   " char-whitespace? 1))
(test "string-trim-right" "" (string-trim-right "abc   " char-whitespace? 4 4))


(test "string-trim empty"    "" (string-trim ""))
(test "string-trim nonempty" "abc" (string-trim " abc"))
(test "string-trim no-trimming" "abc" (string-trim "abc"))

;; FIXME: R7RS and SRFI-13 conflict. But when STklos run tests, it will run this
;; file, load the SRFI-13 string-map, shadowing the R7RS one, and fail the R7RS tests later.
;; The following is an ugly hack to  at least let the R7RS tests use the original
;; string-map procedure, but there should be a better way... -- jpellegrini
(set! string-map r7rs:string-map)


;; ;; ----------------------------------------------------------------------
;; ;;  SRFI 37 ...
;; ;; ----------------------------------------------------------------------
(test-subsection "SRFI 37 - args-fold: a program argument processor")

(require "srfi-37")

;; tests from Guile
;; Copyright (C) 2007, 2008, 2013 Free Software Foundation, Inc.
;; Released under the LGPL.
;; Adapted to STklos by Jeronimo Pellegrini

(test "empty calls with count-modified seeds"
      '(21 42)
      (call-with-values
	  (lambda ()
	    (args-fold '("1" "3" "4") '()
		       (lambda (opt name arg seed seed2)
			 (values 1 2))
		       (lambda (op seed seed2)
			 (values (+ 1 seed) (+ 2 seed2)))
		       18 36))
	list))

;; Guile returns '(#t #t "doit" "whatev" #t #t)
;; Chicken, Gauche, SISC, Kawa return '(#t #t "doit" #f #t #t)
;; Guile seems correct.
(test "short opt params"
      '(#t #t "doit" "whatev" #t #t)
      (let ((a-set #f) (b-set #f) (c-val #f) (d-val #f) (no-fail #t) (no-operands #t))
        (args-fold '("-abcdoit" "-ad" "whatev")
		   (list (option '(#\a) #f #f
                                 (lambda (opt name arg)
				   (set! a-set #t)
				   (values)))
		         (option '(#\b) #f #f
                                 (lambda (opt name arg)
				   (set! b-set #t)
				   (values)))
		         (option '("cdoit" #\c) #f #t
			         (lambda (opt name arg)
				   (set! c-val arg)
				   (values)))
		         (option '(#\d) #f #t
			         (lambda (opt name arg)
				   (set! d-val arg)
				   (values))))
		   (lambda (opt name arg) (set! no-fail #f) (values))
		   (lambda (oper) (set! no-operands #f) (values)))
        (list a-set b-set c-val d-val no-fail no-operands)))

(test "single unrecognized long-opt"
      "::fake"
      (args-fold '("--fake" "-i2")
        	 (list (option '(#\i) #t #f
        		       (lambda (opt name arg k) k)))
        	 (lambda (opt name arg k) (string-append "::" name))
        	 (lambda (operand k) #f)
        	 #f))

(test "long req'd/optional"
      '(#f "bsquare" "apple")
      (args-fold '("--x=pple" "--y=square" "--y")
        	 (list (option '("x") #t #f
        		       (lambda (opt name arg k)
        			 (cons (string-append "a" arg) k)))
        	       (option '("y") #f #t
        		       (lambda (opt name arg k)
        			 (cons (if arg
        				   (string-append "b" arg)
        				   #f) k))))
        	 (lambda (opt name arg k) #f)
        	 (lambda (opt name arg k) #f)
        	 '()))

;; this matches behavior of getopt_long in libc 2.4
(test "short options absorb special markers in the next arg"
      '((#\y . "-z") (#\x . "--") (#\z . #f))
      (let ((arg-proc (lambda (opt name arg k)
        	        (cons (cons  name arg ) k))))
        (args-fold '("-zx" "--" "-y" "-z" "--")
        	   (list (option '(#\x) #f #t arg-proc)
        		 (option '(#\z) #f #f arg-proc)
        		 (option '(#\y) #t #f arg-proc))
        	   (lambda (opt name arg k) #f)
        	   (lambda (opt name arg k) #f)
        	   '())))

(test "short options without arguments"
      ;; In Guile 1.8.4 and earlier, using short names of argument-less options
      ;; would lead to a stack overflow.
      '((#\x . #f))  
      (let ((arg-proc (lambda (opt name arg k)
        	        (cons (cons name arg) k))))
        (args-fold '("-x")
        	   (list (option '(#\x) #f #f arg-proc))
        	   (lambda (opt name arg k) #f)
        	   (lambda (opt name arg k) #f)
        	   '())))

(test "short option with optional argument omitted"
      'good
      ;; This would trigger an infinite loop in Guile up to 2.0.7.
      ;; See <http://bugs.gnu.org/13176>.
      (args-fold '("-I")
                 (list (option '(#\I) #f #t
                               (lambda (opt name arg value)
                                 (and (eqv? name #\I) (not arg)
                                      'good))))
                 (lambda _ (error "unrecognized"))
                 (lambda args #f)
                 #f))

;; Gosh, Chicken, SISC, Kawa return #f,
;; but the Guile tests expect "the-argument", whicih, according to the
;; SRFI, should be the correct value.
(test "short option with optional argument provided"
      "the-argument"
      (args-fold '("-I" "the-argument")
                 (list (option '(#\I) #f #t
                               (lambda (opt name arg result)
                                 (and (eqv? name #\I) arg))))
                 (lambda args (error "unrecognized"))
                 (lambda args #f)
                 #f))


;; ----------------------------------------------------------------------
;;  SRFI 51 ...https://github.com/egallesio/STklos/pulls
;; ----------------------------------------------------------------------
(test-subsection "SRFI 51 - Handling rest list")

(require "srfi-51")


(define rest-list '(x 1))
(define caller values)

(test "rest-values" '(1 2 3)   (let-values (((a b c) ((lambda (. a-b) (rest-values a-b 5)) 1 2 3)))
                                 (list a b c)))

(test "rest-list"            '(x 1)       (receive (a b)  (rest-values rest-list) (list a b)))
(test "rest-list 2"          '(x 1)       (receive (a b)  (rest-values rest-list 2) (list a b)))
(test "caller rest-list"     '(x 1)       (receive (a b)  (rest-values caller rest-list) (list a b)))
(test "caller rest-list -3"  '(x 1)       (receive (a b)  (rest-values caller rest-list -3) (list a b)))
(test "rest-list -"          '(x 1 "str") (receive (a b c) (rest-values rest-list - 'y 100 "str") (list a b c)))
(test "rest-list +"          '(x 1 "str") (receive (a b c) (rest-values rest-list + `(x y z) `(100 . ,number?) `("str" . ,string?)) (list a b c)))
(test "rest-list #t"         '(x 1 "str") (receive (a b c) (rest-values rest-list #t `(x y z) `(100 . ,number?) `("str" . ,string?)) (list a b c)))
(test "rest-list #t"         '(1 "str" x) (receive (a b c) (rest-values rest-list #t `(100 . ,number?) `("str" . ,string?) `(x y z)) (list a b c)))
(test "rest-list #f"         '(1 "str" y x) (receive (a b c d) (rest-values rest-list #f `(100 . ,number?) `("str" . ,string?) `(y z)) (list a b c d)))

;; ----------------------------------------------------------------------
;;  SRFI 54 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 54 - Formatting")

(require "srfi-9")  ;; some tests use records
(require "srfi-13") ;; one test uses string-reverse
(require "srfi-14") ;; two tests use charsets
(require "srfi-26") ;; two tests use cut...

(require "srfi-54")

(define-macro (mute-cat expr)
  `(let ((res #f))
     (with-output-to-string (lambda () (set! res ,expr)))
     res))


(test "align left" "130.00    " (cat 129.995 -10 2.))
(test "align right, I" "    130.00" (cat 129.995 10 2.))
(test "align right, II" "    129.98" (cat 129.985 10 2.))
(test "align right, III" "    129.99" (cat 129.985001 10 2.))
(test "exact" "#e130.00"   (cat 129.995 2. 'exact))
(test "decimal places" "129.00"     (cat 129 -2.))
(test "exact, II"  "#e129.00"  (cat 129 2.))
(test "exact w/sign, I" "#e+0129.00" (cat 129 10 2. #\0 'sign))
(test "exact w/sign, II" "*#e+129.00" (cat 129 10 2. #\* 'sign))
(test "rational" "1/3" (cat 1/3))
(test "exact, III" "    #e0.33" (cat 1/3 10 2.))
(test "rational floating point" "      0.33" (cat 1/3 10 -2.))
(test "commas" " 1,29.99,5" (cat 129.995 10 '(#\, 2)))
(test "commas w/sign" "  +129,995" (cat 129995 10 '(#\,) 'sign))
(test "round" "130" (cat (cat 129.995 0.) '(0 -1)))
(test "octal" "#i#o+307/2" (cat 99.5 10 'sign 'octal))
(test "exact octal" "  #o+307/2" (cat 99.5 10 'sign 'octal 'exact))
(test "octal w/sign" "#o+443" (cat #x123 'octal 'sign))
(test "exact w/sign, III" "#e+291.00*" (cat #x123 -10 2. 'sign #\*))

;; changed "e15" to "e+15" in the following test, since this is how STklos
;; writes
(test "complex" "-1.234e+15+1.236e-15i" (cat -1.2345e+15+1.2355e-15i 3.))
;; Same for this, but also fixed it so the length includes the leading space
;; (was 10, changed to 11)
(test "exact w/sign, IV" " +1.234e+15" (cat 1.2345e+15 11 3. 'sign))

(test "string -10" "string    " (cat "string" -10))
(test "string upcase" "    STRING" (cat "string" 10 (list string-upcase)))
(test "string upcase -2" "      RING" (cat "string" 10 (list string-upcase) '(-2)))
(test "string titlecase" "     Sting" (cat "string" 10 `(,string-titlecase) '(2 3)))
(test "string reverse upcase" "GNIRTS" (cat "string" `(,string-reverse ,string-upcase)))
(test "char" "         a" (cat #\a 10))
(test "symbol" "    symbol" (cat 'symbol 10))
(test "vector" "#(#\\a \"str\" s)" (cat '#(#\a "str" s)))
(test "list" "(#\\a \"str\" s)" (cat '(#\a "str" s)))


;; Tests with output changed to ignore the string printed below.
;; They're not to useful as this, but will at least detect crashes.

;; (test "" (#\a "str" s)"(#\\a \"str\" s)" (cat '(#\a "str" s) #t))
(test "output I" "(#\\a \"str\" s)" (mute-cat (cat '(#\a "str" s) #t)))

;;(test "" (#\a "str" s)"(#\\a \"str\" s)" (cat '(#\a "str" s) (current-output-port)))
(test "output II" "(#\\a \"str\" s)" (mute-cat (cat '(#\a "str" s) (current-output-port))))

;; original ok:
(test "output III" "3s \"str\"" (mute-cat (cat 3 (cat 's) " " (cat "str" write))))

;;(test "" 3s "str""3s \"str\"" (cat 3 #t (cat 's) " " (cat "str" write)))
(test "output IV" "3s \"str\"" (mute-cat (cat 3 #t (cat 's) " " (cat "str" write))))

;;(test "" s3s "str""3s \"str\"" (cat 3 #t (cat 's #t) " " (cat "str" write)))
(test "output V" "3s \"str\"" (mute-cat (cat 3 #t (cat 's #t) " " (cat "str" write))))


;; records!
(define-record-type :example
    (make-example num str)
    example?
    (num get-num set-num!)
    (str get-str set-str!))

(define ex (make-example 123 "string"))

(define (record->string object)
  (cat (get-num object) "-" (get-str object)))

(define (record-writer object string-port)
    (if (example? object)
    (begin (display (get-num object) string-port)
           (display "-" string-port)
           (display (get-str object) string-port))
    ((or (and (or (string? object)
              (char? object)
              (boolean? object))
          display)
         write) object string-port)))

;; STklos includes a unique identifier in the object description,
;;
;; stklos> ex
;; #[struct example 140336922587072]
;;
;; so we neex to adapt these tests
;;(test "ex" '#{:example} ex)
;;(test "#{:example}" (cat ex))

(test "ex"     #t (example? ex))
(test "cat ex" "#[struct example " (substring (cat ex) 0 17))

(test "record-writer" "          123-string" (cat ex 20 record-writer))

;; I don't know why this test doesn't work. It fails with the
;; following:
;; string-filter: bad string #[<char-set> 7fba1cc7b0f0]
;;
;; * Larceny seems to not include this (they have a different
;; test set for this SRFI);
;; * Racket passes this, but fails the other test that uses cut
;;
;; Maybe we should leave this commented out for now.
;;
;; (test ""
;;       "--------------GNIRTS"
;;       (cat ex 20 record-writer
;;            `(,(cut string-delete char-set:digit <>)
;;              ,string-upcase ,string-reverse)
;;            '(0 -1) #\-))

(test "record-writer/string-upcase"
      "---------------STING"
      (cat "string" 20 record-writer (list string-upcase) '(2 3) #\-))
(test "record-writer/fpoint"
      "            #e12.000"
      (cat 12 20 record-writer 3.))
(test "record->string"
      "          123-string"
      (cat ex 20 (cons example? record->string)))

(test ""
      "----------123-string"
      (cat ex 20 (cons example? record->string)
           `(,(cut string-delete char-set:digit <>)
             ,string-upcase ,string-reverse)
           '(0 -1) #\-))

(test "record->string/string-upcase"
      "---------------STING"
      (cat "string" 20 (cons example? record->string)  (list string-upcase) '(2 3) #\-))
(test "record->string/fpoint"
       "              12.000"
       (cat 12 20 (cons example? record->string) -3.))

;; ----------------------------------------------------------------------
;;  SRFI 60 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 60 - Integers as Bits")

(require "srfi-60")
(test "logand" "1000" (number->string (logand #b1100 #b1010) 2))
(test "logior" "1110" (number->string (logior #b1100 #b1010) 2))
(test "logxor" "110"  (number->string (logxor #b1100 #b1010) 2))
(test "lognot.1" "-10000001" (number->string (lognot #b10000000) 2))
(test "lognot.2" "-1" (number->string (lognot #b0) 2))
(test "logtest.1" #f (logtest #b0100 #b1011))
(test "logtest.1" #t (logtest #b0100 #b0111))
(test "logcount.1" 4 (logcount #b10101010))
(test "logcount.2" 0 (logcount 0))
(test "logcount.3" 1 (logcount -2))
(test "integer-length.1" 8 (integer-length #b10101010))
(test "integer-length.2" 0 (integer-length 0))
(test "integer-length.2" 4 (integer-length #b1111))
(test "log2-binary-factors"
      '((-1 . -1) (0 . 0) (1 . 1) (0 . 0) (2 . 2) (0 . 0)
        (1 . 1) (0 . 0) (3 . 3) (0 . 0) (1 . 1) (0 . 0)
        (2 . 2) (0 . 0) (1 . 1) (0 . 0) (4 . 4))
      (let ((res '()))
        (do ((idx 0 (+ 1 idx)))
            ((> idx 16))
          (set! res (cons (cons (log2-binary-factors (- idx))
                                (log2-binary-factors (+ idx)))
                          res)))
        (reverse res)))
(test "logbit?.1" #t (logbit? 0 #b1101))
(test "logbit?.2" #f (logbit? 1 #b1101))
(test "logbit?.3" #t (logbit? 2 #b1101))
(test "logbit?.4" #t (logbit? 3 #b1101))
(test "logbit?.5" #f (logbit? 4 #b1101))
(test "copybit.1" "1"   (number->string (copy-bit 0 0 #t) 2))
(test "copybit.2" "100" (number->string (copy-bit 2 0 #t) 2))
(test "copybit.3" "1011" (number->string (copy-bit 2 #b1111 #f) 2))
(test "bit-field.1" "1010" (number->string (bit-field #b1101101010 0 4) 2))
(test "bit-field.2" "10110" (number->string (bit-field #b1101101010 4 9) 2))
(test "copy-bit-field.1" "1101100000"
      (number->string (copy-bit-field #b1101101010 0 0 4) 2))
(test "copy-bit-field.2" "1101101111"
      (number->string (copy-bit-field #b1101101010 -1 0 4) 2))
(test "copy-bit-field.3" "110100111110000"
      (number->string (copy-bit-field #b110100100010000 -1 5 9) 2))
(test "ash.1" "1000" (number->string (ash #b1 3) 2))
(test "ash.2" "101" (number->string (ash #b1010 -1) 2))
(test "rotate-bit-field.1"  "10"
      (number->string (rotate-bit-field #b0100 3 0 4) 2))
(test "rotate-bit-field.2" "110100010010000"
      (number->string (rotate-bit-field #b110100100010000 -1 5 9) 2))
(test "rotate-bit-field.3" "110100000110000"
      (number->string (rotate-bit-field #b110100100010000 1 5 9) 2))
(test  "reverse-bit-field" "e5"
       (number->string (reverse-bit-field #xa7 0 8) 16))
(test "integer->list.1" '(#t #t #t #f #t) (integer->list #b11101))
(test "integer->list.2" '(#f #f #f #f #f #t #t #t #f #t) (integer->list #b11101 10))
(test "list->integer"   #b11101 (list->integer '(#f #f #f #f #f #t #t #t #f #t)))
(test "booleans->integer"  #b11101
      (booleans->integer #f #f #f #f #f #t #t #t #f #t))

;; ----------------------------------------------------------------------
;;  SRFI 62 ...
;; ----------------------------------------------------------------------

;; Tests have been moved to the end since test 62.5 breaks emacs
;; fonctifiation unil EOF

;; ----------------------------------------------------------------------
;;  SRFI 71 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 70 - Numbers")

(test "complex?" #t (complex? +inf.0))
(test "real?" #t (real? -inf.0))
(test "rational?" #f (rational? +inf.0))
(test "integer?" #f (integer? -inf.0))

(test "inexact?" #t (inexact? +inf.0))

(test "=.1" #t (= +inf.0 +inf.0))
(test "=.2" #f (= -inf.0 +inf.0))
(test "=.3" #t (= -inf.0 -inf.0))

(test "positive?" #t (positive? +inf.0))
(test "negative?" #t (negative? -inf.0))
(test "finite?" #f (finite? -inf.0))
(test "infinite?" #t (infinite? +inf.0))

(test "max.1" +inf.0 (max 12 +inf.0))
(test "max.2" +inf.0 (max 12.0 +inf.0))
(test "max.3" +inf.0 (max -inf.0 +inf.0))
(test "min.1" -inf.0 (min 12 -inf.0))
(test "min.2" -inf.0 (min 12.0 -inf.0))
(test "min.3" -inf.0 (min -inf.0 +inf.0))

(test "+.1" +inf.0 (+ +inf.0 +inf.0))
(test "+.2" +nan.0 (+ +inf.0 -inf.0))

(test "*.1" +inf.0 (* 5 +inf.0))
(test "*.2" -inf.0 (* -5 +inf.0))
(test "*.3" +inf.0 (* +inf.0 +inf.0))
(test "*.4" -inf.0 (* +inf.0 -inf.0))
(test "*.5" +nan.0 (* 0 +inf.0))

(test "-" +nan.0 (- +inf.0 +inf.0))


(test "/.1" +inf.0 (/ 0.0))
(test "/.2" +inf.0 (/ 1.0 0))
(test "/.3" -inf.0 (/ -1 0.0))
(test "/.4" +nan.0 (/ 0 0.0))
(test "/.5" +nan.0 (/ 0.0 0))
(test "/.6" +nan.0 (/ 0.0 0.0))

(test "angle.1" #t (< (- (* 4 (atan 1))
             (angle -inf.0))
              0.00001))
(test "angle.2" 0.0 (angle +inf.0))

(test "string->number.1" +inf.0 (string->number "+inf.0"))
(test "string->number.2" -inf.0 (string->number "-inf.0"))
(test "number->string.1" "+inf.0" (number->string +inf.0))
(test "number->string.2" "-inf.0" (number->string -inf.0))

;; ----------------------------------------------------------------------
;;  SRFI 74 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 74 - BLOBs")

(require "srfi-74")

(define b1 (make-blob 16))

(test "blob-length" 16 (blob-length b1))

(blob-u8-set! b1 0 223)
(blob-s8-set! b1 1 123)
(blob-s8-set! b1 2 -123)
(blob-u8-set! b1 3 15)

(test "blob repr"
      '(223 123 123 -123 133 15)
      (list (blob-u8-ref b1 0)
        (blob-s8-ref b1 1)
        (blob-u8-ref b1 1)
        (blob-s8-ref b1 2)
        (blob-u8-ref b1 2)
        (blob-u8-ref b1 3)))

(blob-uint-set! 16 (endianness little) b1 0 (- (expt 2 128) 3))
(test "blob-uint-ref.1"
      (- (expt 2 128) 3)
      (blob-uint-ref 16 (endianness little) b1 0))
(test "blob-uint-ref.2"
      -3
      (blob-sint-ref 16 (endianness little) b1 0))

(test "blob->u8-list"
      '(253 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255)
      (blob->u8-list b1))

(blob-uint-set! 16 (endianness big) b1 0 (- (expt 2 128) 3))

(test "blob-uint-ref.3"
      (- (expt 2 128) 3)
      (blob-uint-ref 16 (endianness big) b1 0))

(test "blob-sint-ref"
      -3
      (blob-sint-ref 16 (endianness big) b1 0))

(test "blob->u8-list"
      '(255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 253)
      (blob->u8-list b1))

(test "blob-u16-ref"
      65023
      (blob-u16-ref (endianness little) b1 14))

(test "blob-s16-ref"
      -513
      (blob-s16-ref (endianness little) b1 14))

(test "blob-u16-ref"
      65533
      (blob-u16-ref (endianness big) b1 14))

(test "blob-s16-ref"
      -3
      (blob-s16-ref (endianness big) b1 14))


(blob-u16-set! (endianness little) b1 0 12345)
(blob-u16-native-set! b1 0 12345)

(test "blob-u16-native-ref"
      12345
      (blob-u16-native-ref b1 0))

(test "blob-u32-ref"
      4261412863
      (blob-u32-ref (endianness little) b1 12))
(test "blob-s32-ref"
      -33554433
      (blob-s32-ref (endianness little) b1 12))

(test "blob-u32-ref"
      4294967293
      (blob-u32-ref (endianness big) b1 12))
(test "blob-s32-ref"
      -3
      (blob-s32-ref(endianness big) b1 12))

(blob-u32-set! (endianness little) b1 0 12345)
(blob-u32-native-set! b1 0 12345)

(test "blob-u32-native-ref"
      12345
      (blob-u32-native-ref b1 0))
(test "blob-u64-ref"
      18302628885633695743
       (blob-u64-ref (endianness little) b1 8))
(test "(blob-s64-ref (endianness little) b1 8)"
      -144115188075855873
      (blob-s64-ref (endianness little) b1 8))
(test "(blob-u64-ref (endianness big) b1 8)"
      18446744073709551613
      (blob-u64-ref (endianness big) b1 8))
(test "(blob-s64-ref (endianness big) b1 8)"
      -3
      (blob-s64-ref (endianness big) b1 8))

(blob-u64-set! (endianness little) b1 0 12345)
(blob-u64-native-set! b1 0 12345)

(test "(blob-u64-native-ref b1 0)"
      12345
      (blob-u64-native-ref b1 0))

(define b2 (u8-list->blob '(1 2 3 4 5 6 7 8)))
(define b3 (blob-copy b2))

(test "(blob=? b2 b3)"
      #t
      (blob=? b2 b3))
(test "(blob=? b1 b2)"
      #f
      (blob=? b1 b2))

(blob-copy! b3 0 b3 4 4)
(test "(blob->u8-list b3)"
      '(1 2 3 4 1 2 3 4)
      (blob->u8-list b3))

(blob-copy! b3 0 b3 2 6)
(test "(blob->u8-list b3)"
      '(1 2 1 2 3 4 1 2)
      (blob->u8-list b3))

(blob-copy! b3 2 b3 0 6)
(test "(blob->u8-list b3)"
      '(1 2 3 4 1 2 1 2)
      (blob->u8-list b3))
(test "(blob->uint-list 1 (endianness little) b3)"
      '(1 2 3 4 1 2 1 2)
      (blob->uint-list 1 (endianness little) b3))
(test "(blob->uint-list 2 (endianness little) b3)"
      '(513 1027 513 513)
      (blob->uint-list 2 (endianness little) b3))

(define b4 (u8-list->blob '(0 0 0 0 0 0 48 57 255 255 255 255 255 255 255 253)))

(test "(blob->sint-list 2 (endianness little) b4)"
      '(0 0 0 14640 -1 -1 -1 -513)
      (blob->sint-list 2 (endianness little) b4))


;; ----------------------------------------------------------------------
;;  SRFI 87 and R7RS ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 87 - => in case clauses")

(test "=> else symbol" 'none (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else => (lambda (x) 'none))))
(test "=> choose non-procedure" *test-failed* (case 10 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else 'none)))
(test "=> don't choose non-procedure" 'none (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else 'none)))
(test "=> don't choose non-procedure, II"  -20 (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else => (lambda (x) (- x)))))
(test "=> else number" 60 (case 20 ((5) 'five) ((10) 'ten) ((15) 'fifteen) (else =>  (lambda (x) (* x 3)))))
(test "=> else -" -20 (case 20 ((5) 'five) ((10) 'ten) ((15) 'fifteen) (else =>  -)))
(test "=> only"  #\z (case #\Z ((#\a) => char-upcase)
                               ((#\c) => (lambda (x) (string x #\d)))
                               ((#\z) => char->integer)
                               ((#\Z) => char-downcase)
                               (else => #f)))

;; ----------------------------------------------------------------------
;;  SRFI 151 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 151 - Bitwise Operations")

(require "srfi-151")

;;bitwise/basic
(test "test-1" -1 (bitwise-not 0))
(test "test-122" 0 (bitwise-not -1))
(test "test-248" -11 (bitwise-not 10))
(test "test-249" 36 (bitwise-not -37))
(test "test-2" 0 (bitwise-and #b0 #b1))
(test "test-10" 1680869008 (bitwise-and -193073517 1689392892))
(test "test-20" 3769478 (bitwise-and 1694076839 -4290775858))
(test "test-115" 6 (bitwise-and 14 6))
(test "test-251" 10 (bitwise-and 11 26))
(test "test-254" 4 (bitwise-and 37 12))
(test "test-288" 1 (bitwise-and #b1 #b1))
(test "test-289" 0 (bitwise-and #b1 #b10))
(test "test-290" #b10 (bitwise-and #b11 #b10))
(test "test-291" #b101 (bitwise-and #b101 #b111))
(test "test-292" #b111 (bitwise-and -1 #b111))
(test "test-293" #b110 (bitwise-and -2 #b111))
(test "test-294" 3769478 (bitwise-and -4290775858 1694076839))
(test "test-11" -4294967295 (bitwise-ior 1 (- -1 #xffffffff)))
(test "test-12" -18446744073709551615 (bitwise-ior 1 (- -1 #xffffffffffffffff)))
(test "test-117" 14 (bitwise-ior 10 12))
(test "test-250" 11 (bitwise-ior 3  10))
(test "test-13" -4294967126 (bitwise-xor #b10101010 (- -1 #xffffffff)))
(test "test-15" -18446744073709551446 (bitwise-xor #b10101010 (- -1 #xffffffffffffffff)))
(test "test-16" -2600468497 (bitwise-ior 1694076839 -4290775858))
(test "test-17" -184549633 (bitwise-ior -193073517 1689392892))
(test "test-18" -2604237975 (bitwise-xor 1694076839 -4290775858))
(test "test-19" -1865418641 (bitwise-xor -193073517 1689392892))
(test "test-119" 6 (bitwise-xor 10 12))
(test "test-252" 9 (bitwise-xor 3 10))
(test "test-14" (bitwise-not -4294967126) (bitwise-eqv #b10101010 (- -1 #xffffffff)))
(test "test-253" -42 (bitwise-eqv 37 12))
(test "test-27" -1 (bitwise-nand 0 0))
(test "test-28" -1 (bitwise-nand 0 -1))
(test "test-29" -124 (bitwise-nand -1 123))
(test "test-326" -11 (bitwise-nand 11 26))
(test "test-327" -28 (bitwise-nor  11 26))
(test "test-317" 0 (bitwise-nor -1 123))
(test "test-328" 16 (bitwise-andc1 11 26))
(test "test-329" 1 (bitwise-andc2 11 26))
(test "test-330" -2 (bitwise-orc1 11 26))
(test "test-30" -1 (bitwise-nor 0 0))
(test "test-31" 0 (bitwise-nor 0 -1))
(test "test-22" 0 (bitwise-andc1 0 0))
(test "test-23" -1 (bitwise-andc1 0 -1))
(test "test-24" 123 (bitwise-andc1 0 123))
(test "test-25" 0 (bitwise-andc2 0 0))
(test "test-26" -1 (bitwise-andc2 -1 0))
(test "test-318" -1 (bitwise-orc1 0 0))
(test "test-319" -1 (bitwise-orc1 0 -1))
(test "test-320" 0 (bitwise-orc1 -1 0))
(test "test-321" -124 (bitwise-orc1 123 0))
(test "test-322" -1 (bitwise-orc2 0 0))
(test "test-323" -1 (bitwise-orc2 -1 0))
(test "test-324" 0 (bitwise-orc2 0 -1))
(test "test-325" -124 (bitwise-orc2 0 123))


;;bitwise/integer
(test "test-78" #x1000000000000000100000000000000000000000000000000
      (arithmetic-shift #x100000000000000010000000000000000 64))
(test "test-79" #x8e73b0f7da0e6452c810f32b809079e5
      (arithmetic-shift #x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b -64))
(test "test-196" 2 (arithmetic-shift 1 1))
(test "test-197" 0 (arithmetic-shift 1 -1))
(test "test-331" 1 (arithmetic-shift 1 0))
(test "test-333" 4 (arithmetic-shift 1 2))
(test "test-334" 8 (arithmetic-shift 1 3))
(test "test-335" 16 (arithmetic-shift 1 4))
(test "test-336" (expt 2 31) (arithmetic-shift 1 31))
(test "test-337" (expt 2 32) (arithmetic-shift 1 32))
(test "test-338" (expt 2 33) (arithmetic-shift 1 33))
(test "test-339" (expt 2 63) (arithmetic-shift 1 63))
(test "test-340" (expt 2 64) (arithmetic-shift 1 64))
(test "test-341" (expt 2 65) (arithmetic-shift 1 65))
(test "test-342" (expt 2 127) (arithmetic-shift 1 127))
(test "test-343" (expt 2 128) (arithmetic-shift 1 128))
(test "test-344" (expt 2 129) (arithmetic-shift 1 129))
(test "test-345" 3028397001194014464 (arithmetic-shift 11829675785914119 8))
(test "test-346" -1 (arithmetic-shift -1 0))
(test "test-347" -2 (arithmetic-shift -1 1))
(test "test-348" -4 (arithmetic-shift -1 2))
(test "test-349" -8 (arithmetic-shift -1 3))
(test "test-350" -16 (arithmetic-shift -1 4))
(test "test-351" (- (expt 2 31)) (arithmetic-shift -1 31))
(test "test-352" (- (expt 2 32)) (arithmetic-shift -1 32))
(test "test-353" (- (expt 2 33)) (arithmetic-shift -1 33))
(test "test-354" (- (expt 2 63)) (arithmetic-shift -1 63))
(test "test-355" (- (expt 2 64)) (arithmetic-shift -1 64))
(test "test-356" (- (expt 2 65)) (arithmetic-shift -1 65))
(test "test-357" (- (expt 2 127)) (arithmetic-shift -1 127))
(test "test-358" (- (expt 2 128)) (arithmetic-shift -1 128))
(test "test-359" (- (expt 2 129)) (arithmetic-shift -1 129))
(test "test-360" 0 (arithmetic-shift 1 -63))
(test "test-361" 0 (arithmetic-shift 1 -64))
(test "test-362" 0 (arithmetic-shift 1 -65))
(test "test-255" 32 (arithmetic-shift 8 2))
(test "test-256" 4 (arithmetic-shift 4 0))
(test "test-257" 4 (arithmetic-shift 8 -1))
(test "test-258" -79 (arithmetic-shift -100000000000000000000000000000000 -100))
(test "test-135" 2 (bit-count 12))
(test "test-263" 0 (integer-length  0))
(test "test-264" 1 (integer-length  1))
(test "test-265" 0 (integer-length -1))
(test "test-266" 3 (integer-length  7))
(test "test-267" 3 (integer-length -7))
(test "test-268" 4 (integer-length  8))
(test "test-269" 3 (integer-length -8))
(test "test-125" 9 (bitwise-if 3 1 8))
(test "test-126" 0 (bitwise-if 3 8 1))
(test "test-373" 3 (bitwise-if 1 1 2))
(test "test-378" #b00110011 (bitwise-if #b00111100 #b11110000 #b00001111))

;;bitwise/single
(test "test-160" #t (bit-set? 0 1))
(test "test-161" #f (bit-set? 1 1))
(test "test-162" #f (bit-set? 1 8))
(test "test-163" #t (bit-set? 10000 -1))
(test "test-167" #t (bit-set? 1000 -1))
(test "test-541" #t (bit-set? 64 #x10000000000000000))
(test "test-542" #f (bit-set? 64 1))
(test "test-272" #t (bit-set? 3 10))
(test "test-273" #t (bit-set? 2 6))
(test "test-274" #f (bit-set? 0 6))
(test "test-168" 0 (copy-bit 0 0 #f))
(test "test-169" 0 (copy-bit 30 0 #f))
(test "test-170" 0 (copy-bit 31 0 #f))
(test "test-171" 0 (copy-bit 62 0 #f))
(test "test-172" 0 (copy-bit 63 0 #f))
(test "test-173" 0 (copy-bit 128 0 #f))
(test "test-174" -1 (copy-bit 0 -1 #t))
(test "test-175" -1 (copy-bit 30 -1 #t))
(test "test-176" -1 (copy-bit 31 -1 #t))
(test "test-177" -1 (copy-bit 62 -1 #t))
(test "test-178" -1 (copy-bit 63 -1 #t))
(test "test-179" -1 (copy-bit 128 -1 #t))
(test "test-180" 1 (copy-bit 0 0 #t))
(test "test-181" #x106 (copy-bit 8 6 #t))
(test "test-182" 6 (copy-bit 8 6 #f))
(test "test-183" -2 (copy-bit 0 -1 #f))
(test "test-184" 0 (copy-bit 128 #x100000000000000000000000000000000 #f))
(test "test-185" #x100000000000000000000000000000000
		 (copy-bit 128 #x100000000000000000000000000000000 #t))
(test "test-186" #x100000000000000000000000000000000
		 (copy-bit 64 #x100000000000000000000000000000000 #f))
(test "test-187" #x-100000000000000000000000000000000
		 (copy-bit 64 #x-100000000000000000000000000000000 #f))
(test "test-188" #x-100000000000000000000000000000000
		 (copy-bit 256 #x-100000000000000000000000000000000 #t))
(test "test-276" #b100 (copy-bit 2 0 #t))
(test "test-277" #b1011 (copy-bit 2 #b1111 #f))
(test "test-379" #b1 (copy-bit 0 0 #t))
(test "test-100" #b1011 (bit-swap 1 2 #b1101))
(test "test-101" #b1011 (bit-swap 2 1 #b1101))
(test "test-382" #b1110 (bit-swap 0 1 #b1101))
(test "test-102" #b10000000101 (bit-swap 3 10 #b1101))
(test "test-278" 1 (bit-swap 0 2 4))
(test "test-129" #t (any-bit-set? 3 6))
(test "test-130" #f (any-bit-set? 3 12))
(test "test-133" #t (every-bit-set? 4 6))
(test "test-134" #f (every-bit-set? 7 6))
(test "test-141" -1 (first-set-bit 0))
(test "test-142" 0 (first-set-bit 1))
(test "test-143" 0 (first-set-bit 3))
(test "test-144" 2 (first-set-bit 4))
(test "test-145" 1 (first-set-bit 6))
(test "test-146" 0 (first-set-bit -1))
(test "test-147" 1 (first-set-bit -2))
(test "test-148" 0 (first-set-bit -3))
(test "test-149" 2 (first-set-bit -4))
(test "test-150" 128 (first-set-bit #x100000000000000000000000000000000))
(test "test-280" 1 (first-set-bit 2))
(test "test-282" 3 (first-set-bit 40))
(test "test-283" 2 (first-set-bit -28))
(test "test-284" 99 (first-set-bit (expt  2 99)))
(test "test-285" 99 (first-set-bit (expt -2 99)))

;; bitwise/field
(test "test-189" 0 (bit-field 6 0 1))
(test "test-190" 3 (bit-field 6 1 3))
(test "test-191" 1 (bit-field 6 2 999))
(test "test-192" 1 (bit-field #x100000000000000000000000000000000 128 129))
(test "test-363" #b1010 (bit-field #b1101101010 0 4))
(test "test-364" #b101101 (bit-field #b1101101010 3 9))
(test "test-365" #b10110 (bit-field #b1101101010 4 9))
(test "test-366" #b110110 (bit-field #b1101101010 4 10))
(test "test-367" #t (bit-field-any? #b101101 0 2))
(test "test-368" #t (bit-field-any? #b101101 2 4))
(test "test-369" #f (bit-field-any? #b101101 1 2))
(test "test-370" #f (bit-field-every? #b101101 0 2))
(test "test-371" #t (bit-field-every? #b101101 2 4))
(test "test-372" #t (bit-field-every? #b101101 0 1))
(test "test-374" #b100000 (bit-field-clear #b101010 1 4))
(test "test-375" #b101110 (bit-field-set #b101010 1 4))
(test "test-193" #b111 (bit-field-replace #b110 1 0 1))
(test "test-194" #b110 (bit-field-replace #b110 1 1 2))
(test "test-195" #b010 (bit-field-replace #b110 1 1 3))
(test "test-376" #b100100 (bit-field-replace #b101010 #b010 1 4))
(test "test-377" #b1001 (bit-field-replace-same #b1111 #b0000 1 3))
(test "test-200" #b110  (bit-field-rotate #b110 1 1 2))
(test "test-201" #b1010 (bit-field-rotate #b110 1 2 4))
(test "test-202" #b1011 (bit-field-rotate #b0111 -1 1 4))
(test "test-203" #b0  (bit-field-rotate #b0 128 0 256))
(test "test-204" #b1  (bit-field-rotate #b1 128 1 256))
    (test "test-205" #x100000000000000000000000000000000
	    (bit-field-rotate #x100000000000000000000000000000000 128 0 64))
    (test "test-206" #x100000000000000000000000000000008
	    (bit-field-rotate #x100000000000000000000000000000001 3 0 64))
    (test "test-207" #x100000000000000002000000000000000
	    (bit-field-rotate #x100000000000000000000000000000001 -3 0 64))
(test "test-208" #b110 (bit-field-rotate #b110 0 0 10))
(test "test-209" #b110 (bit-field-rotate #b110 0 0 256))
(test "test-475" 1 (bit-field-rotate #x100000000000000000000000000000000 1 0 129))
(test "test-211" 6 (bit-field-reverse 6 1 3))
(test "test-212" 12 (bit-field-reverse 6 1 4))
(test "test-213" #x80000000 (bit-field-reverse 1 0 32))
(test "test-214" #x40000000 (bit-field-reverse 1 0 31))
(test "test-215" #x20000000 (bit-field-reverse 1 0 30))
(test "test-216" (bitwise-ior (arithmetic-shift -1 32) #xFBFFFFFF)
		 (bit-field-reverse -2 0 27))
(test "test-217" (bitwise-ior (arithmetic-shift -1 32) #xF7FFFFFF)
		 (bit-field-reverse -2 0 28))
(test "test-218" (bitwise-ior (arithmetic-shift -1 32) #xEFFFFFFF)
		 (bit-field-reverse -2 0 29))
(test "test-219" (bitwise-ior (arithmetic-shift -1 32) #xDFFFFFFF)
		 (bit-field-reverse -2 0 30))
(test "test-220" (bitwise-ior (arithmetic-shift -1 32) #xBFFFFFFF)
		 (bit-field-reverse -2 0 31))
(test "test-221" (bitwise-ior (arithmetic-shift -1 32) #x7FFFFFFF)
		 (bit-field-reverse -2 0 32))
(test "test-222" 5 (bit-field-reverse #x140000000000000000000000000000000 0 129))

;; bitwise/conversion
(test "test-103" '(#t #f #t #f #t #t #t) (bits->list #b1110101))
(test "test-104" '(#f #t #f #t) (bits->list #b111010 4))
(test "test-106" #b1110101 (list->bits '(#t #f #t #f #t #t #t)))
(test "test-107" #b111010100 (list->bits '(#f #f #t #f #t #f #t #t #t)))
(test "test-223" '(#t #t) (bits->list 3))
(test "test-224" '(#f #t #t #f) (bits->list 6 4))
(test "test-225" '(#f #t) (bits->list 6 2))
  (test "test-226" '(#t #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		 #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		 #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		 #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		 #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		 #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		 #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		 #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f)
	    (bits->list 1 128))
(test "test-228" '(#f
		     #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		     #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		     #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		     #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		     #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		     #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		     #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		     #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #t)
		   (bits->list #x100000000000000000000000000000000))
(test "test-229" 6 (list->bits '(#f #t #t)))
(test "test-230" 12 (list->bits '(#f #f #t #t)))
(test "test-231" 6 (list->bits '(#f #t #t #f)))
(test "test-232" 2 (list->bits '(#f #t)))
(test "test-233" 1 (list->bits
	     '(#t #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		  #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		  #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		  #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		  #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		  #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		  #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		  #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f)))
(test "test-234" #x100000000000000000000000000000000
		 (list->bits
		  '(#f
		    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
		    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #t)))
(test "test-235" #x03FFFFFF (list->bits '(#t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t)))
(test "test-236" #x07FFFFFF (list->bits '(#t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t)))
(test "test-237" #x0FFFFFFF (list->bits '(#t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t)))
(test "test-238" #x1FFFFFFF (list->bits '(#t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t)))
(test "test-239" #x3FFFFFFF (list->bits '(#t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t)))
(test "test-240" #x7FFFFFFF (list->bits '(#t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t)))
(test "test-241" #xFFFFFFFF (list->bits '(#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t
						#t #t #t #t #t #t #t #t)))
(test "test-242" #x1FFFFFFFF (list->bits '(#t
					      #t #t #t #t #t #t #t #t
					      #t #t #t #t #t #t #t #t
					      #t #t #t #t #t #t #t #t
					      #t #t #t #t #t #t #t #t)))
(test "test-490" 1 (list->bits '(#t #f)))
(test "test-108" #b1110101 (vector->bits '#(#t #f #t #f #t #t #t)))
(test "test-109" #b00011010100 (vector->bits '#(#f #f #t #f #t #f #t #t)))
(test "test-105" '#(#t #t #t #f #t #f #t #f #f) (bits->vector #b1010111 9))
(test "test-105" '#(#t #t #t #f #t #f #t #f #f) (bits->vector #b1010111 9))
(test "test-110" #b1110101 (bits #t #f #t #f #t #t #t))
(test "test-243" 0 (bits))
(test "test-111" #b111010100 (bits #f #f #t #f #t #f #t #t #t))

;; bitwise/fold
(test "test-112" '(#t #f #t #f #t #t #t) (bitwise-fold cons '() #b1010111))
(test "test-113" 5
      (let ((count 0))
        (bitwise-for-each (lambda (b) (if b (set! count (+ count 1))))
                          #b1010111)
        count))
(test "test-114" #b101010101
      (bitwise-unfold (lambda (i) (= i 10)) even? (lambda (i) (+ i 1)) 0))
(let ((g (make-bitwise-generator #b110)))
(test "test-244a" #f (g))
(test "test-244b" #t (g))
(test "test-244c" #t (g))
(test "test-244d" #f (g)))

;; ----------------------------------------------------------------------
;;  SRFI 117 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 117 - Queues based on lists")

(require "srfi-117")

;; list-queues/simple
(test "make-list-queue"  '(1 1 1) (list-queue-list (make-list-queue '(1 1 1))))
(define x (list-queue 1 2 3))
(test "list-queue-list" '(1 2 3) (list-queue-list x))
(define x1 (list 1 2 3))
(define x2 (make-list-queue x1 (cddr x1)))
(test "list-queue-back" 3 (list-queue-back x2))
(define y (list-queue 4 5))
(test "list-queue?" #t (list-queue? y))
(define z (list-queue-append x y))
(test "list-queue-append" '(1 2 3 4 5) (list-queue-list z))
(define z2 (list-queue-append! x (list-queue-copy y)))
(test "list-queue-append-copy" '(1 2 3 4 5) (list-queue-list z2))
(test "list-queue-append-copy-front" 1 (list-queue-front z))
(test "list-queue-append-copy-back" 5 (list-queue-back z))
(list-queue-remove-front! y)
(test "list-queue-remove-front!" '(5) (list-queue-list y))
(list-queue-remove-back! y)
(test "list-queue-empty?" #t (list-queue-empty? y))
(test "list-queue don't remove-front from empty"
      'error-occurred
      (with-handler (lambda (e)
                      'error-occurred)
                    (list-queue-remove-front! y)))
(test "list-queue don't remove-back from empty"
      'error-occurred
      (with-handler (lambda (e)
                      'error-occurred)
                    (list-queue-remove-back! y)))
(test "list-queue-list II" '(1 2 3 4 5) (list-queue-list z))
(test "list-queue-remove-all!" '(1 2 3 4 5) (list-queue-remove-all! z2))
(test "list-queue-remove-all! -> empty" #t (list-queue-empty? z2))
(list-queue-remove-all! z)
(list-queue-add-front! z 1)
(list-queue-add-front! z 0)
(list-queue-add-back! z 2)
(list-queue-add-back! z 3)
(test "list-queue-remove-all-add-4" '(0 1 2 3) (list-queue-list z))

;; list-queues/whole
(define a (list-queue 1 2 3))
(define b (list-queue-copy a))
(test "list-queue-copy" '(1 2 3) (list-queue-list b))
(list-queue-add-front! b 0)
(test "list-queue-copy is not shared" '(1 2 3) (list-queue-list a))
(test "list-queue-copy size" 4 (length (list-queue-list b)))
(define c (list-queue-concatenate (list a b)))
(test "list-queue-concatenate" '(1 2 3 0 1 2 3) (list-queue-list c))

;; list-queues/map
(define r (list-queue 1 2 3))
(define s (list-queue-map (lambda (x) (* x 10)) r))
(test "list-queue-map" '(10 20 30) (list-queue-list s))
(list-queue-map! (lambda (x) (+ x 1)) r)
(test "list-queue-map!" '(2 3 4) (list-queue-list r))
(define sum 0)
(list-queue-for-each (lambda (x) (set! sum (+ sum x))) s)
(test "list-queue-for-each" 60 sum)

;; list-queues/conversion
(define n (list-queue 5 6))
(list-queue-set-list! n (list 1 2))
(test "list-queue-set-list!" '(1 2) (list-queue-list n))
(define d (list 1 2 3))
(define e (cddr d))
(define f (make-list-queue d e))
(define dx #f) ; redefined below
(define ex #f) ; redefined below
(let-values (((dxv exv) (list-queue-first-last f)))
  (set! dx dxv)
  (set! ex exv))
(test "list-queue-first-last" #t (eq? d dx))
(test "list-queue-first-last II" #t (eq? e ex))
(test "list-queue-first-last III" '(1 2 3) (list-queue-list f))
(list-queue-add-front! f 0)
(list-queue-add-back! f 4)
(test "list-queue-add-{front,back}!" '(0 1 2 3 4) (list-queue-list f))
(define g (make-list-queue d e))
(test "make-list-queue II" '(1 2 3 4) (list-queue-list g))
(define h (list-queue 5 6))
(list-queue-set-list! h d e)
(test "list-queue-set-list! II" '(1 2 3 4) (list-queue-list h))

;; list-queues/unfold
(define (double x) (* x 2))
(define (done? x) (> x 3))
(define (add1 x) (+ x 1))
(define x (list-queue-unfold done? double add1 0))
(test "list-queue-unfold" '(0 2 4 6) (list-queue-list x))
(define y (list-queue-unfold-right done? double add1 0))
(test "list-queue-unfold-right" '(6 4 2 0) (list-queue-list y))
(define x0 (list-queue 8))
(define x1 (list-queue-unfold done? double add1 0 x0))
(test "list-queue-unfold II" '(0 2 4 6 8) (list-queue-list x1))
(define y0 (list-queue 8))
(define y1 (list-queue-unfold-right done? double add1 0 y0))
(test "list-queue-unfold-right II" '(8 6 4 2 0) (list-queue-list y1))

;; ----------------------------------------------------------------------
;;  SRFI 118 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 118 - Simple adjustable-size strings")

(define-syntax set-mutable-string!
  (syntax-rules ()
    ((_ s v)
     (set! s (string-copy v)))))

(define a6  (string-copy "abcdef"))
(define b6  (string-copy "123456"))
(define b12 (string-copy "qwertyuiopas"))

(define au6  (string-copy "Ã¡bcdÃf"))
(define bu6  (string-copy "È ÈÈ¡Ç®Æ¶ã"))
(define bu12 (string-copy "è¡ãà¤å½Ø«ØØµ××°âxy"))

(test "string-append! single" "abcdef" (string-append! a6))
(set-mutable-string! a6 "abcdef")
(test "string-append! single length" 6  (string-length (string-append! a6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! single eq?" #t (eq? a6 (string-append! a6)))

(set-mutable-string! a6  "abcdef")
(define a6-copy (string-copy a6))
(test "string-append! = append" #t (string=? (string-append! a6 b6)
                                             (string-append  a6-copy b6)))
(set-mutable-string! a6 "abcdef")
(test "string-append!" "abcdef123456" (string-append! a6 b6))
(set-mutable-string! a6 "abcdef")
(test "string-append! length" 12 (string-length (string-append! a6 b6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! eq?" #t (eq? a6 (string-append! a6 b6)))

(set-mutable-string! a6 "abcdef")
(test "string-append! char" "abcdef123456" (string-append! a6 #\1 #\2 "345" #\6))
(set-mutable-string! a6 "abcdef")
(test "string-append! char length" 12 (string-length (string-append! a6 #\1 #\2 "345" #\6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! char eq?" #t (eq? a6 (string-append! a6 #\1 #\2 "345" #\6)))



(define au6-copy (string-copy au6))
(test "append! = append, unicode" #t (string=? (string-append! au6 bu6 bu12)
                                               (string-append au6-copy bu6 bu12)))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "append! = append, unicode, length" 24 (string-length (string-append! au6 bu6 bu12)))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "append! = append, unicode, eq?" #t (eq? au6 (string-append! au6 bu6 bu12)))
(set-mutable-string! au6  "Ã¡bcdÃf")

(set-mutable-string! a6 "abcdef")
(test "string-append! char, unicode" "abcdefà¦2345à¼«" (string-append! a6 #\à¦ #\2 "345" #\à¼«))
(set-mutable-string! a6 "abcdef")
(test "string-append! char, unicode, length" 12 (string-length (string-append! a6 #\à¦ #\2 "345" #\à¼«)))
(set-mutable-string! a6 "abcdef")
(test "string-append! char, unidoce, eq?" #t (eq? a6 (string-append! a6 #\à¦ #\2 "345" #\à¼«)))

(set-mutable-string! au6  "Ã¡bcdÃf")
(test "string-append! char, unicode" "Ã¡bcdÃfà¦2345à¼«" (string-append! au6 #\à¦ #\2 "345" #\à¼«))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "string-append! char, unicode, length" 12 (string-length (string-append! au6 #\à¦ #\2 "345" #\à¼«)))
(set-mutable-string! au6  "Ã¡bcdÃf")
(test "string-append! char, unidoce, eq?" #t (eq? au6 (string-append! au6 #\à¦ #\2 "345" #\à¼«)))


(test/error "string-append! args 1"  (string-append! a6 #t))
(test/error "string-append! args 2"  (string-append! a6 2))
(test/error "string-append! args 3"  (string-append! 3 10))
(test/error "string-append! args 4"  (string-append! 'a 'b))

(test/error "string-replace! args 1" (string-replace! 'a 0 6  b6 0 6))
(test/error "string-replace! args 2" (string-replace! a6 0 6  #t 0 6))
(test/error "string-replace! args 3" (string-replace! a6 -1 6  b6 0 6))
(test/error "string-replace! args 4" (string-replace! a6  0 50 b6 0 6))
(test/error "string-replace! args 5" (string-replace! a6  0  6  b6 -1 6))
(test/error "string-replace! args 6" (string-replace! a6  0  6  b6  0 50))

(test/error "string-replace! args 7" (string-replace! 'a 6 0  b6 0 6))
(test/error "string-replace! args 8" (string-replace! 'a 0 6  b6 6 0))

(set-mutable-string! a6 "abcdef")
(test "string-replace! all" "123456"  (string-replace! a6 0 6 b6 0 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! all length" 6  (string-length (string-replace! a6 0 6 b6 0 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! all eq?" #t  (eq? a6 (string-replace! a6 0 6 b6 0 6)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! part" "ab23ef"  (string-replace! a6 2 4 b6 1 3))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part length" 6  (string-length (string-replace! a6 2 4 b6 1 3)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part eq?" #t  (eq? a6 (string-replace! a6 2 4 b6 1 3)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2" "abpaef"  (string-replace! a6 2 4 b12 9 11))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2 length" 6  (string-length (string-replace! a6 2 4 b12 9 11)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2 eq?" #t  (eq? a6 (string-replace! a6 2 4 b12 9 11)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! delete" "abef" (string-replace! a6 2 4 b6 0 0))
(set-mutable-string! a6 "abcdef")
(test "string-replace! delete length" 4  (string-length (string-replace! a6 2 4 b6 0 0)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! delete eq?" #t  (eq? a6 (string-replace! a6 2 4 b6 0 0)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! insert" "abc123456def" (string-replace! a6 3 3 b6 0 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! insert length" 12  (string-length (string-replace! a6 3 3 b6 0 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! insert eq?" #t  (eq? a6 (string-replace! a6 3 3 b6 0 6)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap" "abefef" (string-replace! a6 2 4 a6 4 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap length" 6  (string-length (string-replace! a6 2 4 a6 4 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap eq?" #t  (eq? a6 (string-replace! a6 2 4 a6 4 6)))

;; ----------------------------------------------------------------------
;;  SRFI 129 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 129 - Titlecase procedures")

(require "srfi-129")

(test "" #t (char-title-case? #\x01C5))
(test "" #t (char-title-case? #\x1FFC))
(test "" #f (char-title-case? #\Z))
(test "" #f (char-title-case? #\z))

(test "char 1" #\x01C5 (char-titlecase #\x01C4))
(test "char 2" #\x01C5 (char-titlecase #\x01C6))
(test "char 3" #\Z (char-titlecase #\Z))
(test "char 4" #\Z (char-titlecase #\z))

(test "string 1" "\x01C5;" (string-titlecase "\x01C5;"))
(test "string 2" "\x01C5;" (string-titlecase "\x01C4;"))    ;
(test "string 3" "Ss" (string-titlecase "\x00DF;"))         ;
(test "string 4" "Xi\x0307;" (string-titlecase "x\x0130;")) ;
(test "string 5" "\x1F88;" (string-titlecase "\x1F80;"))
(test "string 6" "\x1F88;" (string-titlecase "\x1F88;"))


(define Floo "\xFB02;oo")
(define Floo-bar "\xFB02;oo bar")
(define Baffle "Ba\xFB04;e")
(define LJUBLJANA "\x01C7;ub\x01C7;ana")
(define Ljubljana "\x01C8;ub\x01C9;ana")
(define ljubljana "\x01C9;ub\x01C9;ana")

(test "string 7" "Bar Baz" (string-titlecase "bAr baZ"))
(test "string 8" "Floo" (string-titlecase "floo"))
(test "string 9" "Floo" (string-titlecase "FLOO"))
(test "string 10" "Floo" (string-titlecase Floo))          ;
(test "string 11" "Floo Bar" (string-titlecase "floo bar"))
(test "string 12" "Floo Bar" (string-titlecase "FLOO BAR"))
(test "string 13" "Floo Bar" (string-titlecase Floo-bar))  ;
(test "string 14" Baffle (string-titlecase Baffle))
(test "string 15" Ljubljana (string-titlecase LJUBLJANA))  ;
(test "string 16" Ljubljana (string-titlecase Ljubljana))
(test "string 17" Ljubljana (string-titlecase ljubljana))  ;

(define str1 "abc")
(define str2 "def")
(test/error "string-append! constant 1" (string-append! "a" "b"))
(test/error "string-append! constant 2" (string-append! "Ã¡bÃ§, unicode!" "bÃ§dÃ©ï¬"))
(test/error "string-append! constant 3" (string-append! str1 "x"))
(test "string-append! constant 3" "abcdef" (string-append! (string-copy str1) str2)) ;  second arg may be constant
(test "string-append! constant 3" "xdef" (string-append! (string-copy "x") str2)) ;  second arg may be constant


;; ----------------------------------------------------------------------
;;  SRFI 141 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 141 - Integer division")

(require "srfi-141")

;; SRFI 141 comes with no tests, so I have ceated a few.

(define nums-dens '( (25 3)
                     (-25 3)
                     (17 3)
                     (-17 3)
                     (29 5)
                     (-29 5)
                     (30 3)
                     (-30 3)
                     (101 80)
                     (-101 80)
                     (101 -80)
                     (100 60)
                     (-100 60) ))

(for-each (lambda (num-den)
            (let ((n (car num-den))
                  (d (cadr num-den)))
              (let ((flq (floor-quotient n d))
                    (flr (floor-remainder n d))
                    (clq (ceiling-quotient n d))
                    (clr (ceiling-remainder n d))
                    (tcq (truncate-quotient n d))
                    (tcr (truncate-remainder n d))
                    (rdq (round-quotient n d))
                    (rdr (round-remainder n d))
                    (euq (euclidean-quotient n d))
                    (eur (euclidean-remainder n d))
                    (blq (balanced-quotient n d))
                    (blr (balanced-remainder n d)))

                (test (format "flq:~d:~d" n d)
                      (floor (/ n d))
                      flq)
                (test (format "flr:~d:~d" n d)
                     (- n (* flq d))
                     flr)
                
                (test (format "clq:~d:~d" n d)
                      (ceiling (/ n d))
                      clq)
                (test (format "clr:~d:~d" n d)
                      (- n (* clq d))
                      clr)
                
                (test (format "trlq:~d:~d" n d)
                      (truncate (/ n d))
                      tcq)
                (test (format "trr:~d:~d" n d)
                      (- n (* tcq d))
                      tcr)

                (test (format "rdq:~d:~d" n d)
                      (round (/ n d))
                      rdq)
                (test (format "rdr:~d:~d" n d)
                      (- n (* rdq d))
                      rdr)
          
                (test (format "euq:~d:~d" n d)
                      (if (positive? d)
                          (floor (/ n d))
                          (ceiling (/ n d)))
                      euq)
                (test (format "eur3:~d:~d" n d)
                      #t
                      (< eur (abs d)))
                (test (format "eur2:~d:~d" n d)
                      #t
                      (>= eur 0))
                (test (format "eur:~d:~d" n d)
                      (- n (* euq d))
                      eur)

                (test (format "blr1:~d:~d" n d)
                      #t
                      (< blr (abs (/ d 2))))
                (test (format "blr2:~d:~d" n d)
                      #t
                      (>= blr (- (abs (/ d 2)))))
                (test (format "blr:~d:~d" n d)
                      (- n (* blq d))
                      blr))))
          nums-dens)

;; ----------------------------------------------------------------------
;;  SRFI 156 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 156 - Syntactic combiners for binary predicates")

(require "srfi-156")


;; the tests were translated from the original SRFI reference implementation

(test "" #t
 (is 1 odd?))

(test "" #t
 (isnt 2 odd?))

(test "" #t
 (is '() null?))

(test "" #t
 (is procedure? procedure?))

(test "" #t
 (isnt 5 procedure?))

;; two arguments:

(test "" #t
 (is 1 < 2))

(test "" #t
 (isnt 1 < 1))

(test "" #t
 (is (+ 2 2) = 4))

(test "" #t
 (is 'x eq? 'x))

(test "" #t
 (is procedure? eq? procedure?))

(test "" #t
 (eq? (is eq? eq? eq?)
      (eq? eq? eq?)))

(test "" #t
 (is (is eq? eq? eq?) eq? (eq? eq? eq?)))

(test "" '(y z)
 (is 'y memq '(x y z)))

(test "" '((1) (2) (1 2))
 (is '(1) member '(() (1) (2) (1 2))))

(test "" #t
 (isnt 'x eq? 'y))

(test "" #t
 (is '(a b c) equal? '(a b c)))

(test "" #t
 (isnt '(a b c) equal? '(c b a)))

(test "" #t
 (is 0 = 0.0))

(test "" #t
 (is 1.0 = 1))

(test "" #t
 (isnt 1 = 0))

(define (divisible-by? x y)
  (is (modulo x y) = 0))

(test "" #t
 (is 9 divisible-by? 3))

(test "" #t
 (isnt 3 divisible-by? 9))

;; ending with unary predicate:

(test "" #t
 (is 1 < 2 even?))

(test "" #t
 (isnt 1 < 2 odd?))

(test "" #t
 (isnt 2 < 1 even?))

(test "" #t
 (is 0 = 0.0 zero?))

(test "" #t
 (isnt 1.0 = 1 zero?))

;; three arguments:

(test "" #t
 (is 1 < 2 <= 3))

(test "" #t
 (is 0 = 0.0 = 0+0i = 0.0+0.0i))

(test "" #t
 (isnt 1 <= 2 < 2))

;; predicates don't need to be transitive
;; (although that's not particularly elegant):

(test "" #t
 (is 1 < 2 > 1.5))

(test "" #t
 (isnt 1 < 2 > 3))

(test "" #t
 (isnt 3 < 2 < 1))

(test "" '((x y) (y x))
 (is 'x member '(x y) member '((x y) (y x))))

;; more arguments:

(test "" #t
 (is -0.4 < -0.1 <= 0 = 0.0 < 0.1 < 0.4))

(test "" #t
 (isnt -0.4 < -0.1 <= 0 = 0.0 < 0.1 < -0.1))

(test "" #t
 (is 0 = 0.0 = 0+0i = 0.0+0.0i = (+) < (*) = 1 = 1.0 = 1+0i = 1.0+0.0i))

;; ending with unary predicate:

(test "" #t
 (is -0.4 < -0.1 <= 0 <= 0.0 < 0.1 < 0.4 <= 2 even?))

(test "" #t
 (isnt -0.4 < -0.1 <= 0 <= 0.0 < 0.1 < 0.4 <= 2 odd?))

;; as procedures (with underscore):

(test "" #t
 (equal? (filter (isnt _ even?) '(2 4 5 6 7 8))
	 '(5 7)))

(test "" #t
 (equal? (filter (is _ < 2) '(1 3 2 0))
	 '(1 0)))

(test "" #t
 (equal? (filter (is 1 < _) '(1 3 2 0))
	 '(3 2)))

(test "" #t
 (equal? (filter (is 3 < _ <= 5) '(2 3 4 5 6 7))
	 '(4 5)))

(test "" #t
 (equal? (filter (is 'x memq _) '((a b) (x) (p q) (x y) (c d) (z x)))
	 '((x) (x y) (z x))))

(test "" #t
 (equal? (filter (isnt 'x memq _) '((a b) (x) (p q) (x y) (c d) (z x)))
	 '((a b) (p q) (c d))))

(test "" #t
 (equal? (filter (isnt 3 < _ <= 5) '(2 3 4 5 6 7))
	 '(2 3 6 7)))

(test "" #t
 (equal? (filter (is _ eq? 'a) '(m a m a))
	 '(a a)))

(test "" #t
 (equal? (filter (isnt 'a eq? _) '(m a m a))
	 '(m m)))

;; multiple underscores:

(test "" #t
 ((is _ < 2 < _) 1 3))

(test "" #t
 ((isnt 1 < _ <= _ < 3) 2 4))

(test "" #t
 ((is _ < _ even?) 1 2))

(test "" #t
 ((isnt _ < _ odd?) 1 2))

(test "" #t
 ((is 1 < _ <= 3 < _ <= 5 < _) 3 5 6))

(test "" #t
 ((isnt 1 < _ <= 3 < _ <= 5 < _) 3 3 6))

(test "" #t
 ((is 1 < _ <= 3 < _ <= 5 < _ even?) 3 5 6))

(test "" #t
 ((isnt 1 < _ <= 3 < _ <= 5 < _ odd?) 3 5 6))

;; ----------------------------------------------------------------------
;;  SRFI 158 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 158 - generators")

(require "srfi-158")


(test "iota-simple" (generator->list (make-iota-generator 3 8)) '(8 9 10))
(test "iota-step" (generator->list (make-iota-generator 3 8 2)) '(8 10 12))
(test "range-simple" (generator->list (make-range-generator 3) 4) '(3 4 5 6))
(test "range-upper-limit" (generator->list (make-range-generator 3 8)) '(3 4 5 6 7))
(test "range-upper-limit-step" (generator->list (make-range-generator 3 8 2)) '(3 5 7))

(define g
  (make-coroutine-generator
   (lambda (yield) (let loop ((i 0))
                (when (< i 3) (yield i) (loop (+ i 1)))))))
(test "coroutine-generator" (generator->list g) '(0 1 2))

(test "list->generator" (generator->list (list->generator '(1 2 3 4 5))) '(1 2 3 4 5))
(test "vector->generator" (generator->list (vector->generator '#(1 2 3 4 5))) '(1 2 3 4 5))
(test "reverse-vector->generator" (generator->list (reverse-vector->generator '#(1 2 3 4 5))) '(5 4 3 2 1))
(test "string->generator" (generator->list (string->generator "abcde")) '(#\a #\b #\c #\d #\e))
(test "vector->generator-start" (generator->list (vector->generator '#(a b c d e) 2)) '(c d e))
(test "vector->generator-start-end" (generator->list (vector->generator '#(a b c d e) 2 4)) '(c d))
(test "reverse-vector->generator-start" (generator->list (reverse-vector->generator '#(a b c d e) 2)) '(e d c))
(test "reverse-vector->generator-start-end" (generator->list (reverse-vector->generator '#(a b c d e) 2 4)) '(d c))
(test "reverse-vector->generator-start-end-2" (generator->list (reverse-vector->generator '#(a b c d e) 0 2)) '(b a))

(test "make-unfold-generator" (generator->list (make-unfold-generator
                                                (lambda (s) (> s 5))
                                                (lambda (s) (* s 2))
                                                (lambda (s) (+ s 1))
                                                0))
      '(0 2 4 6 8 10))

(test "gcons*" (generator->list (gcons* 'a 'b (make-range-generator 0 2))) '(a b 0 1))
(test "gappend" (generator->list (gappend (make-range-generator 0 3) (make-range-generator 0 2))) '(0 1 2 0 1))
(test "gappend-2" (generator->list (gappend)) '())
(test "gmap"    (generator->list (gmap - (make-range-generator 0 3))) '(0 -1 -2))
(test "gmap-2"  (generator->list (gmap cons (generator 1 2 3) (generator 4 5))) '((1 . 4) (2 . 5)))
(test "gdelete" (generator->list (gdelete 3 (generator 1 2 3 4 5 3 6 7))) '(1 2 4 5 6 7))
(test "gdelete-neighbor-dups" (generator->list (gdelete-neighbor-dups (list->generator '(a a b c a a a d c)))) '(a b c a d c))
(test "gindex" (generator->list (gindex (list->generator '(a b c d e f))
                                        (list->generator '(0 2 4))))
      '(a c e))
(test "gselect" (generator->list (gselect (list->generator '(a b c d e f))
                                          (list->generator '(#t #f #f #t #t #f))))
      '(a d e))


;; ----------------------------------------------------------------------
;;  SRFI 161 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 161 - Unifiable Boxes")

(require "srfi-161")

(define a (ubox 'a))
(define b (ubox 'b))
(define c (ubox 'c))
(define d (ubox 'd))
(define e (ubox 'e))
(define f (ubox 'f))


(test "ubox?" #t (ubox? (ubox 'g)))

(test "ubox?, 2" #f (ubox? (vector 'h)))

(test "ubox=?" #f (ubox=? a b))

(test "ubox-ref"
      #t
      (eq? 'a (ubox-ref a)))

(ubox-link! a b)
(ubox-union! a c)
(ubox-unify! cons d e)
(ubox-link! b f)

(test "ubox=?" #t (ubox=? a b))
(test "ubox=?" #t (ubox=? b c))
(test "ubox=?" #t (ubox=? c f))
(test "ubox=?" #t (ubox=? a f))
(test "ubox=?" #t (ubox=? d e))
(test "ubox=?" #f (ubox=? a e))

(test "ubox-ref, eq?" #t (eq? (ubox-ref a) 'f))
(test "ubox-ref, equal?" #t (equal? (ubox-ref d) '(d . e)))

(ubox-set! b 'i)

(test "ubox-set!" #t (eq? (ubox-ref a) 'i))

(ubox-link! a e)

(test "ubox-link!" #t (ubox=? c e))


;; ----------------------------------------------------------------------
;;  SRFI 169 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 169 - Underscores in numbers")

;; bin
(test "binary" 201 (read-from-string "#b11001001"))
(test "binary" 201 (read-from-string "#b1_1_0_0_1_0_0_1"))
(test "binary" 201 (read-from-string "#b1_1001001"))
(test "binary" 201 (read-from-string "#b110_01001"))
(test "binary" 201 (read-from-string "#b1100100_1"))

(test/error "binary, leading _"  (read-from-string "#b_11001001"))
(test/error "binary, trailing _" (read-from-string "#b11001001_"))
(test/error "binary, #_b"        (read-from-string "#_b11001001"))
(test/error "binary, double _"   (read-from-string "#b1100__1001"))

;; if it begins with _, it's a symbol!
(test "binary, _#b"  #t (symbol? (read-from-string "_#b11001001")))

;; hex
(test "hex" 4194308277 (read-from-string "#xfa0010b5"))
(test "hex, several _" 4194308277 (read-from-string "#xf_a_0_0_1_0_b_5"))
(test "hex, left _" 4194308277 (read-from-string "#xf_a0010b5"))
(test "hex, right _" 4194308277 (read-from-string "#xfa0010b_5"))
(test "hex, middle _" 4194308277 (read-from-string "#xfa0_010b5"))

(test/error "hex, leading _"  (read-from-string "#x_fa0010b5"))
(test/error "hex, trailing _" (read-from-string "#xfa0010b5_"))
(test/error "hex, #_x"        (read-from-string "#_xfa0010b5"))
(test/error "hex, double _"   (read-from-string "#xfa0__010b5"))

;; if it begins with _, it's a symbol!
(test "hex, _#x" #t (symbol? (read-from-string "_#xfa0010b5")))

;; from the SRFI
;; integers
(test "int" 123 (read-from-string "0123"))
(test "int, three underscores" 123 (read-from-string "0_1_2_3"))
(test "int, one underscore I" 123 (read-from-string "0_123"))
(test "int, one underscore II" 123 (read-from-string "01_23"))
(test "int, one underscore III" 123 (read-from-string "012_3"))
(test "int, signed+, no underscore" 123 (read-from-string "+0123"))
(test "int, signed+, one underscore" 123 (read-from-string "+0_123"))
(test "int, signed-, no underscore" -123 (read-from-string "-0123"))
(test "int, signed-, one underscore" -123 (read-from-string "-0_123"))


(test "int, leading _" #f (number? (read-from-string "_0123")))
(test "int, trailing _" #f (number? (read-from-string "0123_")))
(test "int, trailing double _" #f (number? (read-from-string "0123__")))
(test "int, double _" #f (number? (read-from-string "01__23")))
(test "int, several _" #f (number? (read-from-string "0_1__2___3")))
(test "int, _ after sign+" #f (number? (read-from-string "+_0123")))
(test "int, signed+, trailing _" #f (number? (read-from-string "+0123_")))
(test "int, after sign-" #f (number? (read-from-string "-_0123")))
(test "int, signed-, trailing _" #f (number? (read-from-string "-0123_")))

;; reals
(test "real" 123.456 (read-from-string "123.456"))
(test "real, 4 underscores" 123.456 (read-from-string "0_1_23.4_5_6"))
(test "real, exp-notation" 123.5e6 (read-from-string "1_2_3.5e6"))
(test "real, exp-notation" 12e12 (read-from-string "1_2e1_2"))

(test "real, leading _" #f (number? (read-from-string "_0123.456")))
(test "real, _." #f (number? (read-from-string "0123_.456")))
(test "real, ._" #f (number? (read-from-string "0123._456")))
(test "real, trailing _" #f (number? (read-from-string "0123.456_")))
(test "real, _., exp-notation" #f (number? (read-from-string "123_.5e6" )))
(test "real, ._, exp-notation" #f (number? (read-from-string "123._5e6" )))
(test "real, _e" #f (number? (read-from-string "123.5_e6" )))
(test "real, e_" #f (number? (read-from-string "123.5e_6" )))
(test "real, trailing _, exp-notation" #f (number? (read-from-string "123.5e6_" )))
(test "real, _e, no dot" #f (number? (read-from-string "12_e12"   )))
(test "real e_, no dot" #f (number? (read-from-string "12e_12"   )))
(test "real, trailing _, no dot" #f (number? (read-from-string "12e12_"   )))

(test "octal, two _"  80247 (read-from-string "#o23_45_67"))
(test "int, #d, two _" 456789 (read-from-string "#d45_67_89"))
(test "hex, negative" -32 (read-from-string "#x-2_0"))
(test "octal, signed, two _" 10030 (read-from-string "#o+2_345_6"))

(test/error "hex, #x-_"  (read-from-string "#x-_2"))
(test "_#x-_"  #t (symbol? (read-from-string "_#x-_2")))
(test/error "#d_"   (read-from-string "#d_45_67_89"))
(test/error "#e_"  (read-from-string "#e_45/67_89"))
(test/error "#i#o_"  (read-from-string "#i#o_1234"))
(test/error "#i_#o_" (read-from-string "#i_#o_1234"))
(test/error "trailing _" (read-from-string "#e#x1234_"))

;; ---------------------------------------------------------------------
;;  SRFI 171 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 171 - Transducers")

(require "srfi-1")
(require "srfi-66")
(require "srfi-69")
(require "srfi-171")

(define (add1 x) (+ x 1))

(define numeric-list (iota 5))
(define numeric-vec (list->vector numeric-list))
(define bv (list->u8vector numeric-list))
(define test-string "0123456789abcdef")
(define list-of-chars (string->list test-string))

;; for testing all treplace variations
(define replace-alist '((1 . s) (2 . c) (3 . h) (4 . e) (5 . m)))
(define stklos-hashtable (%old-alist->hash-table replace-alist eq? md5sum))
(define srfi69-hashtable (alist->hash-table replace-alist))
;;(define rnrs-hashtable (rnrs:make-eq-hashtable))

;; No rnrs hashtables
;; (rnrs:hashtable-set! rnrs-hashtable 1 's)
;; (rnrs:hashtable-set! rnrs-hashtable 2 'c)
;; (rnrs:hashtable-set! rnrs-hashtable 3 'h)
;; (rnrs:hashtable-set! rnrs-hashtable 4 'e)
;; (rnrs:hashtable-set! rnrs-hashtable 5 'm)

(define (replace-function val)
  (case val
    ((1) 's)
    ((2) 'c)
    ((3) 'h)
    ((4) 'e)
    ((5) 'm)
    (else val)))

;; Test procedures for port-transduce
;; broken out to properly close port
(define (port-transduce-test)
  (let* ((port (open-input-string "0 1 2 3 4"))
        (res (equal? 15 (port-transduce (tmap add1) + read
                                        (open-input-string "0 1 2 3 4")))))
    (close-port port)
    res))
(define (port-transduce-with-identity-test)
  (let* ((port (open-input-string "0 1 2 3 4"))
         (res (equal? 15 (port-transduce (tmap add1)
                                         +
                                         0
                                         read
                                         (open-input-string "0 1 2 3 4")))))
    (close-port port)
    res))


;;; helpers:


  (define (compose . functions)
    (define (make-chain thunk chain)
      (lambda args
        (call-with-values (lambda () (apply thunk args)) chain)))
    (if (null? functions)
        values
        (fold make-chain (car functions) (cdr functions))))


;; "transducers"


(test "tmap"
      '(1 2 3 4 5)
      (list-transduce (tmap add1)
                      rcons
                      numeric-list))

(test "tfilter"
      '(0 2 4)
      (list-transduce (tfilter even?)
                      rcons
                      numeric-list))

(test "tfilter+tmap"
      '(1 3 5)
      (list-transduce (compose (tfilter even?) (tmap add1))
                      rcons
                      numeric-list))

(test "tfilter-map"
      '(1 3 5)
      (list-transduce (tfilter-map
                       (lambda (x)
                         (if (even? x)
                             (+ x 1)
                             #f)))
                      rcons numeric-list))

(test "tremove"
      (list-transduce (tremove char-alphabetic?)
                      rcount
                      list-of-chars)
      (string-transduce (tremove char-alphabetic?)
                        rcount
                        test-string))

(test "treplace with alist"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace replace-alist)
                      rcons
                      '(1 2 3 4 5 4 r o c k s) ))

(test "treplace with replace-function"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace replace-function)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

(test "treplace with STklos hash-table"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace stklos-hashtable)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

(test "treplace with srfi-69 hash-table"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace srfi69-hashtable)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

;; STklos has no RNRS hashtables, so we comment this out.
;;
;; (test "treplace with rnrs hash-table"
;;       '(s c h e m e  r o c k s)
;;       (list-transduce (treplace rnrs-hashtable)
;;                       rcons
;;                       '(1 2 3 4 5 4 r o c k s)))

(test "ttake"
      6 (list-transduce (ttake 4) + numeric-list))

(test "tdrop"
      7 (list-transduce (tdrop 3) + numeric-list))

(test "tdrop-while"
      '(3 4)
      (list-transduce (tdrop-while (lambda (x) (< x 3)))
                      rcons
                      numeric-list))

(test "ttake-while"
      '(0 1 2)
      (list-transduce (ttake-while (lambda (x) (< x 3)))
                      rcons
                      numeric-list))

(test "tconcatenate"
      '(0 1 2 3 4) (list-transduce tconcatenate
                                   rcons
                                   '((0 1) (2 3) (4))))

(test "tappend-map"
      '(1 2 2 4 3 6)
      (list-transduce (tappend-map (lambda (x) (list x (* x 2))))
                      rcons
                      '(1 2 3)))

(test "tdelete-neighbor-duplicates"
      '(1 2 1 2 3)
      (list-transduce (tdelete-neighbor-duplicates)
                      rcons
                      '(1 1 1 2 2 1 2 3 3)))

(test "tdelete-neighbor-duplicates with equality predicate"
      '(a b c "hej" "hej")
      (list-transduce (tdelete-neighbor-duplicates eq?)
                      rcons
                      (list 'a 'a 'b 'c 'c "hej" (string #\h #\e #\j))))

(test "tdelete-duplicates"
      '(1 2 3 4)
      (list-transduce (tdelete-duplicates)
                      rcons
                      '(1 1 2 1 2 3 3 1 2 3 4)))

(test "tdelete-duplicates with predicate"
      '("hej" "hopp")
      (list-transduce (tdelete-duplicates string-ci=?)
                      rcons
                      (list "hej" "HEJ" "hopp" "HOPP" "heJ")))

;; added by jpellegrini:
(test "tdelete-duplicates with string=?"
      '("hej" "HEJ" "hopp" "HOPP")
      (list-transduce (tdelete-duplicates string=?)
                      rcons
                      (list "hej" "HEJ" "hopp" "HOPP" "hej")))

(test "tflatten"
      '(1 2 3 4 5 6 7 8 9)
      (list-transduce tflatten rcons '((1 2) 3 (4 (5 6) 7) 8 (9))))

(test "tpartition"
      '((1 1 1 1) (2 2 2 2) (3 3 3) (4 4 4 4))
      (list-transduce (tpartition even?)
                      rcons
                      '(1 1 1 1 2 2 2 2 3 3 3 4 4 4 4)))

(test "tsegment"
      '((0 1) (2 3) (4))
      (vector-transduce (tsegment 2) rcons numeric-vec))

(test "tadd-between"
      '(0 and 1 and 2 and 3 and 4)
      (list-transduce (tadd-between 'and) rcons numeric-list))

(test "tenumerate"
      '((-1 . 0) (0 . 1) (1 . 2) (2 . 3) (3 . 4))
      (list-transduce (tenumerate (- 1)) rcons numeric-list))


;; "x-transduce"

(test "list-transduce"
      15 (list-transduce (tmap add1) + numeric-list))

(test "list-transduce with identity"
      15 (list-transduce (tmap add1) + 0 numeric-list))

(test "vector-transduce"
      15 (vector-transduce (tmap add1) + numeric-vec))

(test "vector-transduce with identity"
      15
      (vector-transduce (tmap add1) + 0 numeric-vec))

(test "port-transduce" #t (port-transduce-test))
(test "port-transduce with identity" #t (port-transduce-with-identity-test))

;; Converts each numeric char to it's corresponding integer  and sums them.
(test "string-transduce"
      15
      (string-transduce (tmap (lambda (x) (- (char->integer x) 47))) + "01234"))

(test "string-transduce with identity"
      15
      (string-transduce  (tmap (lambda (x) (- (char->integer x) 47)))
                         +
                         0
                         "01234"))

(test "generator-transduce"
      '(1 2 3)
      (with-input-from-string "1 2 3"
        (lambda () (generator-transduce (tmap (lambda (x) x)) rcons read))))

(test "generator-transduce with identity"
      '(1 2 3)
      (with-input-from-string "1 2 3"
        (lambda () (generator-transduce (tmap (lambda (x) x)) rcons '() read))))

(test "bytevector-u8-transduce"
      15 (bytevector-u8-transduce (tmap add1) + bv))

(test "bytevector-u8-transduce with identity"
      15 (bytevector-u8-transduce (tmap add1) + 0 bv))

;; ----------------------------------------------------------------------
;;  SRFI 173 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 173 - Hooks")

(require "srfi-173")

(test "make-hook type" (hook? (make-hook 2)) #t)

(define hook (make-hook 2))
(define hook-sum-var 0)
(define hook-prod-var 1)
(define (hook-prod x y)
  (set! hook-prod-var (* x y)))

(hook-add! hook (lambda (x y) (set! hook-sum-var (+ x y))))
(hook-add! hook hook-prod)

(test "add-hook!+run-hook" '(8 15)
      (begin
        (hook-run hook 3 5)
        (list hook-sum-var hook-prod-var)))

(define list-from-hook (hook->list hook))

(test "hook->list" #t (list? list-from-hook))
(test "hook->list length" 2 (length list-from-hook))
(test "hook->list element types" #f (member #f (map procedure? list-from-hook)))

(hook-delete! hook hook-prod)
(set! list-from-hook (hook->list hook))
(test "hook-delete!" #f (member hook-prod (hook->list hook)))
(test "hook->list length after delete 1 proc" 1 (length list-from-hook))

(hook-reset! hook)
(set! list-from-hook (hook->list hook))
(test "hook-reset!" 0 (length list-from-hook))

;; these three will be changed by the hook:
(define hook-arith-var 0)
(define hook-geom-var 0)
(define hook-harmo-var 0)
;; define the following two as zero. the procs that changed their values
;; were removed, so they should NOT be altered.
(set! hook-sum-var 0)
(set! hook-prod-var 1)

;; three procedures:
(define (arith-mean x y) (set! hook-arith-var (/ (+ x y) 2)))
(define (geom-mean x y)  (set! hook-geom-var  (sqrt (* x y))))
(define (harmo-mean x y) (set! hook-harmo-var (/ 1 (+ x y))))

(list->hook! hook (list arith-mean geom-mean harmo-mean))
(test "list->hook! - length of list" 3 (length (hook->list hook)))
(test "add-hook!+run-hook after list->hook"  (list 4 (sqrt 15) 1/8 0 1)
      (begin
        (hook-run hook 3 5)
        (list hook-arith-var
              hook-geom-var
              hook-harmo-var
              hook-sum-var
              hook-prod-var)))

;;  SRFI 176 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 176 - Version flag")

(test "version-alist is list" #t (list? (version-alist)))
(test "scheme.id stklos" 'stklos (cadr (assoc 'scheme.id (version-alist))))
(test "version" (version) (cadr (assoc 'version (version-alist))))
(test "version" (features) (cdr (assoc 'scheme.features (version-alist))))

;; ----------------------------------------------------------------------
;;  SRFI 174 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 174 - POSIX Timespecs")

(require "srfi-174")

(define ts1 (timespec 1 2))
(define ts2 (timespec 1 2))
(define ts3 (timespec 1 3))
(define ts4 (timespec 2 2))
(define ts-neg1 (timespec -1 2))
(define ts-neg2 (timespec -1 5))
(define ts-neg3 (timespec -2 0))


(test "timespec?" #t (timespec? ts1))
(test "not timespec?" #t (not (timespec? #f)))
(test "seconds" 1 (timespec-seconds ts1))
(test "nanos" 2 (timespec-nanoseconds ts1))
(test "equal" #t (timespec=? ts1 ts2))
(test "less nanos" #t (timespec<? ts1 ts3))
(test "less seconds" #t (timespec<? ts1 ts4))
(test "less -nanos" #t (timespec<? ts-neg2 ts-neg1))
(test "less -seconds" #t (timespec<? ts-neg3 ts-neg2))
(test "positive hash" #t (positive? (timespec-hash ts-neg1)))
(test "to inexact" #i1.1 (timespec->inexact (timespec 1 #e1e8)))
(let ((t (timespec 1 1))
      (u (inexact->timespec #i1.000000001)))
  (test "from inexact" t u))

;; ----------------------------------------------------------------------
;;  SRFI 175 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 175 - ASCII character library")

(require "srfi-175")


(test "ascii 1" #f (ascii-codepoint? -1))
(test "ascii 2" #t (ascii-codepoint? 0))
(test "ascii 3" #t (ascii-codepoint? #x7f))
(test "ascii 4" #f (ascii-codepoint? #x80))

(test "ascii 5" #t (ascii-char? (integer->char 0)))
(test "ascii 6" #t (ascii-char? (integer->char #x7f)))
(test "ascii 7" #f (ascii-char? (integer->char #x80)))

(test "ascii 8" #t (ascii-string? ""))
(test "ascii 9" #t (ascii-string? "a"))
(test "ascii 10" #t (ascii-string? "a b c"))
(test "ascii 11" #f (ascii-string? "Ã¥ b o"))
(test "ascii 12" #t (ascii-string? (make-string 1 (integer->char #x7f))))
(test "ascii 13" #f (ascii-string? (make-string 1 (integer->char #x80))))

(test "ascii 14" #t (ascii-bytevector? (string->utf8 "")))
(test "ascii 15" #t (ascii-bytevector? (string->utf8 "a")))
(test "ascii 16" #t (ascii-bytevector? (string->utf8 "a b c")))
(test "ascii 17" #f (ascii-bytevector? (string->utf8 "Ã¥ b o")))
(test "ascii 18" #t (ascii-bytevector?
          (string->utf8 (make-string 1 (integer->char #x7f)))))
(test "ascii 19" #f (ascii-bytevector?
          (string->utf8 (make-string 1 (integer->char #x80)))))

(test "ascii 20" #t (ascii-non-control? #\space))
(test "ascii 21" #f (ascii-non-control? #\tab))
(test "ascii 22" #f (ascii-non-control? #\newline))
(test "ascii 23" #f (ascii-non-control? (integer->char #x0d)))

(test "ascii 24" #t (ascii-space-or-tab? #\space))
(test "ascii 25" #t (ascii-space-or-tab? #\tab))
(test "ascii 26" #f (ascii-space-or-tab? #\newline))
(test "ascii 27" #f (ascii-non-control? (integer->char #x0d)))

(test "ascii 28" #f (ascii-non-control? (integer->char #x00)))
(test "ascii 29" #f (ascii-non-control? (integer->char #x1f)))
(test "ascii 30" #t (ascii-non-control? (integer->char #x20)))
(test "ascii 31" #t (ascii-non-control? (integer->char #x7e)))
(test "ascii 32" #f (ascii-non-control? (integer->char #x7f)))
(test "ascii 33" #f (ascii-non-control? (integer->char #x80)))

(let ((lowers "abcdefghijklmnopqrstuvwxyz")
      (uppers "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
  (let loop ((i 0))
    (when (< i 26)
      (let ((lower (string-ref lowers i))
            (upper (string-ref uppers i)))
        (test "ascii 34" upper (ascii-upcase upper))
        (test "ascii 35" upper (ascii-upcase lower))
        (test "ascii 36" lower (ascii-downcase upper))
        (test "ascii 37" lower (ascii-downcase lower))
        (loop (+ i 1))))))

(let loop ((cc 0))
  (when (< cc #x80)
    (unless (ascii-alphabetic? cc)
      (test "ascii 38" cc (ascii-upcase cc))
      (test "ascii 39" cc (ascii-downcase cc)))
    (loop (+ cc 1))))

(let loop ((cc 0))
  (when (< cc #x80)
    (test "ascii 40" #f (ascii-char? cc))
    (test "ascii 41" #t (ascii-char? (integer->char cc)))
    (cond ((ascii-alphabetic? cc)
           (test "ascii 42" #t (ascii-upper-case? (ascii-upcase cc)))
           (test "ascii 43" #t (ascii-lower-case? (ascii-downcase cc)))
           (test "ascii 44" #f (ascii-lower-case? (ascii-upcase cc)))
           (test "ascii 45" #f (ascii-upper-case? (ascii-downcase cc)))
           (test "ascii 46" #t (ascii-alphanumeric? cc))
           (test "ascii 47" #t (ascii-non-control? cc))
           (test "ascii 48" #f (ascii-other-graphic? cc))
           (test "ascii 49" #f (ascii-control? cc))
           (test "ascii 50" #f (ascii-numeric? cc))
           (test "ascii 51" #f (ascii-whitespace? cc))
           (test "ascii 52" #f (ascii-space-or-tab? cc)))
          ((ascii-control? cc)
           (test "ascii 53" #f (ascii-non-control? cc))
           (test "ascii 54" #f (ascii-other-graphic? cc))
           (test "ascii 55" cc
                 (ascii-graphic->control
                  (ascii-control->graphic cc)))
           (test "ascii 56" (integer->char cc)
                 (ascii-graphic->control
                  (ascii-control->graphic (integer->char cc)))))
          ((member cc '(#\( #\) #\[ #\] #\{ #\} #\< #\>))
           (test "ascii 57" cc (ascii-mirror-bracket (ascii-mirror-bracket cc)))))
    (loop (+ cc 1))))

(let outer ((a 0))
  (when (< a 26)
    (let inner ((b 0))
      (if (= b 26)
          (outer (+ a 1))
          (begin (test "ascii 58" (= a b)  (ascii-ci=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 59" (< a b)  (ascii-ci<?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 60" (<= a b) (ascii-ci<=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 61" (> a b)  (ascii-ci>?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 62" (>= a b) (ascii-ci>=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (inner (+ b 1)))))))

(ascii-ci>? #\A #\_)
(ascii-ci>? #\Z #\_)

(test "ascii 63" #f (ascii-char? -1))
(test "ascii 64" #f (ascii-char? #x80))
(test "ascii 65" #f (ascii-char? (integer->char #x80)))

(test "ascii 66" #f (ascii-control? -1))
(test "ascii 67" #t (ascii-control? #x00))
(test "ascii 68" #t (ascii-control? #x1f))
(test "ascii 69" #f (ascii-control? #x20))
(test "ascii 70" #f (ascii-control? #x7e))
(test "ascii 71" #t (ascii-control? #x7f))
(test "ascii 72" #f (ascii-control? #x80))

(test "ascii 73" 0 (ascii-digit-value #\0 10))
(test "ascii 74" 0 (ascii-digit-value #\0 1))
(test "ascii 75" #f (ascii-digit-value #\0 0))
(test "ascii 76" #f (ascii-digit-value #\0 -1))
(test "ascii 77" 7 (ascii-digit-value #\7 8))
(test "ascii 78" #f (ascii-digit-value #\7 7))
(test "ascii 79" #f (ascii-digit-value #\: 10))

(test "ascii 80" 0 (ascii-upper-case-value #\A 0 26))
(test "ascii 81" 25 (ascii-upper-case-value #\Z 0 26))
(test "ascii 82" #f (ascii-upper-case-value #\Z 0 25))

(test "ascii 83" 0 (ascii-lower-case-value #\a 0 26))
(test "ascii 84" 25 (ascii-lower-case-value #\z 0 26))
(test "ascii 85" #f (ascii-lower-case-value #\z 0 25))

(test "ascii 86" 0 (ascii-lower-case-value #\a 0 1))
(test "ascii 87" #f (ascii-lower-case-value #\a 0 0))
(test "ascii 88" #f (ascii-lower-case-value #\a 0 -1))
(test "ascii 89" 9001 (ascii-lower-case-value #\b 9000 2))

(test "ascii 90" #f (ascii-nth-digit -1))
(test "ascii 91" #\0 (ascii-nth-digit 0))
(test "ascii 92" #\9 (ascii-nth-digit 9))
(test "ascii 93" #f (ascii-nth-digit 10))

(test "ascii 94" #\Z (ascii-nth-upper-case -1))
(test "ascii 95" #\A (ascii-nth-upper-case 0))
(test "ascii 96" #\Z (ascii-nth-upper-case 25))
(test "ascii 97" #\A (ascii-nth-upper-case 26))

(test "ascii 98" #\z (ascii-nth-lower-case -1))
(test "ascii 99" #\a (ascii-nth-lower-case 0))
(test "ascii 100" #\z (ascii-nth-lower-case 25))
(test "ascii 101" #\a (ascii-nth-lower-case 26))

(define (count-matching predicates value)
  (let loop ((ps predicates) (n 0))
    (if (null? ps) n (loop (cdr ps) (if ((car ps) value) (+ n 1) n)))))

(define (union? whole . parts)
  (let check ((cc 0))
    (or (= cc #x80)
        (if (and (whole cc) (not (= 1 (count-matching parts cc))))
            #f (check (+ cc 1))))))

(define (subset? small-set . bigger-sets)
  (let check ((cc 0))
    (or (= cc #x80)
        (if (and (small-set cc) (= 0 (count-matching bigger-sets cc)))
            #f (check (+ cc 1))))))

(define (disjoint? . predicates)
  (let check ((cc 0))
    (or (= cc #x80) (and (<= (count-matching predicates cc) 1)
                         (check (+ cc 1))))))

(test "ascii 102" #t (union? ascii-alphanumeric? ascii-alphabetic? ascii-numeric?))
(test "ascii 103" #t (union? ascii-alphabetic? ascii-upper-case? ascii-lower-case?))

(test "ascii 104" #t (subset? ascii-space-or-tab? ascii-whitespace?))
(test "ascii 105" #t (subset? ascii-other-graphic? ascii-non-control?))
(test "ascii 106" #t (subset? ascii-upper-case?   ascii-alphabetic? ascii-non-control?))
(test "ascii 107" #t (subset? ascii-lower-case?   ascii-alphabetic? ascii-non-control?))
(test "ascii 108" #t (subset? ascii-alphabetic?   ascii-alphanumeric? ascii-non-control?))
(test "ascii 109" #t (subset? ascii-numeric?      ascii-alphanumeric? ascii-non-control?))
(test "ascii 110" #t (subset? ascii-alphanumeric? ascii-non-control?))

(test "ascii 111" #t (disjoint? ascii-control? ascii-non-control?))
(test "ascii 112" #t (disjoint? ascii-whitespace?
                    ascii-other-graphic?
                    ascii-upper-case?
                    ascii-lower-case?
                    ascii-numeric?))
(test "ascii 113" #t (disjoint? ascii-control?
                    ascii-other-graphic?
                    ascii-upper-case?
                    ascii-lower-case?
                    ascii-numeric?))

(define (check-string-ci a b cmp)
  (test "ascii 114" (= cmp 0) (ascii-string-ci=? a b))
  (test "ascii 115" (< cmp 0) (ascii-string-ci<? a b))
  (test "ascii 116" (> cmp 0) (ascii-string-ci>? a b))
  (test "ascii 117" (<= cmp 0) (ascii-string-ci<=? a b))
  (test "ascii 118" (>= cmp 0) (ascii-string-ci>=? a b)))

(check-string-ci "" "" 0)
(check-string-ci "a" "a" 0)
(check-string-ci "A" "a" 0)
(check-string-ci "a" "A" 0)

(check-string-ci "a" "b" -1)
(check-string-ci "b" "a" 1)

(check-string-ci "a" "B" -1)
(check-string-ci "B" "a" 1)

(check-string-ci "aa" "aa" 0)
(check-string-ci "aa" "ab" -1)
(check-string-ci "ab" "aa" 1)
(check-string-ci "aa" "aaa" -1)
(check-string-ci "aaa" "aa" 1)

;; ----------------------------------------------------------------------
;;  SRFI 180 ...
;;
;; The tests here are a small part of the tests from the sample
;; implementation.
;;
;; Other tests (only for json-read and json-write) are also available
;; in the file "./test-json.stk".
;; ----------------------------------------------------------------------
(test-subsection "SRFI 180 - JSON")

(require "srfi-180")

(test "json-generator.1"
      '(42)
      (call-with-input-string "42 101 1337"
                              (lambda (port) (generator->list (json-generator port)))))
(test "json-generator.2"
      '(array-start 42 array-end)
      (call-with-input-string "[42] 101 1337"
                              (lambda (port) (generator->list (json-generator port)))))
(test "json-error"
      #t
      (with-handler (lambda (e) (json-error? e))
                    (call-with-input-string "{" json-read)))

;; ----------------------------------------------------------------------
;;  SRFI 190 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 190 - Coroutine Generators")

(require "srfi-190")

(let ()
  (define g1 (coroutine-generator
           (do ((i 0 (+ i 1)))
               ((<= 5 i))
             (yield i))))

  (define g2 (let ((yield-square (lambda (yield i) (yield (* i i)))))
               (coroutine-generator
                (do ((i 0 (+ i 1)))
                    ((<= 5 i))
                  (yield-square yield i)))))

  (define-coroutine-generator (g3 n)
    (do ((i 0 (+ i 1)))
        ((<= n i))
      (yield i)))

  (test "Coroutine generator.1" '(0 1 2 3 4)
        (generator->list g1))
  (test "Coroutine generator.2" '(0 1 4 9 16)
        (generator->list g2))
  (test "Coroutine generator.3" '(0 1 2 3 4 5 6)
        (generator->list (g3 7))))

;; ----------------------------------------------------------------------
;;  SRFI 62 ...
;; ----------------------------------------------------------------------
;; Tests have been moved here because test 62.5 breaks Emacs fontification

(test-subsection "SRFI 62 - S-expression comments")

(test "srfi-62.1" 5 (+ 1 #;(* 2 3) 4))
(test "srfi-62.2" '(x z) (list 'x #;'y 'z))
(test "srfi-62.3" 12 (* 3 4 #;(+ 1 2)))
(test "srfi-62.4" 16 (#;sqrt abs -16))

(test "srfi-62.5" '(a e) (list 'a #;(list 'b #;c 'd) 'e))
(test "srfi-62.6" '(a . c) '(a . #;b c))
(test "srfi-62.7" '(a . b) '(a . b #;c))


;; ----------------------------------------------------------------------
(test-section-end)
