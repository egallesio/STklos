;;;;
;;;; test-srfi.stk  -- Test of various SRFIs
;;;;
;;;; Copyright © 2005-2020 Erick Gallesio - I3S-CNRS/ESSI <eg@essi.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@essi.fr]
;;;;    Creation date:  4-Aug-2005 10:34 (eg)
;;;; Last file update: 22-Nov-2020 13:05 (eg)
;;;;

(require "test")

(test-section "SRFIs")


;;;
;;; Run all the tests in "./srfi" directory
;;
(include "../lib/srfis.stk")

(dotimes (nb (last-implemented-srfi))
  (let ((desc (find-srfi nb)))
    (when desc                            ;; We have an impl. for this SRFI
      (let ((test-file (format "./srfi/~a.stk" nb)))
        (when (file-exists? test-file)    ;; and we have a test for it
          ;; Add a subsection title
          (test-subsection (format "SRFI ~S - ~S ..." nb (srfi-title desc)))
          ;; Eventually require the SRFI
          (let* ((name    (symbol-append 'srfi- nb))
                 (to-load (srfi-0-feature-implementation-file name)))
            (when to-load
              (for-each (lambda (x)
                          ;; /!\ do not use the function but the require macro!!
                          (require x)) 
                        to-load)))
          ;; Run the tests
          (load test-file))))))





;; ----------------------------------------------------------------------
;;  SRFI 113 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 113 - Sets and bags")

(require "srfi-113")

;;; Below are some default comparators provided by SRFI-114,
;;; but not SRFI-128, which this SRFI has transitioned to
;;; depend on. See the rationale for SRFI-128 as to why it is
;;; preferred in usage compared to SRFI-114.

;; Most if not all of this code is taken from SRFI-114

(define exact inexact->exact)

(define string-foldcase string-downcase)

(define (make-comparison=/< = <)
  (lambda (a b)
    (cond
      ((= a b) 0)
      ((< a b) -1)
      (else 1))))

;; Comparison procedure for real numbers only
(define (real-comparison a b)
  (cond
    ((< a b) -1)
    ((> a b) 1)
    (else 0)))

;; Comparison procedure for non-real numbers.
(define (complex-comparison a b)
  (let ((real-result (real-comparison (real-part a) (real-part b))))
    (if (= real-result 0)
      (real-comparison (imag-part a) (imag-part b))
      real-result)))

(define (number-hash obj) (exact (abs obj)))

(define number-comparator
  (make-comparator number? = complex-comparison number-hash))

(define char-comparison (make-comparison=/< char=? char<?))

;; not necesary, and interferes with SRFI-128:
;; (define (char-hash obj) (abs (char->integer obj)))

(define char-comparator
  (make-comparator char? char=? char-comparison char-hash))

;; Makes a hash function that works vectorwise
(define limit (expt 2 20))

(define (make-vectorwise-hash hash length ref)
  (lambda (obj)
    (let loop ((index (- (length obj) 1)) (result 5381))
      (if (= index 0)
        result
        (let* ((prod (modulo (* result 33) limit))
               (sum (modulo (+ prod (hash (ref obj index))) limit)))
          (loop (- index 1) sum))))))

;; not necesary, and interferes with SRFI-128:
;; (define string-hash
;;   (make-vectorwise-hash char-hash string-length string-ref))

(define string-comparison (make-comparison=/< string=? string<?))

(define string-ci-comparison (make-comparison=/< string-ci=? string-ci<?))

(define string-comparator
  (make-comparator string? string=? string-comparison string-hash))

(define (string-ci-hash obj) (string-hash (string-foldcase obj)))

(define string-ci-comparator
  (make-comparator string? string-ci=? string-ci-comparison string-ci-hash))

(define eq-comparator
  (make-comparator
    #t
    eq?
    #f
    default-hash))

(define eqv-comparator
  (make-comparator
    #t
    eqv?
    #f
    default-hash))

(define equal-comparator
  (make-comparator
    #t
    equal?
    #f
    default-hash))

;;;
;;; END of srfi-114 piece
;;;


;;; sets/simple

(define (big x) (> x 5))

(define nums (set number-comparator))
;; nums is now {}
(define syms (set eq-comparator 'a 'b 'c 'd))
;; syms is now {a, b, c, d}
(define nums2 (set-copy nums))
;; nums2 is now {}
(define syms2 (set-copy syms))
;; syms2 is now {a, b, c, d}
(define esyms (set eq-comparator))
;; esyms is now {}
(test "test/simple 1" #t (set-empty? esyms))
(define total 0)
(test "test/simple 2" #t (set? nums))
(test "test/simple 3" #t (set? syms))
(test "test/simple 4" #t (set? nums2))
(test "test/simple 5" #t (set? syms2))
(test "test/simple 6" #t (not (set? 'a)))
(set-adjoin! nums 2)
(set-adjoin! nums 3)
(set-adjoin! nums 4)
(set-adjoin! nums 4)
;; nums is now {2, 3, 4}
(test "test/simple 7" 4 (set-size (set-adjoin nums 5)))
(test "test/simple 8" 3 (set-size nums))
(test "test/simple 9" 3 (set-size (set-delete syms 'd)))
(test "test/simple 10" 2 (set-size (set-delete-all syms '(c d))))
(test "test/simple 11" 4 (set-size syms))
(set-adjoin! syms 'e 'f)
;; syms is now {a, b, c, d, e, f}
(test "test/simple 12" 4 (set-size (set-delete-all! syms '(e f))))
;; syms is now {a, b, c, d}
(test "test/simple 13" 0 (set-size nums2))
(test "test/simple 14" 4 (set-size syms2))
(set-delete! nums 2)
;; nums is now {3, 4}
(test "test/simple 15" 2 (set-size nums))
(set-delete! nums 1)
(test "test/simple 16" 2 (set-size nums))
(set! nums2 (set-map number-comparator (lambda (x) (* 10 x)) nums))
;; nums2 is now {30, 40}
(test "test/simple 17" #t (set-contains? nums2 30))
(test "test/simple 18" #t (not (set-contains? nums2 3)))
(set-for-each (lambda (x) (set! total (+ total x))) nums2)
(test "test/simple 19" 70 total)
(test "test/simple 20" 10 (set-fold + 3 nums))
(set! nums (set eqv-comparator 10 20 30 40 50))
;; nums is now {10, 20, 30, 40, 50}
(test "test/simple 21" #t
    (set=? nums (set-unfold
                 (lambda (i) (= i 0))
                 (lambda (i) (* i 10))
                 (lambda (i) (- i 1))
                 5
                 eqv-comparator)))
(test "test/simple 22" '(a) (set->list (set eq-comparator 'a)))
(set! syms2 (list->set eq-comparator '(e f)))
;; syms2 is now {e, f}
(test "test/simple 23" 2  (set-size syms2))
(test "test/simple 24" #t (set-contains? syms2 'e))
(test "test/simple 25" #t (set-contains? syms2 'f))
(list->set! syms2 '(a b))
(test "test/simple 26" 4 (set-size syms2))



;;; sets/search

(define yam (set char-comparator #\y #\a #\m))
(define (failure/insert insert ignore)
  (insert 1))
(define (failure/ignore insert ignore)
  (ignore 2))
(define (success/update element update remove)
  (update #\b 3))
(define (success/remove element update remove)
  (remove 4))
(define yam! (set char-comparator #\y #\a #\m #\!))
(define bam (set char-comparator #\b #\a #\m))
(define ym (set char-comparator #\y #\m))
(define set1 #f)
(define obj1 #f)
(define-values (set1 obj1)
  (set-search! (set-copy yam) #\! failure/insert error))
(test "sets/search 1" #t (set=? yam! set1))
(test "sets/search 2" 1 obj1)
(define-values (set2 obj2)
  (set-search! (set-copy yam) #\! failure/ignore error))
(test "sets/search 3" #t (set=? yam set2))
(test "sets/search 4" 2 obj2)
(define-values (set3 obj3)
  (set-search! (set-copy yam) #\y error success/update))
(test "sets/search 5" #t (set=? bam set3))
(test "sets/search 6" 3 obj3)
(define-values (set4 obj4)
  (set-search! (set-copy yam) #\a error success/remove))
(test "sets/search 7" #t (set=? ym set4))
(test "sets/search 8" 4 obj4)


;;; sets/subsets
  (define set2 (set number-comparator 1 2))
  (define other-set2 (set number-comparator 1 2))
  (define set3 (set number-comparator 1 2 3))
  (define set4 (set number-comparator 1 2 3 4))
  (define sety (set number-comparator 1 2 4 5))
  (define setx (set number-comparator 10 20 30 40))
  (test "sets/subsets 1" #t (set=? set2 other-set2))
  (test "sets/subsets 2" #t (not (set=? set2 set3)))
  (test "sets/subsets 3" #t (not (set=? set2 set3 other-set2)))
  (test "sets/subsets 4" #t (set<? set2 set3 set4))
  (test "sets/subsets 5" #t (not (set<? set2 other-set2)))
  (test "sets/subsets 6" #t (set<=? set2 other-set2 set3))
  (test "sets/subsets 7" #t (not (set<=? set2 set3 other-set2)))
  (test "sets/subsets 8" #t (set>? set4 set3 set2))
  (test "sets/subsets 9" #t (not (set>? set2 other-set2)))
  (test "sets/subsets 10" #t (set>=? set3 other-set2 set2))
  (test "sets/subsets 11" #t (not (set>=? other-set2 set3 set2)))
  (test "sets/subsets 12" #t (not (set<? set2 other-set2)))
  (test "sets/subsets 13" #t (not (set<? set2 setx)))
  (test "sets/subsets 14" #t (not (set<=? set2 setx)))
  (test "sets/subsets 15" #t (not (set>? set2 setx)))
  (test "sets/subsets 16" #t (not (set>=? set2 setx)))
  (test "sets/subsets 17" #t (not (set<?  set3 sety)))
  (test "sets/subsets 18" #t (not (set<=? set3 sety)))
  (test "sets/subsets 19" #t (not (set>?  set3 sety)))
  (test "sets/subsets 20" #t (not (set>=? set3 sety)))

;;; "sets/ops"
  ;; Potentially mutable
  (define abcd (set eq-comparator 'a 'b 'c 'd))
  (define efgh (set eq-comparator 'e 'f 'g 'h))
  (define abgh (set eq-comparator 'a 'b 'g 'h))
  ;; Never get a chance to be mutated
  (define other-abcd (set eq-comparator 'a 'b 'c 'd))
  (define other-efgh (set eq-comparator 'e 'f 'g 'h))
  (define other-abgh (set eq-comparator 'a 'b 'g 'h))
  (define all (set eq-comparator 'a 'b 'c 'd 'e 'f 'g 'h))
  (define none (set eq-comparator))
  (define ab (set eq-comparator 'a 'b))
  (define cd (set eq-comparator 'c 'd))
  (define ef (set eq-comparator 'e 'f))
  (define gh (set eq-comparator 'g 'h))
  (define cdgh (set eq-comparator 'c 'd 'g 'h))
  (define abcdgh (set eq-comparator 'a 'b 'c 'd 'g 'h))
  (define abefgh (set eq-comparator 'a 'b 'e 'f 'g 'h))
  (test "sets/ops 1" #t (set-disjoint? abcd efgh))
  (test "sets/ops 2" #t (not (set-disjoint? abcd ab)))

(define efgh2 #f)
(define abcd2 #f)
(define abcd3 #f)
(define abcd4 #f)

;; ;(parameterize ((current-test-comparator set=?))

(test "sets/ops 3" #t (set=? abcd (set-union abcd)))
(test "sets/ops 4" #t (set=? all (set-union abcd efgh)))
(test "sets/ops 5" #t (set=? abcdgh (set-union abcd abgh)))
(test "sets/ops 6" #t (set=? abefgh (set-union efgh abgh)))
(set! efgh2 (set-copy efgh))
(set-union! efgh2)
(test "sets/ops 7" #t (set=? efgh efgh2))
(set-union! efgh2 abgh)
(test "sets/ops 8" #t (set=? abefgh efgh2))
(test "sets/ops 9" #t (set=? abcd (set-intersection abcd)))
(test "sets/ops 10" #t (set=? none (set-intersection abcd efgh)))
(set! abcd2 (set-copy abcd))
(set-intersection! abcd2)
(test "sets/ops 11" #t (set=? abcd abcd2))
(set-intersection! abcd2 efgh)
(test "sets/ops 12" #t (set=? none abcd2))
(test "sets/ops 13" #t (set=? ab (set-intersection abcd abgh)))
(test "sets/ops 14" #t (set=? ab (set-intersection abgh abcd)))
(test "sets/ops 15" #t (set=? abcd (set-difference abcd)))
(test "sets/ops 16" #t (set=? cd (set-difference abcd ab)))
(test "sets/ops 17" #t (set=? abcd (set-difference abcd gh)))
(test "sets/ops 18" #t (set=? none (set-difference abcd abcd)))
(set! abcd3 (set-copy abcd))
(set-difference! abcd3)
(test "sets/ops 19" #t (set=? abcd abcd3))
(set-difference! abcd3 abcd)
(test "sets/ops 20" #t (set=? none abcd3))
(test "sets/ops 21" #t (set=? cdgh (set-xor abcd abgh)))
(test "sets/ops 22" #t (set=? all (set-xor abcd efgh)))
(test "sets/ops 23" #t (set=? none (set-xor abcd other-abcd)))
(set! abcd4 (set-copy abcd))
;; don't test xor! effect
(test "sets/ops 24" #t (set=? none (set-xor! abcd4 other-abcd)))
(test "sets/ops 25" #t (set=? other-abcd abcd)) ; "abcd smashed?"
(test "sets/ops 26" #t (set=? other-efgh efgh)) ; "efgh smashed?"
(test "sets/ops 27" #t (set=? other-abgh abgh)) ; "abgh smashed?"

;;; STklos test system won't catch syntax error; skip these
;; ;;; "sets/mismatch"
;;   (define nums (set number-comparator 1 2 3))
;;   (define syms (set eq-comparator 'a 'b 'c))
;;   (test/error (set=? nums syms))
;;   (test/error (set<? nums syms))
;;   (test/error (set<=? nums syms))
;;   (test/error (set>? nums syms))
;;   (test/error (set>=? nums syms))
;;   (test/error (set-union nums syms))
;;   (test/error (set-intersection nums syms))
;;   (test/error (set-difference nums syms))
;;   (test/error (set-xor nums syms))
;;   (test/error (set-union! nums syms))
;;   (test/error (set-intersection! nums syms))
;;   (test/error (set-difference! nums syms))
;;   (test/error (set-xor! nums syms))


;; ;;; "sets/whole"
  (define whole (set eqv-comparator 1 2 3 4 5 6 7 8 9 10))
  (define whole2 (set-copy whole))
  (define whole3 (set-copy whole))
  (define whole4 (set-copy whole))
  (define bottom (set eqv-comparator 1 2 3 4 5))
  (define top (set eqv-comparator 6 7 8 9 10))
(define-values (topx bottomx)
    (set-partition big whole))
  (set-partition! big whole4)
;;   (parameterize ((current-test-comparator set=?))
    (test "sets/whole 1" #t (set=? top (set-filter big whole)))
    (test "sets/whole 2" #t (set=? bottom (set-remove big whole)))
    (set-filter! big whole2)
    (test "sets/whole 3" #t (not (set-contains? whole2 1)))
    (set-remove! big whole3)
    (test "sets/whole 4" #t (not (set-contains? whole3 10)))
    (test "sets/whole 5" #t (set=? top topx))
    (test "sets/whole 6" #t (set=? bottom bottomx))
    (test "sets/whole 7" #t (set=? top whole4))
  (test "sets/whole 8" 5 (set-count big whole))
  (define hetero (set eqv-comparator 1 2 'a 3 4))
  (define homo (set eqv-comparator 1 2 3 4 5))
  (test "sets/whole 8" 'a (set-find symbol? hetero (lambda () (error "wrong"))))
  (test/error  "sets/whole 9" (set-find symbol? homo (lambda () (error "wrong"))))
  (test "sets/whole 10" #t (set-any? symbol? hetero))
  (test "sets/whole 11" #t (set-any? number? hetero))
  (test "sets/whole 12" #t (not (set-every? symbol? hetero)))
  (test "sets/whole 13" #t (not (set-every? number? hetero)))
  (test "sets/whole 14" #t (not (set-any? symbol? homo)))
  (test "sets/whole 15" #t (set-every? number? homo))


;;; "sets/lowlevel"
  (define bucket (set string-ci-comparator "abc" "def"))
  (test "sets/lowlevel 1" string-ci-comparator (set-element-comparator bucket))
  (test "sets/lowlevel 2" #t (set-contains? bucket "abc"))
  (test "sets/lowlevel 3" #t (set-contains? bucket "ABC"))
  (test "sets/lowlevel 4" "def" (set-member bucket "DEF" "fqz"))
  (test "sets/lowlevel 5" "fqz" (set-member bucket "lmn" "fqz"))
  (define nums (set number-comparator 1 2 3))
  ;; nums is now {1, 2, 3}
  (define nums2 (set-replace nums 2.0))
  ;; nums2 is now {1, 2.0, 3}
  (test "sets/lowlevel 6" #t (set-any? inexact? nums2))
  (set-replace! nums 2.0)
  ;; nums is now {1, 2.0, 3}
  (test "sets/lowlevel 6" #t (set-any? inexact? nums))
  (define sos
    (set set-comparator
      (set equal-comparator '(2 . 1) '(1 . 1) '(0 . 2) '(0 . 0))
      (set equal-comparator '(2 . 1) '(1 . 1) '(0 . 0) '(0 . 2))))
  (test "sets/lowlevel 5" 1 (set-size sos))


;;; "bags/simple"
  (define nums (bag number-comparator))
  ;; nums is now {}
  (define syms (bag eq-comparator 'a 'b 'c 'd))
  ;; syms is now {a, b, c, d}
  (define nums2 (bag-copy nums))
  ;; nums2 is now {}
  (define syms2 (bag-copy syms))
  ;; syms2 is now {a, b, c, d}
  (define esyms (bag eq-comparator))
  ;; esyms is now {}
  (test "bags/simple 1" #t (bag-empty? esyms))
  (define total 0)
  (test "bags/simple 2" #t (bag? nums))
  (test "bags/simple 3" #t (bag? syms))
  (test "bags/simple 4" #t (bag? nums2))
  (test "bags/simple 5" #t (bag? syms2))
  (test "bags/simple 6" #t (not (bag? 'a)))
  (bag-adjoin! nums 2)
  (bag-adjoin! nums 3)
  (bag-adjoin! nums 4)
  ;; nums is now {2, 3, 4}
  (test "bags/simple 7" 4 (bag-size (bag-adjoin nums 5)))
  (test "bags/simple 8" 3 (bag-size nums))
  (test "bags/simple 9" 3 (bag-size (bag-delete syms 'd)))
  (test "bags/simple 10" 2 (bag-size (bag-delete-all syms '(c d))))
  (test "bags/simple 11" 4 (bag-size syms))
  (bag-adjoin! syms 'e 'f)
  ;; syms is now {a, b, c, d, e, f}
  (test "bags/simple 12" 4 (bag-size (bag-delete-all! syms '(e f))))
  ;; syms is now {a, b, c, d}
  (test "bags/simple 13" 3 (bag-size nums))
  (bag-delete! nums 1)
  (test "bags/simple 14" 3 (bag-size nums))
  (set! nums2 (bag-map number-comparator (lambda (x) (* 10 x)) nums))
  ;; nums2 is now {20, 30, 40}
  (test "bags/simple 15" #t (bag-contains? nums2 30))
  (test "bags/simple 16" #t (not (bag-contains? nums2 3)))
  (bag-for-each (lambda (x) (set! total (+ total x))) nums2)
  (test "bags/simple 17" 90 total)
  (test "bags/simple 18" 12 (bag-fold + 3 nums))
  (set! nums (bag eqv-comparator 10 20 30 40 50))
  ;; nums is now {10, 20, 30, 40, 50}
  (test "bags/simple 19" #t
    (bag=? nums (bag-unfold
       (lambda (i) (= i 0))
       (lambda (i) (* i 10))
       (lambda (i) (- i 1))
       5
       eqv-comparator)))
  (test "bags/simple 20" '(a) (bag->list (bag eq-comparator 'a)))
  (set! syms2 (list->bag eq-comparator '(e f)))
  ;; syms2 is now {e, f}
  (test "bags/simple 21" 2 (bag-size syms2))
  (test "bags/simple 22" #t (bag-contains? syms2 'e))
  (test "bags/simple 23" #t (bag-contains? syms2 'f))
  (list->bag! syms2 '(e f))
  ;; syms2 is now {e, e, f, f}
  (test "bags/simple 24" 4 (bag-size syms2))


;;; "bags/search"
  (define yam (bag char-comparator #\y #\a #\m))
  (define (failure/insert insert ignore)
    (insert 1))
  (define (failure/ignore insert ignore)
    (ignore 2))
  (define (success/update element update remove)
    (update #\b 3))
  (define (success/remove element update remove)
    (remove 4))
  (define yam! (bag char-comparator #\y #\a #\m #\!))
  (define bam (bag char-comparator #\b #\a #\m))
  (define ym (bag char-comparator #\y #\m))
  (define-values (bag1 obj1)
    (bag-search! (bag-copy yam) #\! failure/insert error))
  (test "bags/search 1" #t (bag=? yam! bag1))
  (test "bags/search 2" 1 obj1)
  (define-values (bag2 obj2)
    (bag-search! (bag-copy yam) #\! failure/ignore error))
  (test "bags/search 3" #t (bag=? yam bag2))
  (test "bags/search 4" 2 obj2)
  (define-values (bag3 obj3)
    (bag-search! (bag-copy yam) #\y error success/update))
  (test "bags/search 5" #t (bag=? bam bag3))
  (test "bags/search 6" 3 obj3)
  (define-values (bag4 obj4)
    (bag-search! (bag-copy yam) #\a error success/remove))
  (test "bags/search 7" #t (bag=? ym bag4))
  (test "bags/search 8" 4 obj4)


;;; "bags/elemcount"
  (define mybag (bag eqv-comparator 1 1 1 1 1 2 2))
  (test "bags/elemcount 1" 5 (bag-element-count mybag 1))
  (test "bags/elemcount 2" 0 (bag-element-count mybag 3))


;;; "bags/subbags"
  (define bag2 (bag number-comparator 1 2))
  (define other-bag2 (bag number-comparator 1 2))
  (define bag3 (bag number-comparator 1 2 3))
  (define bag4 (bag number-comparator 1 2 3 4))
  (define bagx (bag number-comparator 10 20 30 40))
  (define bagy (bag number-comparator 10 20 20 30 40))
  (test "bags/subbags 1" #t (bag=? bag2 other-bag2))
  (test "bags/subbags 2" #t (not (bag=? bag2 bag3)))
  (test "bags/subbags 3" #t (not (bag=? bag2 bag3 other-bag2)))
  (test "bags/subbags 4" #t (bag<? bag2 bag3 bag4))
  (test "bags/subbags 5" #t (not (bag<? bag2 other-bag2)))
  (test "bags/subbags 6" #t (bag<=? bag2 other-bag2 bag3))
  (test "bags/subbags 7" #t (not (bag<=? bag2 bag3 other-bag2)))
  (test "bags/subbags 8" #t (bag>? bag4 bag3 bag2))
  (test "bags/subbags 9" #t (not (bag>? bag2 other-bag2)))
  (test "bags/subbags 10" #t (bag>=? bag3 other-bag2 bag2))
  (test "bags/subbags 11" #t (not (bag>=? other-bag2 bag3 bag2)))
  (test "bags/subbags 12" #t (not (bag<? bag2 other-bag2)))
  (test "bags/subbags 13" #t (bag<=? bagx bagy))
  (test "bags/subbags 14" #t (not (bag<=? bagy bagx)))
  (test "bags/subbags 15" #t (bag<? bagx bagy))
  (test "bags/subbags 16" #t (not (bag<? bagy bagx)))
  (test "bags/subbags 17" #t (bag>=? bagy bagx))
  (test "bags/subbags 18" #t (not (bag>=? bagx bagy)))
  (test "bags/subbags 19" #t (bag>? bagy bagx))
  (test "bags/subbags 20" #t (not (bag>? bagx bagy)))


;;; "bags/multi"
  (define one (bag eqv-comparator 10))
  (define two (bag eqv-comparator 10 10))
  (test "bags/multi 1" #t (not (bag=? one two)))
  (test "bags/multi 2" #t (bag<? one two))
  (test "bags/multi 3" #t (not (bag>? one two)))
  (test "bags/multi 4" #t (bag<=? one two))
  (test "bags/multi 5" #t (not (bag>? one two)))
  (test "bags/multi 6" #t (bag=? two two))
  (test "bags/multi 7" #t (not (bag<? two two)))
  (test "bags/multi 8" #t (not (bag>? two two)))
  (test "bags/multi 9"  #t (bag<=? two two))
  (test "bags/multi 10" #t (bag>=? two two))
  (test "bags/multi 11"
        '((10 . 2))
        (let ((result '()))
          (bag-for-each-unique
           (lambda (x y) (set! result (cons (cons x y) result)))
           two)
          result))
  (test "bags/multi 12" 25 (bag-fold + 5 two))
  (test "bags/multi 13" 12 (bag-fold-unique (lambda (k n r) (+ k n r)) 0 two))


;;; "bags/ops"
  ;; Potentially mutable
  (define abcd (bag eq-comparator 'a 'b 'c 'd))
  (define efgh (bag eq-comparator 'e 'f 'g 'h))
  (define abgh (bag eq-comparator 'a 'b 'g 'h))
  ;; Never get a chance to be mutated
  (define other-abcd (bag eq-comparator 'a 'b 'c 'd))
  (define other-efgh (bag eq-comparator 'e 'f 'g 'h))
  (define other-abgh (bag eq-comparator 'a 'b 'g 'h))
  (define all (bag eq-comparator 'a 'b 'c 'd 'e 'f 'g 'h))
  (define none (bag eq-comparator))
  (define ab (bag eq-comparator 'a 'b))
  (define cd (bag eq-comparator 'c 'd))
  (define ef (bag eq-comparator 'e 'f))
  (define gh (bag eq-comparator 'g 'h))
  (define cdgh (bag eq-comparator 'c 'd 'g 'h))
  (define abcdgh (bag eq-comparator 'a 'b 'c 'd 'g 'h))
  (define abefgh (bag eq-comparator 'a 'b 'e 'f 'g 'h))
  (test "bags/ops 1" #t (bag-disjoint? abcd efgh))
  (test "bags/ops 2" #t (not (bag-disjoint? abcd ab)))
;(parameterize ((current-test-comparator bag=?))
    (test "bags/ops " #t (bag=? abcd (bag-union abcd)))
    (test "bags/ops " #t (bag=? all (bag-union abcd efgh)))
    (test "bags/ops " #t (bag=? abcdgh (bag-union abcd abgh)))
    (test "bags/ops " #t (bag=? abefgh (bag-union efgh abgh)))
    (define efgh2 (bag-copy efgh))
    (bag-union! efgh2)
    (test "bags/ops " #t (bag=? efgh efgh2))
    (bag-union! efgh2 abgh)
    (test "bags/ops " #t (bag=? abefgh efgh2))
    (test "bags/ops " #t (bag=? abcd (bag-intersection abcd)))
    (test "bags/ops " #t (bag=? none (bag-intersection abcd efgh)))
    (define abcd2 (bag-copy abcd))
    (bag-intersection! abcd2)
    (test "bags/ops " #t (bag=? abcd abcd2))
    (bag-intersection! abcd2 efgh)
    (test "bags/ops " #t (bag=? none abcd2))
    (test "bags/ops " #t (bag=? ab (bag-intersection abcd abgh)))
    (test "bags/ops " #t (bag=? ab (bag-intersection abgh abcd)))
    (test "bags/ops " #t (bag=? abcd (bag-difference abcd)))
    (test "bags/ops " #t (bag=? cd (bag-difference abcd ab)))
    (test "bags/ops " #t (bag=? abcd (bag-difference abcd gh)))
    (test "bags/ops " #t (bag=? none (bag-difference abcd abcd)))
    (define abcd3 (bag-copy abcd))
    (bag-difference! abcd3)
    (test "bags/ops " #t (bag=? abcd abcd3))
    (bag-difference! abcd3 abcd)
    (test "bags/ops " #t (bag=? none abcd3))
    (test "bags/ops " #t (bag=? cdgh (bag-xor abcd abgh)))
    (test "bags/ops " #t (bag=? all (bag-xor abcd efgh)))
    (test "bags/ops " #t (bag=? none (bag-xor abcd other-abcd)))
    (define abcd4 (bag-copy abcd))
    (test "bags/ops " #t (bag=? none (bag-xor! abcd4 other-abcd)))
    (define abab (bag eq-comparator 'a 'b 'a 'b))
    (test "bags/ops " #t (bag=? ab (bag-sum ab)))
    (define ab2 (bag-copy ab))
    (test "bags/ops " #t (bag=? ab (bag-sum! ab2)))
    (test "bags/ops " #t (bag=? abab (bag-sum! ab2 ab)))
    (test "bags/ops " #t (bag=? abab ab2))
    (test "bags/ops " #t (bag=? abab (bag-product 2 ab)))
    (define ab3 (bag-copy ab))
    (bag-product! 2 ab3)
    (test "bags/ops " #t (bag=? abab ab3))
    (test "bags/ops " #t (bag=?  other-abcd abcd)) ; "abcd smashed?"
    (test "bags/ops " #t (bag=?  other-abcd abcd)) ; "abcd smashed?"
    (test "bags/ops " #t (bag=?  other-efgh efgh)) ; "efgh smashed?"
    (test "bags/ops " #t (bag=?  other-abgh abgh)) ; "abgh smashed?"

;;; STklos test system won't catch syntax error; skip these
;; (test-group "bags/mismatch"
;;   (define nums (bag number-comparator 1 2 3))
;;   (define syms (bag eq-comparator 'a 'b 'c))
;;   (test/error (bag=? nums syms))
;;   (test/error (bag<? nums syms))
;;   (test/error (bag<=? nums syms))
;;   (test/error (bag>? nums syms))
;;   (test/error (bag>=? nums syms))
;;   (test/error (bag-union nums syms))
;;   (test/error (bag-intersection nums syms))
;;   (test/error (bag-difference nums syms))
;;   (test/error (bag-xor nums syms))
;;   (test/error (bag-union! nums syms))
;;   (test/error (bag-intersection! nums syms))
;;   (test/error (bag-difference! nums syms))
;; ) ; end bags/mismatch

;;; "bags/whole"
  (define whole (bag eqv-comparator 1 2 3 4 5 6 7 8 9 10))
  (define whole2 (bag-copy whole))
  (define whole3 (bag-copy whole))
  (define whole4 (bag-copy whole))
  (define bottom (bag eqv-comparator 1 2 3 4 5))
  (define top (bag eqv-comparator 6 7 8 9 10))
  (define-values (topx bottomx)
    (bag-partition big whole))
  (bag-partition! big whole4)
;  (parameterize ((current-test-comparator bag=?))
    (test "bags/whole 1" #t (bag=? top (bag-filter big whole)))
    (test "bags/whole 2" #t (bag=? bottom (bag-remove big whole)))
    (bag-filter! big whole2)
    (test "bags/whole 3" #t (not (bag-contains? whole2 1)))
    (bag-remove! big whole3)
    (test "bags/whole 4" #t (not (bag-contains? whole3 10)))
    (test "bags/whole 5" #t (bag=? top topx))
    (test "bags/whole 6" #t (bag=? bottom bottomx))
    (test "bags/whole 7" #t (bag=? top whole4))
  (test "bags/whole 8" 5 (bag-count big whole))
  (define hetero (bag eqv-comparator 1 2 'a 3 4))
  (define homo (bag eqv-comparator 1 2 3 4 5))
  (test "bags/simple 9" 'a (bag-find symbol? hetero (lambda () (error "wrong"))))
  (test/error  "bags/simple 10" (bag-find symbol? homo (lambda () (error "wrong"))))
  (test "bags/simple 11" #t (bag-any? symbol? hetero))
  (test "bags/simple 12" #t (bag-any? number? hetero))
  (test "bags/simple 13" #t (not (bag-every? symbol? hetero)))
  (test "bags/simple 14" #t (not (bag-every? number? hetero)))
  (test "bags/simple 15" #t (not (bag-any? symbol? homo)))
  (test "bags/simple 16" #t (bag-every? number? homo))


;;; "bags/lowlevel"
  (define bucket (bag string-ci-comparator "abc" "def"))
  (test "bags/lowlevel 0"  string-ci-comparator (bag-element-comparator bucket))
  (test "bags/lowlevel 1" #t (bag-contains? bucket "abc"))
  (test "bags/lowlevel 2" #t (bag-contains? bucket "ABC"))
  (test "bags/lowlevel 3" "def" (bag-member bucket "DEF" "fqz"))
  (test "bags/lowlevel 4" "fqz" (bag-member bucket "lmn" "fqz"))
  (define nums (bag number-comparator 1 2 3))
  ;; nums is now {1, 2, 3}
  (define nums2 (bag-replace nums 2.0))
  ;; nums2 is now {1, 2.0, 3}
  (test "bags/lowlevel 5" #t (bag-any? inexact? nums2))
  (bag-replace! nums 2.0)
  ;; nums is now {1, 2.0, 3}
  (test "bags/lowlevel 6" #t (bag-any? inexact? nums))
  (define bob
    (bag bag-comparator
      (bag eqv-comparator 1 2)
      (bag eqv-comparator 1 2)))
  (test "bags/lowlevel 7" 2 (bag-size bob))



;;; "bags/semantics"
  (define mybag (bag number-comparator 1 2))
  ;; mybag is {1, 2}
  (test "bags/semantics 1" 2 (bag-size mybag))
  (bag-adjoin! mybag 1)
  ;; mybag is {1, 1, 2}
  (test "bags/semantics 2" 3 (bag-size mybag))
  (test "bags/semantics 3" 2 (bag-unique-size mybag))
  (bag-delete! mybag 2)
  ;; mybag is {1, 1}
  (bag-delete! mybag 2)
  (test "bags/semantics 4" 2 (bag-size mybag))
  (bag-increment! mybag 1 3)
  ;; mybag is {1, 1, 1, 1, 1}
  (test "bags/semantics 5" 5 (bag-size mybag))
  (test "bags/semantics 6" #t (not (not (bag-decrement! mybag 1 2))))
  ;; mybag is {1, 1, 1}
  (test "bags/semantics 7" 3 (bag-size mybag))
  (bag-decrement! mybag 1 5)
  ;; mybag is {}
  (test "bags/semantics 8" 0 (bag-size mybag))


;;; "bags/convert"
  (define multi (bag eqv-comparator 1 2 2 3 3 3))
  (define single (bag eqv-comparator 1 2 3))
  (define singleset (set eqv-comparator 1 2 3))
  (define minibag (bag eqv-comparator 'a 'a))
  (define alist '((a . 2)))
  (test "bags/convert 1" alist (bag->alist minibag))
  (test "bags/convert 2" #t (bag=? minibag (alist->bag eqv-comparator alist)))
  (test "bags/convert 3" #t (set=? singleset (bag->set single)))
  (test "bags/convert 4" #t (set=? singleset (bag->set multi)))
  (test "bags/convert 5" #t (bag=? single (set->bag singleset)))
  (test "bags/convert 6" #t (not (bag=? multi (set->bag singleset))))
  (set->bag! minibag singleset)
  ;; minibag is now {a, a, a, a, 1, 2, 3}
  (test "bags/convert 7" #t (bag-contains? minibag 1))


;;; "bags/sumprod"
  (define abb (bag eq-comparator 'a 'b 'b))
  (define aab (bag eq-comparator 'a 'a 'b))
  (define total (bag-sum abb aab))
  (test "bags/sumprod 1" 3 (bag-count (lambda (x) (eqv? x 'a)) total))
  (test "bags/sumprod 2" 3 (bag-count (lambda (x) (eqv? x 'b)) total))
  (test "bags/sumprod 3" 12 (bag-size (bag-product 2 total)))
  (define bag1 (bag eqv-comparator 1))
  (bag-sum! bag1 bag1)
  (test "bags/sumprod 4" 2 (bag-size bag1))
  (bag-product! 2 bag1)
  (test "bags/sumprod 5" 4 (bag-size bag1))


;;; "comparators"
  (define a (set number-comparator 1 2 3))
  (define b (set number-comparator 1 2 4))
  (define aa (bag number-comparator 1 2 3))
  (define bb (bag number-comparator 1 2 4))
  (test "bags/comparators 1" #t (not (=? set-comparator a b)))
  (test "bags/comparators 2" #t (=? set-comparator a (set-copy a)))
;;  (test/error (<? set-comparator a b))
  (test "bags/comparators 3" #t (not (=? bag-comparator aa bb)))
  (test "bags/comparators 4" #t (=? bag-comparator aa (bag-copy aa)))
;;  (test/error (<? bag-comparator aa bb))
  (test "bags/comparators 5" #t (not (=? (make-default-comparator) a aa)))


;; ----------------------------------------------------------------------
;;  SRFI 117 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 117 - Queues based on lists")

(require "srfi-117")

;; list-queues/simple
(test "make-list-queue"  '(1 1 1) (list-queue-list (make-list-queue '(1 1 1))))
(define x (list-queue 1 2 3))
(test "list-queue-list" '(1 2 3) (list-queue-list x))
(define x1 (list 1 2 3))
(define x2 (make-list-queue x1 (cddr x1)))
(test "list-queue-back" 3 (list-queue-back x2))
(define y (list-queue 4 5))
(test "list-queue?" #t (list-queue? y))
(define z (list-queue-append x y))
(test "list-queue-append" '(1 2 3 4 5) (list-queue-list z))
(define z2 (list-queue-append! x (list-queue-copy y)))
(test "list-queue-append-copy" '(1 2 3 4 5) (list-queue-list z2))
(test "list-queue-append-copy-front" 1 (list-queue-front z))
(test "list-queue-append-copy-back" 5 (list-queue-back z))
(list-queue-remove-front! y)
(test "list-queue-remove-front!" '(5) (list-queue-list y))
(list-queue-remove-back! y)
(test "list-queue-empty?" #t (list-queue-empty? y))
(test "list-queue don't remove-front from empty"
      'error-occurred
      (with-handler (lambda (e)
                      'error-occurred)
                    (list-queue-remove-front! y)))
(test "list-queue don't remove-back from empty"
      'error-occurred
      (with-handler (lambda (e)
                      'error-occurred)
                    (list-queue-remove-back! y)))
(test "list-queue-list II" '(1 2 3 4 5) (list-queue-list z))
(test "list-queue-remove-all!" '(1 2 3 4 5) (list-queue-remove-all! z2))
(test "list-queue-remove-all! -> empty" #t (list-queue-empty? z2))
(list-queue-remove-all! z)
(list-queue-add-front! z 1)
(list-queue-add-front! z 0)
(list-queue-add-back! z 2)
(list-queue-add-back! z 3)
(test "list-queue-remove-all-add-4" '(0 1 2 3) (list-queue-list z))

;; list-queues/whole
(define a (list-queue 1 2 3))
(define b (list-queue-copy a))
(test "list-queue-copy" '(1 2 3) (list-queue-list b))
(list-queue-add-front! b 0)
(test "list-queue-copy is not shared" '(1 2 3) (list-queue-list a))
(test "list-queue-copy size" 4 (length (list-queue-list b)))
(define c (list-queue-concatenate (list a b)))
(test "list-queue-concatenate" '(1 2 3 0 1 2 3) (list-queue-list c))

;; list-queues/map
(define r (list-queue 1 2 3))
(define s (list-queue-map (lambda (x) (* x 10)) r))
(test "list-queue-map" '(10 20 30) (list-queue-list s))
(list-queue-map! (lambda (x) (+ x 1)) r)
(test "list-queue-map!" '(2 3 4) (list-queue-list r))
(define sum 0)
(list-queue-for-each (lambda (x) (set! sum (+ sum x))) s)
(test "list-queue-for-each" 60 sum)

;; list-queues/conversion
(define n (list-queue 5 6))
(list-queue-set-list! n (list 1 2))
(test "list-queue-set-list!" '(1 2) (list-queue-list n))
(define d (list 1 2 3))
(define e (cddr d))
(define f (make-list-queue d e))
(define dx #f) ; redefined below
(define ex #f) ; redefined below
(let-values (((dxv exv) (list-queue-first-last f)))
  (set! dx dxv)
  (set! ex exv))
(test "list-queue-first-last" #t (eq? d dx))
(test "list-queue-first-last II" #t (eq? e ex))
(test "list-queue-first-last III" '(1 2 3) (list-queue-list f))
(list-queue-add-front! f 0)
(list-queue-add-back! f 4)
(test "list-queue-add-{front,back}!" '(0 1 2 3 4) (list-queue-list f))
(define g (make-list-queue d e))
(test "make-list-queue II" '(1 2 3 4) (list-queue-list g))
(define h (list-queue 5 6))
(list-queue-set-list! h d e)
(test "list-queue-set-list! II" '(1 2 3 4) (list-queue-list h))

;; list-queues/unfold
(define (double x) (* x 2))
(define (done? x) (> x 3))
(define (add1 x) (+ x 1))
(define x (list-queue-unfold done? double add1 0))
(test "list-queue-unfold" '(0 2 4 6) (list-queue-list x))
(define y (list-queue-unfold-right done? double add1 0))
(test "list-queue-unfold-right" '(6 4 2 0) (list-queue-list y))
(define x0 (list-queue 8))
(define x1 (list-queue-unfold done? double add1 0 x0))
(test "list-queue-unfold II" '(0 2 4 6 8) (list-queue-list x1))
(define y0 (list-queue 8))
(define y1 (list-queue-unfold-right done? double add1 0 y0))
(test "list-queue-unfold-right II" '(8 6 4 2 0) (list-queue-list y1))

;; ----------------------------------------------------------------------
;;  SRFI 118 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 118 - Simple adjustable-size strings")

(define-syntax set-mutable-string!
  (syntax-rules ()
    ((_ s v)
     (set! s (string-copy v)))))

(define a6  (string-copy "abcdef"))
(define b6  (string-copy "123456"))
(define b12 (string-copy "qwertyuiopas"))

(define au6  (string-copy "ábcdÊf"))
(define bu6  (string-copy "ȠȘȡǮƶそ"))
(define bu12 (string-copy "行きऔ国ث؇صאװ⇇xy"))

(test "string-append! single" "abcdef" (string-append! a6))
(set-mutable-string! a6 "abcdef")
(test "string-append! single length" 6  (string-length (string-append! a6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! single eq?" #t (eq? a6 (string-append! a6)))

(set-mutable-string! a6  "abcdef")
(define a6-copy (string-copy a6))
(test "string-append! = append" #t (string=? (string-append! a6 b6)
                                             (string-append  a6-copy b6)))
(set-mutable-string! a6 "abcdef")
(test "string-append!" "abcdef123456" (string-append! a6 b6))
(set-mutable-string! a6 "abcdef")
(test "string-append! length" 12 (string-length (string-append! a6 b6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! eq?" #t (eq? a6 (string-append! a6 b6)))

(set-mutable-string! a6 "abcdef")
(test "string-append! char" "abcdef123456" (string-append! a6 #\1 #\2 "345" #\6))
(set-mutable-string! a6 "abcdef")
(test "string-append! char length" 12 (string-length (string-append! a6 #\1 #\2 "345" #\6)))
(set-mutable-string! a6 "abcdef")
(test "string-append! char eq?" #t (eq? a6 (string-append! a6 #\1 #\2 "345" #\6)))



(define au6-copy (string-copy au6))
(test "append! = append, unicode" #t (string=? (string-append! au6 bu6 bu12)
                                               (string-append au6-copy bu6 bu12)))
(set-mutable-string! au6  "ábcdÊf")
(test "append! = append, unicode, length" 24 (string-length (string-append! au6 bu6 bu12)))
(set-mutable-string! au6  "ábcdÊf")
(test "append! = append, unicode, eq?" #t (eq? au6 (string-append! au6 bu6 bu12)))
(set-mutable-string! au6  "ábcdÊf")

(set-mutable-string! a6 "abcdef")
(test "string-append! char, unicode" "abcdefঈ2345༫" (string-append! a6 #\ঈ #\2 "345" #\༫))
(set-mutable-string! a6 "abcdef")
(test "string-append! char, unicode, length" 12 (string-length (string-append! a6 #\ঈ #\2 "345" #\༫)))
(set-mutable-string! a6 "abcdef")
(test "string-append! char, unidoce, eq?" #t (eq? a6 (string-append! a6 #\ঈ #\2 "345" #\༫)))

(set-mutable-string! au6  "ábcdÊf")
(test "string-append! char, unicode" "ábcdÊfঈ2345༫" (string-append! au6 #\ঈ #\2 "345" #\༫))
(set-mutable-string! au6  "ábcdÊf")
(test "string-append! char, unicode, length" 12 (string-length (string-append! au6 #\ঈ #\2 "345" #\༫)))
(set-mutable-string! au6  "ábcdÊf")
(test "string-append! char, unidoce, eq?" #t (eq? au6 (string-append! au6 #\ঈ #\2 "345" #\༫)))


(test/error "string-append! args 1"  (string-append! a6 #t))
(test/error "string-append! args 2"  (string-append! a6 2))
(test/error "string-append! args 3"  (string-append! 3 10))
(test/error "string-append! args 4"  (string-append! 'a 'b))

(test/error "string-replace! args 1" (string-replace! 'a 0 6  b6 0 6))
(test/error "string-replace! args 2" (string-replace! a6 0 6  #t 0 6))
(test/error "string-replace! args 3" (string-replace! a6 -1 6  b6 0 6))
(test/error "string-replace! args 4" (string-replace! a6  0 50 b6 0 6))
(test/error "string-replace! args 5" (string-replace! a6  0  6  b6 -1 6))
(test/error "string-replace! args 6" (string-replace! a6  0  6  b6  0 50))

(test/error "string-replace! args 7" (string-replace! 'a 6 0  b6 0 6))
(test/error "string-replace! args 8" (string-replace! 'a 0 6  b6 6 0))

(set-mutable-string! a6 "abcdef")
(test "string-replace! all" "123456"  (string-replace! a6 0 6 b6 0 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! all length" 6  (string-length (string-replace! a6 0 6 b6 0 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! all eq?" #t  (eq? a6 (string-replace! a6 0 6 b6 0 6)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! part" "ab23ef"  (string-replace! a6 2 4 b6 1 3))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part length" 6  (string-length (string-replace! a6 2 4 b6 1 3)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part eq?" #t  (eq? a6 (string-replace! a6 2 4 b6 1 3)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2" "abpaef"  (string-replace! a6 2 4 b12 9 11))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2 length" 6  (string-length (string-replace! a6 2 4 b12 9 11)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! part 2 eq?" #t  (eq? a6 (string-replace! a6 2 4 b12 9 11)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! delete" "abef" (string-replace! a6 2 4 b6 0 0))
(set-mutable-string! a6 "abcdef")
(test "string-replace! delete length" 4  (string-length (string-replace! a6 2 4 b6 0 0)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! delete eq?" #t  (eq? a6 (string-replace! a6 2 4 b6 0 0)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! insert" "abc123456def" (string-replace! a6 3 3 b6 0 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! insert length" 12  (string-length (string-replace! a6 3 3 b6 0 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! insert eq?" #t  (eq? a6 (string-replace! a6 3 3 b6 0 6)))

(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap" "abefef" (string-replace! a6 2 4 a6 4 6))
(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap length" 6  (string-length (string-replace! a6 2 4 a6 4 6)))
(set-mutable-string! a6 "abcdef")
(test "string-replace! overlap eq?" #t  (eq? a6 (string-replace! a6 2 4 a6 4 6)))

;; ----------------------------------------------------------------------
;;  SRFI 128 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 128 - Comparators")

(require "srfi-128")

(define (vector-cdr vec)
    (let* ((len (vector-length vec))
           (result (make-vector (- len 1))))
      (let loop ((n 1))
        (cond
          ((= n len) result)
          (else (vector-set! result (- n 1) (vector-ref vec n))
                (loop (+ n 1)))))))

(test "vector-cdr"   '#(2 3 4) (vector-cdr '#(1 2 3 4)))
(test "vector-cdr 2" '#() (vector-cdr '#(1)))

(define default-comparator (make-default-comparator))
(define real-comparator (make-comparator real? = < number-hash))
(define degenerate-comparator (make-comparator (lambda (x) #t) equal? #f #f))
(define boolean-comparator
  (make-comparator boolean? eq? (lambda (x y) (and (not x) y)) boolean-hash))
(define bool-pair-comparator (make-pair-comparator boolean-comparator boolean-comparator))
(define num-list-comparator
  (make-list-comparator real-comparator list? null? car cdr))
(define num-vector-comparator
  (make-vector-comparator real-comparator vector? vector-length vector-ref))
(define vector-qua-list-comparator
  (make-list-comparator
   real-comparator
   vector?
   (lambda (vec) (= 0 (vector-length vec)))
   (lambda (vec) (vector-ref vec 0))
   vector-cdr))
(define list-qua-vector-comparator
  (make-vector-comparator default-comparator list? length list-ref))
(define eq-comparator (make-eq-comparator))
(define eqv-comparator (make-eqv-comparator))
(define equal-comparator (make-equal-comparator))
(define symbol-comparator
  (make-comparator
   symbol?
   eq?
   (lambda (a b) (string<? (symbol->string a) (symbol->string b)))
   symbol-hash))

;; comparators/predicates
(test "comparator? 1" #t (comparator? real-comparator))
(test "comparator? 2" #t (not (comparator? =)))
(test "ordered?" #t (comparator-ordered? real-comparator))
(test "hashtable?" #t (comparator-hashable? real-comparator))
(test "ordered? 2" #t (not (comparator-ordered? degenerate-comparator)))
(test "hashtable? 2" #t (not (comparator-hashable? degenerate-comparator)))

;; comparators/constructors

(test "1" #t (=? boolean-comparator #t #t))
(test "2" #t (not (=? boolean-comparator #t #f)))
(test "3" #t (<? boolean-comparator #f #t))
(test "4" #t (not (<? boolean-comparator #t #t)))
(test "5" #t (not (<? boolean-comparator #t #f)))

(test "6" #t (comparator-test-type bool-pair-comparator '(#t . #f)))
(test "7" #t (not (comparator-test-type bool-pair-comparator 32)))
(test "8" #t (not (comparator-test-type bool-pair-comparator '(32 . #f))))
(test "9" #t (not (comparator-test-type bool-pair-comparator '(#t . 32))))
(test "10" #t (not (comparator-test-type bool-pair-comparator '(32 . 34))))
(test "11" #t (=? bool-pair-comparator '(#t . #t) '(#t . #t)))
(test "12" #t (not (=? bool-pair-comparator '(#t . #t) '(#f . #t))))
(test "13" #t (not (=? bool-pair-comparator '(#t . #t) '(#t . #f))))
(test "14" #t (<? bool-pair-comparator '(#f . #t) '(#t . #t)))
(test "15" #t (<? bool-pair-comparator '(#t . #f) '(#t . #t)))
(test "16" #t (not (<? bool-pair-comparator '(#t . #t) '(#t . #t))))
(test "17" #t (not (<? bool-pair-comparator '(#t . #t) '(#f . #t))))
(test "18" #t (not (<? bool-pair-comparator '(#f . #t) '(#f . #f))))

(test "19" #t (comparator-test-type num-vector-comparator '#(1 2 3)))
(test "20" #t (comparator-test-type num-vector-comparator '#()))
(test "21" #t (not (comparator-test-type num-vector-comparator 1)))
(test "22" #t (not (comparator-test-type num-vector-comparator '#(a 2 3))))
(test "23" #t (not (comparator-test-type num-vector-comparator '#(1 b 3))))
(test "24" #t (not (comparator-test-type num-vector-comparator '#(1 2 c))))
(test "25" #t (=? num-vector-comparator '#(1 2 3) '#(1 2 3)))
(test "26" #t (not (=? num-vector-comparator '#(1 2 3) '#(4 5 6))))
(test "27" #t (not (=? num-vector-comparator '#(1 2 3) '#(1 5 6))))
(test "28" #t (not (=? num-vector-comparator '#(1 2 3) '#(1 2 6))))
(test "29" #t (<? num-vector-comparator '#(1 2) '#(1 2 3)))
(test "30" #t (<? num-vector-comparator '#(1 2 3) '#(2 3 4)))
(test "31" #t (<? num-vector-comparator '#(1 2 3) '#(1 3 4)))
(test "32" #t (<? num-vector-comparator '#(1 2 3) '#(1 2 4)))
(test "33" #t (<? num-vector-comparator '#(3 4) '#(1 2 3)))
(test "34" #t (not (<? num-vector-comparator '#(1 2 3) '#(1 2 3))))
(test "35" #t (not (<? num-vector-comparator '#(1 2 3) '#(1 2))))
(test "36" #t (not (<? num-vector-comparator '#(1 2 3) '#(0 2 3))))
(test "37" #t (not (<? num-vector-comparator '#(1 2 3) '#(1 1 3))))

(test "38" #t (not (<? vector-qua-list-comparator '#(3 4) '#(1 2 3))))
(test "39" #t (<? list-qua-vector-comparator '(3 4) '(1 2 3)))

(define bool-pair (cons #t #f))
(define bool-pair-2 (cons #t #f))
(define reverse-bool-pair (cons #f #t))

(test "40" #t (=? eq-comparator #t #t))
(test "41" #t (not (=? eq-comparator #f #t)))
(test "42" #t (=? eqv-comparator bool-pair bool-pair))
(test "43" #t (not (=? eqv-comparator bool-pair bool-pair-2)))
(test "44" #t (=? equal-comparator bool-pair bool-pair-2))
(test "45" #t (not (=? equal-comparator bool-pair reverse-bool-pair)))

;; comparators/hash
(test "46" #t (exact-integer? (boolean-hash #f)))
(test "47" #t (not (negative? (boolean-hash #t))))
(test "48" #t (exact-integer? (char-hash #\a)))
(test "49" #t (not (negative? (char-hash #\b))))
(test "50" #t (exact-integer? (char-ci-hash #\a)))
(test "51" #t (not (negative? (char-ci-hash #\b))))
(test "52" #t (= (char-ci-hash #\a) (char-ci-hash #\A)))
(test "53" #t (exact-integer? (string-hash "f")))
(test "54" #t (not (negative? (string-hash "g"))))
(test "55" #t (exact-integer? (string-ci-hash "f")))
(test "56" #t (not (negative? (string-ci-hash "g"))))
(test "57" #t (= (string-ci-hash "f") (string-ci-hash "F")))
(test "58" #t (exact-integer? (symbol-hash 'f)))
(test "59" #t (not (negative? (symbol-hash 't))))
(test "60" #t (exact-integer? (number-hash 3)))
(test "61" #t (not (negative? (number-hash 3))))
(test "62" #t (exact-integer? (number-hash -3)))
(test "63" #t (not (negative? (number-hash -3))))
(test "64" #t (exact-integer? (number-hash 3.0)))
(test "65" #t (not (negative? (number-hash 3.0))))

;; comparators/default
(test "66" #t (<? default-comparator '() '(a)))
(test "67" #t (not (=? default-comparator '() '(a))))
(test "68" #t (=? default-comparator #t #t))
(test "69" #t (not (=? default-comparator #t #f)))
(test "70" #t (<? default-comparator #f #t))
(test "71" #t (not (<? default-comparator #t #t)))
(test "72" #t (=? default-comparator #\a #\a))
(test "73" #t (<? default-comparator #\a #\b))

(test "74" #t (comparator-test-type default-comparator '()))
(test "75" #t (comparator-test-type default-comparator #t))
(test "76" #t (comparator-test-type default-comparator #\t))
(test "77" #t (comparator-test-type default-comparator '(a)))
(test "78" #t (comparator-test-type default-comparator 'a))
(test "79" #t (comparator-test-type default-comparator (make-bytevector 10)))
(test "80" #t (comparator-test-type default-comparator 10))
(test "81" #t (comparator-test-type default-comparator 10.0))
(test "82" #t (comparator-test-type default-comparator "10.0"))
(test "83" #t (comparator-test-type default-comparator '#(10)))

(test "84" #t (=? default-comparator '(#t . #t) '(#t . #t)))
(test "85" #t (not (=? default-comparator '(#t . #t) '(#f . #t))))
(test "86" #t (not (=? default-comparator '(#t . #t) '(#t . #f))))
(test "87" #t (<? default-comparator '(#f . #t) '(#t . #t)))
(test "88" #t (<? default-comparator '(#t . #f) '(#t . #t)))
(test "89" #t (not (<? default-comparator '(#t . #t) '(#t . #t))))
(test "90" #t (not (<? default-comparator '(#t . #t) '(#f . #t))))
(test "91" #t (not (<? default-comparator '#(#f #t) '#(#f #f))))

(test "92" #t (=? default-comparator '#(#t #t) '#(#t #t)))
(test "93" #t (not (=? default-comparator '#(#t #t) '#(#f #t))))
(test "94" #t (not (=? default-comparator '#(#t #t) '#(#t #f))))
(test "95" #t (<? default-comparator '#(#f #t) '#(#t #t)))
(test "96" #t (<? default-comparator '#(#t #f) '#(#t #t)))
(test "97" #t (not (<? default-comparator '#(#t #t) '#(#t #t))))
(test "98" #t (not (<? default-comparator '#(#t #t) '#(#f #t))))
(test "99" #t (not (<? default-comparator '#(#f #t) '#(#f #f))))

(test "100" #t (= (comparator-hash default-comparator #t) (boolean-hash #t)))
(test "101" #t (= (comparator-hash default-comparator #\t) (char-hash #\t)))
(test "102" #t
      (begin
        (let ((a (comparator-hash default-comparator "t"))
              (b (string-hash "t")))
          (= a b))))
(test "103" #t (= (comparator-hash default-comparator 't) (symbol-hash 't)))
(test "104" #t (= (comparator-hash default-comparator 10) (number-hash 10)))
(test "105" #t (= (comparator-hash default-comparator 10.0) (number-hash 10.0)))

(comparator-register-default!
 (make-comparator procedure? (lambda (a b) #t) (lambda (a b) #f) (lambda (obj) 200)))
(test "106" #t (=? default-comparator (lambda () #t) (lambda () #f)))
(test "107" #t (not (<? default-comparator (lambda () #t) (lambda () #f))))
(test "108" 200 (comparator-hash default-comparator (lambda () #t)))



;; SRFI 128 does not actually require a comparator's four procedures
;; to be eq? to the procedures originally passed to make-comparator.
;; For interoperability/interchangeability between the comparators
;; of SRFI 114 and SRFI 128, some of the procedures passed to
;; make-comparator may need to be wrapped inside another lambda
;; expression before they're returned by the corresponding accessor.
;;
;; So this next group of tests is incorrect, hence commented out
;; and replaced by a slightly less naive group of tests.

;; comparators/accessors"
;; (define ttp (lambda (x) #t))
;; (define eqp (lambda (x y) #t))
;; (define orp (lambda (x y) #t))
;; (define hf (lambda (x) 0))
;; (define comp (make-comparator ttp eqp orp hf))
;; (test "" ttp (comparator-type-test-predicate comp))
;; (test "" eqp (comparator-equality-predicate comp))
;; (test "" orp (comparator-ordering-predicate comp))
;; (test "" hf (comparator-hash-function comp))

;; comparators/accessors
(define x1 0)
(define x2 0)
(define x3 0)
(define x4 0)
(define ttp (lambda (x) (set! x1 111) #t))
(define eqp (lambda (x y) (set! x2 222) #t))
(define orp (lambda (x y) (set! x3 333) #t))
(define hf (lambda (x) (set! x4 444) 0))
(define comp (make-comparator ttp eqp orp hf))
(test "109" #t (and ((comparator-type-test-predicate comp) x1)   (= x1 111)))
(test "110" #t (and ((comparator-equality-predicate comp) x1 x2) (= x2 222)))
(test "111" #t (and ((comparator-ordering-predicate comp) x1 x3) (= x3 333)))
(test "112" #t (and (zero? ((comparator-hash-function comp) x1)) (= x4 444)))

;; comparators/invokers
(test "113" #t (comparator-test-type real-comparator 3))
(test "114" #t (comparator-test-type real-comparator 3.0))
(test "115" #t (not (comparator-test-type real-comparator "3.0")))
(test "116" #t (comparator-check-type boolean-comparator #t))
(test "117" *test-failed* (comparator-check-type boolean-comparator 't))

;; comparators/comparison
(test "118" #t (=? real-comparator 2 2.0 2))
(test "119" #t (<? real-comparator 2 3.0 4))
(test "120" #t (>? real-comparator 4.0 3.0 2))
(test "121" #t (<=? real-comparator 2.0 2 3.0))
(test "122" #t (>=? real-comparator 3 3.0 2))
(test "123" #t (not (=? real-comparator 1 2 3)))
(test "124" #t (not (<? real-comparator 3 1 2)))
(test "125" #t (not (>? real-comparator 1 2 3)))
(test "126" #t (not (<=? real-comparator 4 3 3)))
(test "127" #t (not (>=? real-comparator 3 4 4.0)))


;; comparators/syntax
(test "128" 'less (comparator-if<=> real-comparator 1 2 'less 'equal 'greater))
(test "129" 'equal (comparator-if<=> real-comparator 1 1 'less 'equal 'greater))
(test "130" 'greater (comparator-if<=> real-comparator 2 1 'less 'equal 'greater))
(test "131" 'less (comparator-if<=> "1" "2" 'less 'equal 'greater))
(test "132" 'equal (comparator-if<=> "1" "1" 'less 'equal 'greater))
(test "133" 'greater (comparator-if<=> "2" "1" 'less 'equal 'greater))

;; comparators/bound-salt"
(test "hash bound" #t (exact-integer? (hash-bound)))
(test "hash salt" #t (exact-integer? (hash-salt)))
(test "hash salt<hash bound" #t (< (hash-salt) (hash-bound)))

;; ----------------------------------------------------------------------
;;  SRFI 129 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 129 - Titlecase procedures")

(require "srfi-129")

(test "" #t (char-title-case? #\x01C5))
(test "" #t (char-title-case? #\x1FFC))
(test "" #f (char-title-case? #\Z))
(test "" #f (char-title-case? #\z))

(test "char 1" #\x01C5 (char-titlecase #\x01C4))
(test "char 2" #\x01C5 (char-titlecase #\x01C6))
(test "char 3" #\Z (char-titlecase #\Z))
(test "char 4" #\Z (char-titlecase #\z))

(test "string 1" "\x01C5;" (string-titlecase "\x01C5;"))
(test "string 2" "\x01C5;" (string-titlecase "\x01C4;"))    ;
(test "string 3" "Ss" (string-titlecase "\x00DF;"))         ;
(test "string 4" "Xi\x0307;" (string-titlecase "x\x0130;")) ;
(test "string 5" "\x1F88;" (string-titlecase "\x1F80;"))
(test "string 6" "\x1F88;" (string-titlecase "\x1F88;"))


(define Floo "\xFB02;oo")
(define Floo-bar "\xFB02;oo bar")
(define Baffle "Ba\xFB04;e")
(define LJUBLJANA "\x01C7;ub\x01C7;ana")
(define Ljubljana "\x01C8;ub\x01C9;ana")
(define ljubljana "\x01C9;ub\x01C9;ana")

(test "string 7" "Bar Baz" (string-titlecase "bAr baZ"))
(test "string 8" "Floo" (string-titlecase "floo"))
(test "string 9" "Floo" (string-titlecase "FLOO"))
(test "string 10" "Floo" (string-titlecase Floo))          ;
(test "string 11" "Floo Bar" (string-titlecase "floo bar"))
(test "string 12" "Floo Bar" (string-titlecase "FLOO BAR"))
(test "string 13" "Floo Bar" (string-titlecase Floo-bar))  ;
(test "string 14" Baffle (string-titlecase Baffle))
(test "string 15" Ljubljana (string-titlecase LJUBLJANA))  ;
(test "string 16" Ljubljana (string-titlecase Ljubljana))
(test "string 17" Ljubljana (string-titlecase ljubljana))  ;

(define str1 "abc")
(define str2 "def")
(test/error "string-append! constant 1" (string-append! "a" "b"))
(test/error "string-append! constant 2" (string-append! "ábç, unicode!" "bçdéﬀ"))
(test/error "string-append! constant 3" (string-append! str1 "x"))
(test "string-append! constant 3" "abcdef" (string-append! (string-copy str1) str2)) ;  second arg may be constant
(test "string-append! constant 3" "xdef" (string-append! (string-copy "x") str2)) ;  second arg may be constant


;; ----------------------------------------------------------------------
;;  SRFI 141 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 141 - Integer division")

(require "srfi-141")

;; SRFI 141 comes with no tests, so I have ceated a few.

(define nums-dens '( (25 3)
                     (-25 3)
                     (17 3)
                     (-17 3)
                     (29 5)
                     (-29 5)
                     (30 3)
                     (-30 3)
                     (101 80)
                     (-101 80)
                     (101 -80)
                     (100 60)
                     (-100 60) ))

(for-each (lambda (num-den)
            (let ((n (car num-den))
                  (d (cadr num-den)))
              (let ((flq (floor-quotient n d))
                    (flr (floor-remainder n d))
                    (clq (ceiling-quotient n d))
                    (clr (ceiling-remainder n d))
                    (tcq (truncate-quotient n d))
                    (tcr (truncate-remainder n d))
                    (rdq (round-quotient n d))
                    (rdr (round-remainder n d))
                    (euq (euclidean-quotient n d))
                    (eur (euclidean-remainder n d))
                    (blq (balanced-quotient n d))
                    (blr (balanced-remainder n d)))

                (test (format "flq:~d:~d" n d)
                      (floor (/ n d))
                      flq)
                (test (format "flr:~d:~d" n d)
                     (- n (* flq d))
                     flr)

                (test (format "clq:~d:~d" n d)
                      (ceiling (/ n d))
                      clq)
                (test (format "clr:~d:~d" n d)
                      (- n (* clq d))
                      clr)

                (test (format "trlq:~d:~d" n d)
                      (truncate (/ n d))
                      tcq)
                (test (format "trr:~d:~d" n d)
                      (- n (* tcq d))
                      tcr)

                (test (format "rdq:~d:~d" n d)
                      (round (/ n d))
                      rdq)
                (test (format "rdr:~d:~d" n d)
                      (- n (* rdq d))
                      rdr)

                (test (format "euq:~d:~d" n d)
                      (if (positive? d)
                          (floor (/ n d))
                          (ceiling (/ n d)))
                      euq)
                (test (format "eur3:~d:~d" n d)
                      #t
                      (< eur (abs d)))
                (test (format "eur2:~d:~d" n d)
                      #t
                      (>= eur 0))
                (test (format "eur:~d:~d" n d)
                      (- n (* euq d))
                      eur)

                (test (format "blr1:~d:~d" n d)
                      #t
                      (< blr (abs (/ d 2))))
                (test (format "blr2:~d:~d" n d)
                      #t
                      (>= blr (- (abs (/ d 2)))))
                (test (format "blr:~d:~d" n d)
                      (- n (* blq d))
                      blr))))
          nums-dens)

;; ----------------------------------------------------------------------
;;  SRFI 156 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 156 - Syntactic combiners for binary predicates")

(require "srfi-156")


;; the tests were translated from the original SRFI reference implementation

(test "" #t
 (is 1 odd?))

(test "" #t
 (isnt 2 odd?))

(test "" #t
 (is '() null?))

(test "" #t
 (is procedure? procedure?))

(test "" #t
 (isnt 5 procedure?))

;; two arguments:

(test "" #t
 (is 1 < 2))

(test "" #t
 (isnt 1 < 1))

(test "" #t
 (is (+ 2 2) = 4))

(test "" #t
 (is 'x eq? 'x))

(test "" #t
 (is procedure? eq? procedure?))

(test "" #t
 (eq? (is eq? eq? eq?)
      (eq? eq? eq?)))

(test "" #t
 (is (is eq? eq? eq?) eq? (eq? eq? eq?)))

(test "" '(y z)
 (is 'y memq '(x y z)))

(test "" '((1) (2) (1 2))
 (is '(1) member '(() (1) (2) (1 2))))

(test "" #t
 (isnt 'x eq? 'y))

(test "" #t
 (is '(a b c) equal? '(a b c)))

(test "" #t
 (isnt '(a b c) equal? '(c b a)))

(test "" #t
 (is 0 = 0.0))

(test "" #t
 (is 1.0 = 1))

(test "" #t
 (isnt 1 = 0))

(define (divisible-by? x y)
  (is (modulo x y) = 0))

(test "" #t
 (is 9 divisible-by? 3))

(test "" #t
 (isnt 3 divisible-by? 9))

;; ending with unary predicate:

(test "" #t
 (is 1 < 2 even?))

(test "" #t
 (isnt 1 < 2 odd?))

(test "" #t
 (isnt 2 < 1 even?))

(test "" #t
 (is 0 = 0.0 zero?))

(test "" #t
 (isnt 1.0 = 1 zero?))

;; three arguments:

(test "" #t
 (is 1 < 2 <= 3))

(test "" #t
 (is 0 = 0.0 = 0+0i = 0.0+0.0i))

(test "" #t
 (isnt 1 <= 2 < 2))

;; predicates don't need to be transitive
;; (although that's not particularly elegant):

(test "" #t
 (is 1 < 2 > 1.5))

(test "" #t
 (isnt 1 < 2 > 3))

(test "" #t
 (isnt 3 < 2 < 1))

(test "" '((x y) (y x))
 (is 'x member '(x y) member '((x y) (y x))))

;; more arguments:

(test "" #t
 (is -0.4 < -0.1 <= 0 = 0.0 < 0.1 < 0.4))

(test "" #t
 (isnt -0.4 < -0.1 <= 0 = 0.0 < 0.1 < -0.1))

(test "" #t
 (is 0 = 0.0 = 0+0i = 0.0+0.0i = (+) < (*) = 1 = 1.0 = 1+0i = 1.0+0.0i))

;; ending with unary predicate:

(test "" #t
 (is -0.4 < -0.1 <= 0 <= 0.0 < 0.1 < 0.4 <= 2 even?))

(test "" #t
 (isnt -0.4 < -0.1 <= 0 <= 0.0 < 0.1 < 0.4 <= 2 odd?))

;; as procedures (with underscore):

(test "" #t
 (equal? (filter (isnt _ even?) '(2 4 5 6 7 8))
     '(5 7)))

(test "" #t
 (equal? (filter (is _ < 2) '(1 3 2 0))
     '(1 0)))

(test "" #t
 (equal? (filter (is 1 < _) '(1 3 2 0))
     '(3 2)))

(test "" #t
 (equal? (filter (is 3 < _ <= 5) '(2 3 4 5 6 7))
     '(4 5)))

(test "" #t
 (equal? (filter (is 'x memq _) '((a b) (x) (p q) (x y) (c d) (z x)))
     '((x) (x y) (z x))))

(test "" #t
 (equal? (filter (isnt 'x memq _) '((a b) (x) (p q) (x y) (c d) (z x)))
     '((a b) (p q) (c d))))

(test "" #t
 (equal? (filter (isnt 3 < _ <= 5) '(2 3 4 5 6 7))
     '(2 3 6 7)))

(test "" #t
 (equal? (filter (is _ eq? 'a) '(m a m a))
     '(a a)))

(test "" #t
 (equal? (filter (isnt 'a eq? _) '(m a m a))
     '(m m)))

;; multiple underscores:

(test "" #t
 ((is _ < 2 < _) 1 3))

(test "" #t
 ((isnt 1 < _ <= _ < 3) 2 4))

(test "" #t
 ((is _ < _ even?) 1 2))

(test "" #t
 ((isnt _ < _ odd?) 1 2))

(test "" #t
 ((is 1 < _ <= 3 < _ <= 5 < _) 3 5 6))

(test "" #t
 ((isnt 1 < _ <= 3 < _ <= 5 < _) 3 3 6))

(test "" #t
 ((is 1 < _ <= 3 < _ <= 5 < _ even?) 3 5 6))

(test "" #t
 ((isnt 1 < _ <= 3 < _ <= 5 < _ odd?) 3 5 6))

;; ----------------------------------------------------------------------
;;  SRFI 158 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 158 - generators")

(require "srfi-158")


(test "iota-simple" (generator->list (make-iota-generator 3 8)) '(8 9 10))
(test "iota-step" (generator->list (make-iota-generator 3 8 2)) '(8 10 12))
(test "range-simple" (generator->list (make-range-generator 3) 4) '(3 4 5 6))
(test "range-upper-limit" (generator->list (make-range-generator 3 8)) '(3 4 5 6 7))
(test "range-upper-limit-step" (generator->list (make-range-generator 3 8 2)) '(3 5 7))

(define g
  (make-coroutine-generator
   (lambda (yield) (let loop ((i 0))
                (when (< i 3) (yield i) (loop (+ i 1)))))))
(test "coroutine-generator" (generator->list g) '(0 1 2))

(test "list->generator" (generator->list (list->generator '(1 2 3 4 5))) '(1 2 3 4 5))
(test "vector->generator" (generator->list (vector->generator '#(1 2 3 4 5))) '(1 2 3 4 5))
(test "reverse-vector->generator" (generator->list (reverse-vector->generator '#(1 2 3 4 5))) '(5 4 3 2 1))
(test "string->generator" (generator->list (string->generator "abcde")) '(#\a #\b #\c #\d #\e))
(test "vector->generator-start" (generator->list (vector->generator '#(a b c d e) 2)) '(c d e))
(test "vector->generator-start-end" (generator->list (vector->generator '#(a b c d e) 2 4)) '(c d))
(test "reverse-vector->generator-start" (generator->list (reverse-vector->generator '#(a b c d e) 2)) '(e d c))
(test "reverse-vector->generator-start-end" (generator->list (reverse-vector->generator '#(a b c d e) 2 4)) '(d c))
(test "reverse-vector->generator-start-end-2" (generator->list (reverse-vector->generator '#(a b c d e) 0 2)) '(b a))

(test "make-unfold-generator" (generator->list (make-unfold-generator
                                                (lambda (s) (> s 5))
                                                (lambda (s) (* s 2))
                                                (lambda (s) (+ s 1))
                                                0))
      '(0 2 4 6 8 10))

(test "gcons*" (generator->list (gcons* 'a 'b (make-range-generator 0 2))) '(a b 0 1))
(test "gappend" (generator->list (gappend (make-range-generator 0 3) (make-range-generator 0 2))) '(0 1 2 0 1))
(test "gappend-2" (generator->list (gappend)) '())
(test "gmap"    (generator->list (gmap - (make-range-generator 0 3))) '(0 -1 -2))
(test "gmap-2"  (generator->list (gmap cons (generator 1 2 3) (generator 4 5))) '((1 . 4) (2 . 5)))
(test "gdelete" (generator->list (gdelete 3 (generator 1 2 3 4 5 3 6 7))) '(1 2 4 5 6 7))
(test "gdelete-neighbor-dups" (generator->list (gdelete-neighbor-dups (list->generator '(a a b c a a a d c)))) '(a b c a d c))
(test "gindex" (generator->list (gindex (list->generator '(a b c d e f))
                                        (list->generator '(0 2 4))))
      '(a c e))
(test "gselect" (generator->list (gselect (list->generator '(a b c d e f))
                                          (list->generator '(#t #f #f #t #t #f))))
      '(a d e))


;; ----------------------------------------------------------------------
;;  SRFI 161 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 161 - Unifiable Boxes")

(require "srfi-161")

(define a (ubox 'a))
(define b (ubox 'b))
(define c (ubox 'c))
(define d (ubox 'd))
(define e (ubox 'e))
(define f (ubox 'f))


(test "ubox?" #t (ubox? (ubox 'g)))

(test "ubox?, 2" #f (ubox? (vector 'h)))

(test "ubox=?" #f (ubox=? a b))

(test "ubox-ref"
      #t
      (eq? 'a (ubox-ref a)))

(ubox-link! a b)
(ubox-union! a c)
(ubox-unify! cons d e)
(ubox-link! b f)

(test "ubox=?" #t (ubox=? a b))
(test "ubox=?" #t (ubox=? b c))
(test "ubox=?" #t (ubox=? c f))
(test "ubox=?" #t (ubox=? a f))
(test "ubox=?" #t (ubox=? d e))
(test "ubox=?" #f (ubox=? a e))

(test "ubox-ref, eq?" #t (eq? (ubox-ref a) 'f))
(test "ubox-ref, equal?" #t (equal? (ubox-ref d) '(d . e)))

(ubox-set! b 'i)

(test "ubox-set!" #t (eq? (ubox-ref a) 'i))

(ubox-link! a e)

(test "ubox-link!" #t (ubox=? c e))


;; ----------------------------------------------------------------------
;;  SRFI 169 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 169 - Underscores in numbers")

;; bin
(test "binary" 201 (read-from-string "#b11001001"))
(test "binary" 201 (read-from-string "#b1_1_0_0_1_0_0_1"))
(test "binary" 201 (read-from-string "#b1_1001001"))
(test "binary" 201 (read-from-string "#b110_01001"))
(test "binary" 201 (read-from-string "#b1100100_1"))

(test/error "binary, leading _"  (read-from-string "#b_11001001"))
(test/error "binary, trailing _" (read-from-string "#b11001001_"))
(test/error "binary, #_b"        (read-from-string "#_b11001001"))
(test/error "binary, double _"   (read-from-string "#b1100__1001"))

;; if it begins with _, it's a symbol!
(test "binary, _#b"  #t (symbol? (read-from-string "_#b11001001")))

;; hex
(test "hex" 4194308277 (read-from-string "#xfa0010b5"))
(test "hex, several _" 4194308277 (read-from-string "#xf_a_0_0_1_0_b_5"))
(test "hex, left _" 4194308277 (read-from-string "#xf_a0010b5"))
(test "hex, right _" 4194308277 (read-from-string "#xfa0010b_5"))
(test "hex, middle _" 4194308277 (read-from-string "#xfa0_010b5"))

(test/error "hex, leading _"  (read-from-string "#x_fa0010b5"))
(test/error "hex, trailing _" (read-from-string "#xfa0010b5_"))
(test/error "hex, #_x"        (read-from-string "#_xfa0010b5"))
(test/error "hex, double _"   (read-from-string "#xfa0__010b5"))

;; if it begins with _, it's a symbol!
(test "hex, _#x" #t (symbol? (read-from-string "_#xfa0010b5")))

;; from the SRFI
;; integers
(test "int" 123 (read-from-string "0123"))
(test "int, three underscores" 123 (read-from-string "0_1_2_3"))
(test "int, one underscore I" 123 (read-from-string "0_123"))
(test "int, one underscore II" 123 (read-from-string "01_23"))
(test "int, one underscore III" 123 (read-from-string "012_3"))
(test "int, signed+, no underscore" 123 (read-from-string "+0123"))
(test "int, signed+, one underscore" 123 (read-from-string "+0_123"))
(test "int, signed-, no underscore" -123 (read-from-string "-0123"))
(test "int, signed-, one underscore" -123 (read-from-string "-0_123"))


(test "int, leading _" #f (number? (read-from-string "_0123")))
(test "int, trailing _" #f (number? (read-from-string "0123_")))
(test "int, trailing double _" #f (number? (read-from-string "0123__")))
(test "int, double _" #f (number? (read-from-string "01__23")))
(test "int, several _" #f (number? (read-from-string "0_1__2___3")))
(test "int, _ after sign+" #f (number? (read-from-string "+_0123")))
(test "int, signed+, trailing _" #f (number? (read-from-string "+0123_")))
(test "int, after sign-" #f (number? (read-from-string "-_0123")))
(test "int, signed-, trailing _" #f (number? (read-from-string "-0123_")))

;; reals
(test "real" 123.456 (read-from-string "123.456"))
(test "real, 4 underscores" 123.456 (read-from-string "0_1_23.4_5_6"))
(test "real, exp-notation" 123.5e6 (read-from-string "1_2_3.5e6"))
(test "real, exp-notation" 12e12 (read-from-string "1_2e1_2"))

(test "real, leading _" #f (number? (read-from-string "_0123.456")))
(test "real, _." #f (number? (read-from-string "0123_.456")))
(test "real, ._" #f (number? (read-from-string "0123._456")))
(test "real, trailing _" #f (number? (read-from-string "0123.456_")))
(test "real, _., exp-notation" #f (number? (read-from-string "123_.5e6" )))
(test "real, ._, exp-notation" #f (number? (read-from-string "123._5e6" )))
(test "real, _e" #f (number? (read-from-string "123.5_e6" )))
(test "real, e_" #f (number? (read-from-string "123.5e_6" )))
(test "real, trailing _, exp-notation" #f (number? (read-from-string "123.5e6_" )))
(test "real, _e, no dot" #f (number? (read-from-string "12_e12"   )))
(test "real e_, no dot" #f (number? (read-from-string "12e_12"   )))
(test "real, trailing _, no dot" #f (number? (read-from-string "12e12_"   )))

(test "octal, two _"  80247 (read-from-string "#o23_45_67"))
(test "int, #d, two _" 456789 (read-from-string "#d45_67_89"))
(test "hex, negative" -32 (read-from-string "#x-2_0"))
(test "octal, signed, two _" 10030 (read-from-string "#o+2_345_6"))

(test/error "hex, #x-_"  (read-from-string "#x-_2"))
(test "_#x-_"  #t (symbol? (read-from-string "_#x-_2")))
(test/error "#d_"   (read-from-string "#d_45_67_89"))
(test/error "#e_"  (read-from-string "#e_45/67_89"))
(test/error "#i#o_"  (read-from-string "#i#o_1234"))
(test/error "#i_#o_" (read-from-string "#i_#o_1234"))
(test/error "trailing _" (read-from-string "#e#x1234_"))

;; ---------------------------------------------------------------------
;;  SRFI 171 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 171 - Transducers")

(require "srfi-1")
(require "srfi-66")
(require "srfi-69")
(require "srfi-171")

(define (add1 x) (+ x 1))

(define numeric-list (iota 5))
(define numeric-vec (list->vector numeric-list))
(define bv (list->u8vector numeric-list))
(define test-string "0123456789abcdef")
(define list-of-chars (string->list test-string))

;; for testing all treplace variations
(define replace-alist '((1 . s) (2 . c) (3 . h) (4 . e) (5 . m)))
(define stklos-hashtable (%old-alist->hash-table replace-alist eq? md5sum))
(define srfi69-hashtable (alist->hash-table replace-alist))
;;(define rnrs-hashtable (rnrs:make-eq-hashtable))

;; No rnrs hashtables
;; (rnrs:hashtable-set! rnrs-hashtable 1 's)
;; (rnrs:hashtable-set! rnrs-hashtable 2 'c)
;; (rnrs:hashtable-set! rnrs-hashtable 3 'h)
;; (rnrs:hashtable-set! rnrs-hashtable 4 'e)
;; (rnrs:hashtable-set! rnrs-hashtable 5 'm)

(define (replace-function val)
  (case val
    ((1) 's)
    ((2) 'c)
    ((3) 'h)
    ((4) 'e)
    ((5) 'm)
    (else val)))

;; Test procedures for port-transduce
;; broken out to properly close port
(define (port-transduce-test)
  (let* ((port (open-input-string "0 1 2 3 4"))
        (res (equal? 15 (port-transduce (tmap add1) + read
                                        (open-input-string "0 1 2 3 4")))))
    (close-port port)
    res))
(define (port-transduce-with-identity-test)
  (let* ((port (open-input-string "0 1 2 3 4"))
         (res (equal? 15 (port-transduce (tmap add1)
                                         +
                                         0
                                         read
                                         (open-input-string "0 1 2 3 4")))))
    (close-port port)
    res))


;;; helpers:


  (define (compose . functions)
    (define (make-chain thunk chain)
      (lambda args
        (call-with-values (lambda () (apply thunk args)) chain)))
    (if (null? functions)
        values
        (fold make-chain (car functions) (cdr functions))))


;; "transducers"


(test "tmap"
      '(1 2 3 4 5)
      (list-transduce (tmap add1)
                      rcons
                      numeric-list))

(test "tfilter"
      '(0 2 4)
      (list-transduce (tfilter even?)
                      rcons
                      numeric-list))

(test "tfilter+tmap"
      '(1 3 5)
      (list-transduce (compose (tfilter even?) (tmap add1))
                      rcons
                      numeric-list))

(test "tfilter-map"
      '(1 3 5)
      (list-transduce (tfilter-map
                       (lambda (x)
                         (if (even? x)
                             (+ x 1)
                             #f)))
                      rcons numeric-list))

(test "tremove"
      (list-transduce (tremove char-alphabetic?)
                      rcount
                      list-of-chars)
      (string-transduce (tremove char-alphabetic?)
                        rcount
                        test-string))

(test "treplace with alist"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace replace-alist)
                      rcons
                      '(1 2 3 4 5 4 r o c k s) ))

(test "treplace with replace-function"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace replace-function)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

(test "treplace with STklos hash-table"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace stklos-hashtable)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

(test "treplace with srfi-69 hash-table"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace srfi69-hashtable)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

;; STklos has no RNRS hashtables, so we comment this out.
;;
;; (test "treplace with rnrs hash-table"
;;       '(s c h e m e  r o c k s)
;;       (list-transduce (treplace rnrs-hashtable)
;;                       rcons
;;                       '(1 2 3 4 5 4 r o c k s)))

(test "ttake"
      6 (list-transduce (ttake 4) + numeric-list))

(test "tdrop"
      7 (list-transduce (tdrop 3) + numeric-list))

(test "tdrop-while"
      '(3 4)
      (list-transduce (tdrop-while (lambda (x) (< x 3)))
                      rcons
                      numeric-list))

(test "ttake-while"
      '(0 1 2)
      (list-transduce (ttake-while (lambda (x) (< x 3)))
                      rcons
                      numeric-list))

(test "tconcatenate"
      '(0 1 2 3 4) (list-transduce tconcatenate
                                   rcons
                                   '((0 1) (2 3) (4))))

(test "tappend-map"
      '(1 2 2 4 3 6)
      (list-transduce (tappend-map (lambda (x) (list x (* x 2))))
                      rcons
                      '(1 2 3)))

(test "tdelete-neighbor-duplicates"
      '(1 2 1 2 3)
      (list-transduce (tdelete-neighbor-duplicates)
                      rcons
                      '(1 1 1 2 2 1 2 3 3)))

(test "tdelete-neighbor-duplicates with equality predicate"
      '(a b c "hej" "hej")
      (list-transduce (tdelete-neighbor-duplicates eq?)
                      rcons
                      (list 'a 'a 'b 'c 'c "hej" (string #\h #\e #\j))))

(test "tdelete-duplicates"
      '(1 2 3 4)
      (list-transduce (tdelete-duplicates)
                      rcons
                      '(1 1 2 1 2 3 3 1 2 3 4)))

(test "tdelete-duplicates with predicate"
      '("hej" "hopp")
      (list-transduce (tdelete-duplicates string-ci=?)
                      rcons
                      (list "hej" "HEJ" "hopp" "HOPP" "heJ")))

;; added by jpellegrini:
(test "tdelete-duplicates with string=?"
      '("hej" "HEJ" "hopp" "HOPP")
      (list-transduce (tdelete-duplicates string=?)
                      rcons
                      (list "hej" "HEJ" "hopp" "HOPP" "hej")))

(test "tflatten"
      '(1 2 3 4 5 6 7 8 9)
      (list-transduce tflatten rcons '((1 2) 3 (4 (5 6) 7) 8 (9))))

(test "tpartition"
      '((1 1 1 1) (2 2 2 2) (3 3 3) (4 4 4 4))
      (list-transduce (tpartition even?)
                      rcons
                      '(1 1 1 1 2 2 2 2 3 3 3 4 4 4 4)))

(test "tsegment"
      '((0 1) (2 3) (4))
      (vector-transduce (tsegment 2) rcons numeric-vec))

(test "tadd-between"
      '(0 and 1 and 2 and 3 and 4)
      (list-transduce (tadd-between 'and) rcons numeric-list))

(test "tenumerate"
      '((-1 . 0) (0 . 1) (1 . 2) (2 . 3) (3 . 4))
      (list-transduce (tenumerate (- 1)) rcons numeric-list))


;; "x-transduce"

(test "list-transduce"
      15 (list-transduce (tmap add1) + numeric-list))

(test "list-transduce with identity"
      15 (list-transduce (tmap add1) + 0 numeric-list))

(test "vector-transduce"
      15 (vector-transduce (tmap add1) + numeric-vec))

(test "vector-transduce with identity"
      15
      (vector-transduce (tmap add1) + 0 numeric-vec))

(test "port-transduce" #t (port-transduce-test))
(test "port-transduce with identity" #t (port-transduce-with-identity-test))

;; Converts each numeric char to it's corresponding integer  and sums them.
(test "string-transduce"
      15
      (string-transduce (tmap (lambda (x) (- (char->integer x) 47))) + "01234"))

(test "string-transduce with identity"
      15
      (string-transduce  (tmap (lambda (x) (- (char->integer x) 47)))
                         +
                         0
                         "01234"))

(test "generator-transduce"
      '(1 2 3)
      (with-input-from-string "1 2 3"
        (lambda () (generator-transduce (tmap (lambda (x) x)) rcons read))))

(test "generator-transduce with identity"
      '(1 2 3)
      (with-input-from-string "1 2 3"
        (lambda () (generator-transduce (tmap (lambda (x) x)) rcons '() read))))

(test "bytevector-u8-transduce"
      15 (bytevector-u8-transduce (tmap add1) + bv))

(test "bytevector-u8-transduce with identity"
      15 (bytevector-u8-transduce (tmap add1) + 0 bv))

;; ----------------------------------------------------------------------
;;  SRFI 173 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 173 - Hooks")

(require "srfi-173")

(test "make-hook type" (hook? (make-hook 2)) #t)

(define hook (make-hook 2))
(define hook-sum-var 0)
(define hook-prod-var 1)
(define (hook-prod x y)
  (set! hook-prod-var (* x y)))

(hook-add! hook (lambda (x y) (set! hook-sum-var (+ x y))))
(hook-add! hook hook-prod)

(test "add-hook!+run-hook" '(8 15)
      (begin
        (hook-run hook 3 5)
        (list hook-sum-var hook-prod-var)))

(define list-from-hook (hook->list hook))

(test "hook->list" #t (list? list-from-hook))
(test "hook->list length" 2 (length list-from-hook))
(test "hook->list element types" #f (member #f (map procedure? list-from-hook)))

(hook-delete! hook hook-prod)
(set! list-from-hook (hook->list hook))
(test "hook-delete!" #f (member hook-prod (hook->list hook)))
(test "hook->list length after delete 1 proc" 1 (length list-from-hook))

(hook-reset! hook)
(set! list-from-hook (hook->list hook))
(test "hook-reset!" 0 (length list-from-hook))

;; these three will be changed by the hook:
(define hook-arith-var 0)
(define hook-geom-var 0)
(define hook-harmo-var 0)
;; define the following two as zero. the procs that changed their values
;; were removed, so they should NOT be altered.
(set! hook-sum-var 0)
(set! hook-prod-var 1)

;; three procedures:
(define (arith-mean x y) (set! hook-arith-var (/ (+ x y) 2)))
(define (geom-mean x y)  (set! hook-geom-var  (sqrt (* x y))))
(define (harmo-mean x y) (set! hook-harmo-var (/ 1 (+ x y))))

(list->hook! hook (list arith-mean geom-mean harmo-mean))
(test "list->hook! - length of list" 3 (length (hook->list hook)))
(test "add-hook!+run-hook after list->hook"  (list 4 (sqrt 15) 1/8 0 1)
      (begin
        (hook-run hook 3 5)
        (list hook-arith-var
              hook-geom-var
              hook-harmo-var
              hook-sum-var
              hook-prod-var)))

;;  SRFI 176 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 176 - Version flag")

(test "version-alist is list" #t (list? (version-alist)))
(test "scheme.id stklos" 'stklos (cadr (assoc 'scheme.id (version-alist))))
(test "version" (version) (cadr (assoc 'version (version-alist))))
(test "version" (features) (cdr (assoc 'scheme.features (version-alist))))

;; ----------------------------------------------------------------------
;;  SRFI 174 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 174 - POSIX Timespecs")

(require "srfi-174")

(define ts1 (timespec 1 2))
(define ts2 (timespec 1 2))
(define ts3 (timespec 1 3))
(define ts4 (timespec 2 2))
(define ts-neg1 (timespec -1 2))
(define ts-neg2 (timespec -1 5))
(define ts-neg3 (timespec -2 0))


(test "timespec?" #t (timespec? ts1))
(test "not timespec?" #t (not (timespec? #f)))
(test "seconds" 1 (timespec-seconds ts1))
(test "nanos" 2 (timespec-nanoseconds ts1))
(test "equal" #t (timespec=? ts1 ts2))
(test "less nanos" #t (timespec<? ts1 ts3))
(test "less seconds" #t (timespec<? ts1 ts4))
(test "less -nanos" #t (timespec<? ts-neg2 ts-neg1))
(test "less -seconds" #t (timespec<? ts-neg3 ts-neg2))
(test "positive hash" #t (positive? (timespec-hash ts-neg1)))
(test "to inexact" #i1.1 (timespec->inexact (timespec 1 #e1e8)))
(let ((t (timespec 1 1))
      (u (inexact->timespec #i1.000000001)))
  (test "from inexact" t u))

;; ----------------------------------------------------------------------
;;  SRFI 175 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 175 - ASCII character library")

(require "srfi-175")


(test "ascii 1" #f (ascii-codepoint? -1))
(test "ascii 2" #t (ascii-codepoint? 0))
(test "ascii 3" #t (ascii-codepoint? #x7f))
(test "ascii 4" #f (ascii-codepoint? #x80))

(test "ascii 5" #t (ascii-char? (integer->char 0)))
(test "ascii 6" #t (ascii-char? (integer->char #x7f)))
(test "ascii 7" #f (ascii-char? (integer->char #x80)))

(test "ascii 8" #t (ascii-string? ""))
(test "ascii 9" #t (ascii-string? "a"))
(test "ascii 10" #t (ascii-string? "a b c"))
(test "ascii 11" #f (ascii-string? "å b o"))
(test "ascii 12" #t (ascii-string? (make-string 1 (integer->char #x7f))))
(test "ascii 13" #f (ascii-string? (make-string 1 (integer->char #x80))))

(test "ascii 14" #t (ascii-bytevector? (string->utf8 "")))
(test "ascii 15" #t (ascii-bytevector? (string->utf8 "a")))
(test "ascii 16" #t (ascii-bytevector? (string->utf8 "a b c")))
(test "ascii 17" #f (ascii-bytevector? (string->utf8 "å b o")))
(test "ascii 18" #t (ascii-bytevector?
          (string->utf8 (make-string 1 (integer->char #x7f)))))
(test "ascii 19" #f (ascii-bytevector?
          (string->utf8 (make-string 1 (integer->char #x80)))))

(test "ascii 20" #t (ascii-non-control? #\space))
(test "ascii 21" #f (ascii-non-control? #\tab))
(test "ascii 22" #f (ascii-non-control? #\newline))
(test "ascii 23" #f (ascii-non-control? (integer->char #x0d)))

(test "ascii 24" #t (ascii-space-or-tab? #\space))
(test "ascii 25" #t (ascii-space-or-tab? #\tab))
(test "ascii 26" #f (ascii-space-or-tab? #\newline))
(test "ascii 27" #f (ascii-non-control? (integer->char #x0d)))

(test "ascii 28" #f (ascii-non-control? (integer->char #x00)))
(test "ascii 29" #f (ascii-non-control? (integer->char #x1f)))
(test "ascii 30" #t (ascii-non-control? (integer->char #x20)))
(test "ascii 31" #t (ascii-non-control? (integer->char #x7e)))
(test "ascii 32" #f (ascii-non-control? (integer->char #x7f)))
(test "ascii 33" #f (ascii-non-control? (integer->char #x80)))

(let ((lowers "abcdefghijklmnopqrstuvwxyz")
      (uppers "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
  (let loop ((i 0))
    (when (< i 26)
      (let ((lower (string-ref lowers i))
            (upper (string-ref uppers i)))
        (test "ascii 34" upper (ascii-upcase upper))
        (test "ascii 35" upper (ascii-upcase lower))
        (test "ascii 36" lower (ascii-downcase upper))
        (test "ascii 37" lower (ascii-downcase lower))
        (loop (+ i 1))))))

(let loop ((cc 0))
  (when (< cc #x80)
    (unless (ascii-alphabetic? cc)
      (test "ascii 38" cc (ascii-upcase cc))
      (test "ascii 39" cc (ascii-downcase cc)))
    (loop (+ cc 1))))

(let loop ((cc 0))
  (when (< cc #x80)
    (test "ascii 40" #f (ascii-char? cc))
    (test "ascii 41" #t (ascii-char? (integer->char cc)))
    (cond ((ascii-alphabetic? cc)
           (test "ascii 42" #t (ascii-upper-case? (ascii-upcase cc)))
           (test "ascii 43" #t (ascii-lower-case? (ascii-downcase cc)))
           (test "ascii 44" #f (ascii-lower-case? (ascii-upcase cc)))
           (test "ascii 45" #f (ascii-upper-case? (ascii-downcase cc)))
           (test "ascii 46" #t (ascii-alphanumeric? cc))
           (test "ascii 47" #t (ascii-non-control? cc))
           (test "ascii 48" #f (ascii-other-graphic? cc))
           (test "ascii 49" #f (ascii-control? cc))
           (test "ascii 50" #f (ascii-numeric? cc))
           (test "ascii 51" #f (ascii-whitespace? cc))
           (test "ascii 52" #f (ascii-space-or-tab? cc)))
          ((ascii-control? cc)
           (test "ascii 53" #f (ascii-non-control? cc))
           (test "ascii 54" #f (ascii-other-graphic? cc))
           (test "ascii 55" cc
                 (ascii-graphic->control
                  (ascii-control->graphic cc)))
           (test "ascii 56" (integer->char cc)
                 (ascii-graphic->control
                  (ascii-control->graphic (integer->char cc)))))
          ((member cc '(#\( #\) #\[ #\] #\{ #\} #\< #\>))
           (test "ascii 57" cc (ascii-mirror-bracket (ascii-mirror-bracket cc)))))
    (loop (+ cc 1))))

(let outer ((a 0))
  (when (< a 26)
    (let inner ((b 0))
      (if (= b 26)
          (outer (+ a 1))
          (begin (test "ascii 58" (= a b)  (ascii-ci=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 59" (< a b)  (ascii-ci<?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 60" (<= a b) (ascii-ci<=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 61" (> a b)  (ascii-ci>?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 62" (>= a b) (ascii-ci>=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (inner (+ b 1)))))))

(ascii-ci>? #\A #\_)
(ascii-ci>? #\Z #\_)

(test "ascii 63" #f (ascii-char? -1))
(test "ascii 64" #f (ascii-char? #x80))
(test "ascii 65" #f (ascii-char? (integer->char #x80)))

(test "ascii 66" #f (ascii-control? -1))
(test "ascii 67" #t (ascii-control? #x00))
(test "ascii 68" #t (ascii-control? #x1f))
(test "ascii 69" #f (ascii-control? #x20))
(test "ascii 70" #f (ascii-control? #x7e))
(test "ascii 71" #t (ascii-control? #x7f))
(test "ascii 72" #f (ascii-control? #x80))

(test "ascii 73" 0 (ascii-digit-value #\0 10))
(test "ascii 74" 0 (ascii-digit-value #\0 1))
(test "ascii 75" #f (ascii-digit-value #\0 0))
(test "ascii 76" #f (ascii-digit-value #\0 -1))
(test "ascii 77" 7 (ascii-digit-value #\7 8))
(test "ascii 78" #f (ascii-digit-value #\7 7))
(test "ascii 79" #f (ascii-digit-value #\: 10))

(test "ascii 80" 0 (ascii-upper-case-value #\A 0 26))
(test "ascii 81" 25 (ascii-upper-case-value #\Z 0 26))
(test "ascii 82" #f (ascii-upper-case-value #\Z 0 25))

(test "ascii 83" 0 (ascii-lower-case-value #\a 0 26))
(test "ascii 84" 25 (ascii-lower-case-value #\z 0 26))
(test "ascii 85" #f (ascii-lower-case-value #\z 0 25))

(test "ascii 86" 0 (ascii-lower-case-value #\a 0 1))
(test "ascii 87" #f (ascii-lower-case-value #\a 0 0))
(test "ascii 88" #f (ascii-lower-case-value #\a 0 -1))
(test "ascii 89" 9001 (ascii-lower-case-value #\b 9000 2))

(test "ascii 90" #f (ascii-nth-digit -1))
(test "ascii 91" #\0 (ascii-nth-digit 0))
(test "ascii 92" #\9 (ascii-nth-digit 9))
(test "ascii 93" #f (ascii-nth-digit 10))

(test "ascii 94" #\Z (ascii-nth-upper-case -1))
(test "ascii 95" #\A (ascii-nth-upper-case 0))
(test "ascii 96" #\Z (ascii-nth-upper-case 25))
(test "ascii 97" #\A (ascii-nth-upper-case 26))

(test "ascii 98" #\z (ascii-nth-lower-case -1))
(test "ascii 99" #\a (ascii-nth-lower-case 0))
(test "ascii 100" #\z (ascii-nth-lower-case 25))
(test "ascii 101" #\a (ascii-nth-lower-case 26))

(define (count-matching predicates value)
  (let loop ((ps predicates) (n 0))
    (if (null? ps) n (loop (cdr ps) (if ((car ps) value) (+ n 1) n)))))

(define (union? whole . parts)
  (let check ((cc 0))
    (or (= cc #x80)
        (if (and (whole cc) (not (= 1 (count-matching parts cc))))
            #f (check (+ cc 1))))))

(define (subset? small-set . bigger-sets)
  (let check ((cc 0))
    (or (= cc #x80)
        (if (and (small-set cc) (= 0 (count-matching bigger-sets cc)))
            #f (check (+ cc 1))))))

(define (disjoint? . predicates)
  (let check ((cc 0))
    (or (= cc #x80) (and (<= (count-matching predicates cc) 1)
                         (check (+ cc 1))))))

(test "ascii 102" #t (union? ascii-alphanumeric? ascii-alphabetic? ascii-numeric?))
(test "ascii 103" #t (union? ascii-alphabetic? ascii-upper-case? ascii-lower-case?))

(test "ascii 104" #t (subset? ascii-space-or-tab? ascii-whitespace?))
(test "ascii 105" #t (subset? ascii-other-graphic? ascii-non-control?))
(test "ascii 106" #t (subset? ascii-upper-case?   ascii-alphabetic? ascii-non-control?))
(test "ascii 107" #t (subset? ascii-lower-case?   ascii-alphabetic? ascii-non-control?))
(test "ascii 108" #t (subset? ascii-alphabetic?   ascii-alphanumeric? ascii-non-control?))
(test "ascii 109" #t (subset? ascii-numeric?      ascii-alphanumeric? ascii-non-control?))
(test "ascii 110" #t (subset? ascii-alphanumeric? ascii-non-control?))

(test "ascii 111" #t (disjoint? ascii-control? ascii-non-control?))
(test "ascii 112" #t (disjoint? ascii-whitespace?
                    ascii-other-graphic?
                    ascii-upper-case?
                    ascii-lower-case?
                    ascii-numeric?))
(test "ascii 113" #t (disjoint? ascii-control?
                    ascii-other-graphic?
                    ascii-upper-case?
                    ascii-lower-case?
                    ascii-numeric?))

(define (check-string-ci a b cmp)
  (test "ascii 114" (= cmp 0) (ascii-string-ci=? a b))
  (test "ascii 115" (< cmp 0) (ascii-string-ci<? a b))
  (test "ascii 116" (> cmp 0) (ascii-string-ci>? a b))
  (test "ascii 117" (<= cmp 0) (ascii-string-ci<=? a b))
  (test "ascii 118" (>= cmp 0) (ascii-string-ci>=? a b)))

(check-string-ci "" "" 0)
(check-string-ci "a" "a" 0)
(check-string-ci "A" "a" 0)
(check-string-ci "a" "A" 0)

(check-string-ci "a" "b" -1)
(check-string-ci "b" "a" 1)

(check-string-ci "a" "B" -1)
(check-string-ci "B" "a" 1)

(check-string-ci "aa" "aa" 0)
(check-string-ci "aa" "ab" -1)
(check-string-ci "ab" "aa" 1)
(check-string-ci "aa" "aaa" -1)
(check-string-ci "aaa" "aa" 1)


;; ----------------------------------------------------------------------
;;  SRFI 185 ...
;; ----------------------------------------------------------------------

(require "srfi-185")


(test "string-append! ok"  #t (eq? string-append! string-append-linear!))
(test "string-replace! ok" #t (eq? string-replace! string-replace-linear!))

;; srting-append! and string-replace! should now be macros, and they should
;; NOT expand to themselves!
(test "string-append! expansion"
      #f
      (equal? '(string-append! a b c)
              (macro-expand '(string-append! a b c))))

(test "string-replace! expansion"
      #f
      (equal? '(string-replace! dst dst-start dst-end src src-start src-end)
              (macro-expand '(string-replace! dst dst-start dst-end src src-start src-end))))

;; repeat part of SRFI-118 tests here, although nothing should go wrong --
;; the procedures being used here were already tested!
(set-mutable-string! au6  "ábcdÊf")
(test "(linear) string-append! char, unicode" "ábcdÊfঈ2345༫"
      (begin (string-append! au6 #\ঈ #\2 "345" #\༫) au6))
(set-mutable-string! au6  "ábcdÊf")
(test "(linear) string-append! char, unicode, length" 12
      (begin (string-append! au6 #\ঈ #\2 "345" #\༫) (string-length au6)))
;; FIXME: Delete this test
;; (set-mutable-string! au6  "ábcdÊf")
;; (test "(linear) string-append! char, unidoce, eq?" #t (eq? au6 (string-append! au6 #\ঈ #\2 "345" #\༫)))

(set-mutable-string! a6 "abcdef")
(test "(linear) string-replace! overlap" "abefef" (begin (string-replace! a6 2 4 a6 4 6) a6))
(set-mutable-string! a6 "abcdef")
(test "(linear) string-replace! overlap length" 6  (begin (string-replace! a6 2 4 a6 4 6)
                                                          (string-length a6)))
;; FIXME: Delete this test
;; (set-mutable-string! a6 "abcdef")
;; (test "(linear) string-replace! overlap eq?" #t  (eq? a6 (string-replace! a6 2 4 a6 4 6)))


;; ----------------------------------------------------------------------
;;  SRFI 180 ...
;;
;; The tests here are a small part of the tests from the sample
;; implementation.
;;
;; Other tests (only for json-read and json-write) are also available
;; in the file "./test-json.stk".
;; ----------------------------------------------------------------------
(test-subsection "SRFI 180 - JSON")

(require "srfi-180")

(test "json-generator.1"
      '(42)
      (call-with-input-string "42 101 1337"
                              (lambda (port) (generator->list (json-generator port)))))
(test "json-generator.2"
      '(array-start 42 array-end)
      (call-with-input-string "[42] 101 1337"
                              (lambda (port) (generator->list (json-generator port)))))
(test "json-error"
      #t
      (with-handler (lambda (e) (json-error? e))
                    (call-with-input-string "{" json-read)))

;; ----------------------------------------------------------------------
;;  SRFI 189 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 189 - Maybe and Either: optional container types")

(require "srfi-189")

(define (identity x) x)


(define-syntax constantly
  (syntax-rules ()
    ((_ obj) (lambda _ obj))))

(define-syntax values->list
  (syntax-rules ()
    ((_ expr)
     (call-with-values (lambda () expr) list))))

(define always (constantly #t))
(define never (constantly #f))


;; Verify that a Maybe is a Just of 'z, a dummy object.
(define (just-of-z? m)
  (and (maybe? m) (maybe= eqv? m (just 'z))))

;; Verify that an Either is a Right of 'z, a dummy object.
(define (right-of-z? e)
  (and (either? e) (either= eqv? e (right 'z))))

;; Verify that an Either is a Left of 'z, a dummy object.
(define (left-of-z? e)
  (and (either? e) (either= eqv? e (left 'z))))

;; CONSTRUCTORS

;; Uniqueness of the Nothing object.
(test "eq? nothing" #t (eq? (nothing) (nothing)))

;; list->just and list->right
(test "list->just and list->right 1" #t (maybe= eqv? (just #t #t) (list->just '(#t #t))))
(test "list->just and list->right 2" #t (either= eqv? (right #t #t) (list->right '(#t #t))))
(test "list->just and list->right 3" #t (either= eqv? (left #t #t) (list->left '(#t #t))))

;; maybe->either and either->maybe
(test "maybe->either and either->maybe 1" #t (left-of-z? (maybe->either (nothing) 'z)))
(test "maybe->either and either->maybe 2" #t (right-of-z? (maybe->either (just 'z) #f)))
(test "maybe->either and either->maybe 3" #t (either= eqv? (right #t #t) (maybe->either (just #t #t) #f)))
(test "maybe->either and either->maybe 4" #t (nothing? (either->maybe (left #t))))
(test "maybe->either and either->maybe 5" #t (just-of-z? (either->maybe (right 'z))))
(test "maybe->either and either->maybe 6" #t (maybe= eqv? (just #t #t) (either->maybe (right #t #t))))

;; either-swap
(test "either-swap 1" #t (either= eqv? (right #t #t) (either-swap (left #t #t))))
(test "either-swap 2" #t (either= eqv? (left #t #t) (either-swap (right #t #t))))

;;;; Predicates

(test "predicates 1" #t (just? (just 'z)))
(test "predicates 2" #f (just? (nothing)))
(test "predicates 3" #f (nothing? (just 'z)))
(test "predicates 4" #t (nothing? (nothing)))
(test "predicates 5" #t (maybe? (just 'z)))
(test "predicates 6" #t (maybe? (nothing)))

(test "predicates 7" #t (right? (right 'z)))
(test "predicates 8" #f (right? (left 'z)))
(test "predicates 9" #f (left? (right 'z)))
(test "predicates 10" #t (left? (left 'z)))
(test "predicates 11" #t (either? (right 'z)))
(test "predicates 12" #t (either? (left 'z)))

(test "predicates 13" #t (maybe= eqv? (just #t) (just #t)))
(test "predicates 14" #f (maybe= eqv? (just #t) (just #f)))
(test "predicates 15" #t (maybe= eqv? (nothing) (nothing)))
(test "predicates 16" #f (maybe= eqv? (just #t) (nothing)))

(test "predicates 17" #t (maybe= eqv? (just #t #f) (just #t #f)))
(test "predicates 18" #f (maybe= eqv? (just #t #f) (just #t 'z)))
(test "predicates 19" #f (maybe= eqv? (just #t #f) (just #t)))

(test "predicates 20" #t (maybe= eqv? (just #t) (just #t) (just #t)))
(test "predicates 21" #t (maybe= eqv? (nothing) (nothing) (nothing)))
(test "predicates 22" #f (maybe= eqv? (just #t) (just #t) (nothing)))
(test "predicates 23" #f (maybe= eqv? (just #t) (just #t) (just #f)))
(test "predicates 24" #t (maybe= eqv? (just #t 'z) (just #t 'z) (just #t 'z)))

(test "predicates 25" #t (either= eqv? (right #t) (right #t)))
(test "predicates 26" #f (either= eqv? (right #t) (right #f)))
(test "predicates 27" #t (either= eqv? (left #t) (left #t)))
(test "predicates 28" #f (either= eqv? (left #t) (left #f)))
(test "predicates 29" #f (either= eqv? (right #t) (left #t)))

(test "predicates 30" #t (either= eqv? (right #t #f) (right #t #f)))
(test "predicates 31" #f (either= eqv? (right #t #f) (right #t 'z)))
(test "predicates 32" #f (either= eqv? (right #t #f) (right #t)))
(test "predicates 33" #t (either= eqv? (left #t #f) (left #t #f)))
(test "predicates 34" #f (either= eqv? (left #t #f) (left #t 'z)))
(test "predicates 35" #f (either= eqv? (left #t #f) (left #t)))
(test "predicates 36" #f (either= eqv? (left #t #f) (right #t #f)))

(test "predicates 37" #t (either= eqv? (right #t) (right #t) (right #t)))
(test "predicates 38" #t (either= eqv? (left #t) (left #t) (left #t)))
(test "predicates 39" #f (either= eqv? (right #t) (right #t) (left #t)))
(test "predicates 40" #f (either= eqv? (right #t) (right #t) (right #f)))
(test "predicates 41" #t (either= eqv? (right #t 'z) (right #t 'z) (right #t 'z)))

;;;; Accessors

(test "accessors 1" #f (maybe-ref (nothing) (lambda () #f)))
(test "accessors 2" #t (maybe-ref (just #t) (lambda () #f) values))
(test "accessors 3" #f (maybe-ref (nothing) (lambda () #f) values))

(test "accessors 4" '(#t #f) (values->list (maybe-ref (just #t #f) (lambda () #f))))
(test "accessors 5" '(#t #f) (maybe-ref (just #t #f) (lambda () #f) list))

(test "accessors 6" #f (either-ref (left #t) (constantly #f)))
(test "accessors 7" #t (either-ref (right #t) (constantly #f) values))
(test "accessors 8" #t (either-ref (left #t) values (constantly #f)))

(test "accessors 9" '(#t #f) (either-ref (right #t #f) (constantly #f) list))
(test "accessors 10" '(#t #f) (either-ref (left #t #f) list (constantly #f)))

(test "accessors 11" #t (maybe-ref/default (just #t) #f))
(test "accessors 12" #f (maybe-ref/default (nothing) #f))
(test "accessors 13" '(#t #t) (values->list (maybe-ref/default (just #t #t) #f #f)))
(test "accessors 14" '(#f #f) (values->list (maybe-ref/default (nothing) #f #f)))

(test "accessors 15" #t (either-ref/default (right #t) #f))
(test "accessors 16" #f (either-ref/default (left #t) #f))
(test "accessors 17" '(#t #t) (values->list (either-ref/default (right #t #t) #f #f)))
(test "accessors 18" '(#f #f) (values->list (either-ref/default (left #t) #f #f)))

;;;; Join and bind

  ;; maybe-join
(test "maybe-join 1" #t (just-of-z? (maybe-join (just (just 'z)))))
(test "maybe-join 2" #t (nothing? (maybe-join (just (nothing)))))
(test "maybe-join 3" #t (nothing? (maybe-join (nothing))))

  ;; either-join
(test "either-join 1" #t (right-of-z? (either-join (right (right 'z)))))
(test "either-join 2" #t (left-of-z? (either-join (right (left 'z)))))
(test "either-join 3" #t (left-of-z? (either-join (left 'z))))

;; maybe-bind
(test "maybe-bind 1" #t (nothing? (maybe-bind (nothing) just)))

(test "maybe-bind 2" #t (just-of-z? (maybe-bind (just 'z) just)))

(test "maybe-bind 3" #t (let ((m (just #t #f)))
           (maybe= eqv? m (maybe-bind m just))))


;; Associativity of bind.
(let ((k (lambda (n) (just (* n 2))))
      (h (lambda (n) (just (+ n 5))))
      (m (just 1)))
  (test "Associativity of bind" #t (maybe= eqv?
                      (maybe-bind m (lambda (n) (maybe-bind (k n) h)))
                      (maybe-bind (maybe-bind m k) h))))


;; Bind with multiple mprocs.
(let ((neg (lambda (b) (just (not b)))))
  (test "Bind with multiple mprocs 1" #t (maybe= eqv? (just #f) (maybe-bind (just #t) neg neg neg)))
  (test "Bind with multiple mprocs 2" #t (nothing? (maybe-bind (just #t) neg (constantly (nothing)) neg))))

;; maybe-compose
(test "maybe-compose 1" #t (nothing? ((maybe-compose (constantly (nothing))) 'z)))
(test "maybe-compose 2" #t (just-of-z? ((maybe-compose just) 'z)))

;; Compose with multiple mprocs.
(let ((neg (lambda (b) (just (not b)))))
  (test "Compose with multiple mprocs" #t (maybe= eqv? (just #t) ((maybe-compose neg neg neg) #f))))

;; either-bind
(test "either-bind 1" #t (left? (either-bind (left #f) right)))

(test "either-bind 2" #t (right-of-z? (either-bind (right 'z) right)))

(test "either-bind 3" #t (let ((e (right #t #f)))
              (either= eqv? e (either-bind e right))))

;; Associativity of bind.
(let ((k (lambda (n) (right (* n 2))))
      (h (lambda (n) (right (+ n 5))))
      (e (right 1)))
  (test "Associativity of bind 2" #t
     (either= eqv? (either-bind e (lambda (n) (either-bind (k n) h)))
                   (either-bind (either-bind e k) h))))

;; Bind with multiple mprocs.
(let ((neg (lambda (b) (right (not b)))))
  (test "Bind with multiple mprocs 3" #t (either= eqv? (right #f) (either-bind (right #t) neg neg neg)))
  (test "Bind with multiple mprocs 4" #t (either= eqv? (left #f) (either-bind (right #t) neg left neg))))

;; either-compose
(test "either-compose" #t (left-of-z? ((either-compose left) 'z)))
(test "either-compose 2" #t (either= eqv? (right #t) ((either-compose right) #t)))

;; Compose with multiple mprocs.
(let ((neg (lambda (b) (right (not b)))))
  (test "Compose with multiple mprocs" #t (either= eqv? (right #t) ((either-compose neg neg neg) #f))))


;;;; Sequence operations

(define (both b c) (and b c))

(test "maybe-length 0" 0 (maybe-length (nothing)))
(test "maybe-length 1" 1 (maybe-length (just #t)))

(test "either-length 0" 0 (either-length (left #t)))
(test "either-length 1" 1 (either-length (right #t)))

;; maybe-filter & maybe-remove
(test "maybe-filter & maybe-remove 1" #t (just-of-z? (maybe-filter always (just 'z))))
(test "maybe-filter & maybe-remove 2" #t (nothing? (maybe-filter never (just #t))))
(test "maybe-filter & maybe-remove 3" #t (nothing? (maybe-filter always (nothing))))

(test "maybe-filter & maybe-remove 4" #t (maybe= eqv? (just #t #t) (maybe-filter both (just #t #t))))

(test "maybe-filter & maybe-remove 5" #t (just-of-z? (maybe-remove never (just 'z))))
(test "maybe-filter & maybe-remove 6" #t (nothing? (maybe-remove always (just #t))))
(test "maybe-filter & maybe-remove 7" #t (nothing? (maybe-remove always (nothing))))

(test "maybe-filter & maybe-remove 8" #t (maybe= eqv? (just #t #f) (maybe-remove both (just #t #f))))

;; maybe-sequence
(test "maybe-sequence" #t
      (maybe= equal? (maybe-sequence (map just '(#t #f)) map identity)
              (just '(#t #f))))

(test "maybe-sequence 2" #t
      (maybe= equal? (maybe-sequence (list (just 1 #t) (just 2 #f))
                                     map
                                     list)
              (just '((1 #t) (2 #f)))))

(test "maybe-sequence 3" #t
      (nothing? (maybe-sequence (list (just #t) (nothing)) map identity)))

;; either-filter & either-remove
(test "either-filter & either-remove" #t (right-of-z? (either-filter always (right 'z) #f)))
(test "either-filter & either-remove 2" #t (left-of-z? (either-filter never (right #t) 'z)))
(test "either-filter & either-remove 3" #t (left-of-z? (either-filter always (left #t) 'z)))

(test "either-filter & either-remove 4" #t
      (either= eqv? (right #t #t) (either-filter both (right #t #t) #f)))

(test "either-filter & either-remove 5" #t (right-of-z? (either-remove never (right 'z) #f)))
(test "either-filter & either-remove 6" #t (left-of-z? (either-remove always (right #t) 'z)))
(test "either-filter & either-remove 7" #t (left-of-z? (either-remove never (left #t) 'z)))

(test "either-filter & either-remove 8"  #t
      (either= eqv? (right #t #f) (either-remove both (right #t #f) #f)))

;; either-sequence
(test "either-sequence 1" #t
      (either= equal? (either-sequence (map right (list 1 2)) map identity)
               (right (list 1 2))))
(test "either-sequence 2" #t
      (left-of-z? (either-sequence (list (right #t) (left 'z)) map identity)))
(test "either-sequence 3" #t
      (either= equal? (either-sequence (list (right 1 #t) (right 2 #f))
                                       map
                                       list)
               (right '((1 #t) (2 #f)))))


;;;; Protocol conversion procedures

(test "maybe->list (nothing)" '() (maybe->list (nothing)))
(test "conversion 2" '(#t #t) (maybe->list (just #t #t)))
(test "conversion 3" '(#t #t) (either->list (right #t #t)))
(test "conversion 4" '(#t #t) (either->list (left #t #t)))

(test "conversion 5" #t (nothing? (list->maybe '())))
(test "conversion 6" #t (just-of-z? (list->maybe '(z))))
(test "conversion 7" #t (left-of-z? (list->either '() 'z)))
(test "conversion 8" #t (right-of-z? (list->either '(z) #f)))

(test "conversion 9" #f (maybe->truth (nothing)))
(test "maybe->truth, just" 'z (maybe->truth (just 'z)))
(test "conversion 11" #f (either->truth (left 'z)))
(test "maybe->truth, right" 'z (either->truth (right 'z)))

(test "conversion 13" #t (nothing? (truth->maybe #f)))
(test "conversion 14" #t (just-of-z? (truth->maybe 'z)))
(test "conversion 15" #t (left-of-z? (truth->either #f 'z)))
(test "conversion 16" #t (right-of-z? (truth->either 'z #f)))

(test "conversion 17" '(z #t) (maybe->list-truth (just 'z #t)))
(test "conversion 18" #f (maybe->list-truth (nothing)))
(test "conversion 19" '(z #t) (either->list-truth (right 'z #t)))
(test "conversion 20" #f (either->list-truth (left 'z)))

(test "conversion 21" #t (just-of-z? (list-truth->maybe '(z))))
(test "conversion 22" #t (nothing? (list-truth->maybe #f)))
(test "conversion 23" #t (right-of-z? (list-truth->either '(z))))
(test "conversion 24" #t (left-of-z? (list-truth->either #f 'z)))

(test "conversion 25" #t (eof-object? (maybe->generation (nothing))))
(test "conversion 26" #t (maybe->generation (just #t)))
(test "conversion 27" #t (nothing? (generation->maybe (eof-object))))
(test "conversion 28" #t (just-of-z? (generation->maybe 'z)))

(test "conversion 29" #t (eof-object? (either->generation (left))))
(test "conversion 30" #t (either->generation (right #t)))
(test "conversion 31" #t (left-of-z? (generation->either (eof-object) 'z)))
(test "conversion 32" #t (right-of-z? (generation->either 'z #f)))

;; maybe->values and friends
(test "maybe->values and friends 1" #t (maybe->values (just #t)))
(test "maybe->values and friends 2" '() (values->list (maybe->values (nothing))))

(test "maybe->values and friends 3" '(#f #f) (values->list (maybe->two-values (nothing))))
(test "maybe->values and friends 4" '(#t #t) (values->list (maybe->two-values (just #t))))

(test "maybe->values and friends 5" #t (just-of-z? (two-values->maybe (lambda () (values 'z #t)))))
(test "maybe->values and friends 6" #t (nothing? (two-values->maybe (lambda () (values 'z #f)))))

(test "maybe->values and friends 7" #t (nothing? (values->maybe (lambda () (values)))))
(test "maybe->values and friends 8" #t (just-of-z? (values->maybe (lambda () 'z))))
(test "maybe->values and friends 9" #t (maybe->values (values->maybe (lambda () #t))))
(test "maybe->values and friends 10" #t (just-of-z? (values->maybe (lambda ()
                                         (maybe->values (just 'z))))))

;; either->values and friends
(test "either->values and friends 1" #t (either->values (right #t)))
(test "either->values and friends 2" '() (values->list (either->values (left 'z))))

(test "either->values and friends 3" #t (left-of-z? (values->either (lambda () (values)) 'z)))
(test "either->values and friends 4" #t (right-of-z? (values->either (lambda () 'z) #f)))
(test "either->values and friends 5" #t (either->values (values->either (lambda () #t) #f)))
(test "either->values and friends 6" #t (right-of-z? (values->either (lambda () (either->values (right 'z))) #f)))

(test "either->values and friends 7" #t (left-of-z? (exception->either symbol? (lambda () (raise 'z)))))
(test "either->values and friends 8" #t (right-of-z? (exception->either symbol? (lambda () 'z))))

(test "guarded" 'z (guard (obj ((symbol? obj) obj))
                     (exception->either number?
                                        (lambda () (raise-continuable 'z)))))

(test "exception->either" #t (either= eqv?
                                      (with-exception-handler
                                          not
                                        (lambda ()
                                          (exception->either string?
                                                             (lambda ()
                                                               (not (raise-continuable #t))))))
                                      (right #t)))


;;;; Map, fold, and unfold

  ;; maybe-map
(test "Map, fold, and unfold 1" #t (nothing? (maybe-map not (nothing))))
(test "Map, fold, and unfold 2" #t (maybe= eqv? (just #f) (maybe-map not (just #t))))

(test "Map, fold, and unfold 3" #t (maybe= eqv? (just #t #f) (maybe-map values (just #t #f))))

;; either-map
  ;; Verify that the result is the same Left (in the sense of eqv?).
(test "Map, fold, and unfold 4" #t (let ((e (left #t))) (eqv? e (either-map not e))))
(test "Map, fold, and unfold 5" #t (either= eqv? (right #f) (either-map not (right #t))))

(test "Map, fold, and unfold 6" #t (let ((e (right #t #f)))
              (either= eqv? e (either-map values e))))

;; maybe-for-each
(test "maybe-for-each 1" #t (let ((x #f))
              (maybe-for-each (lambda (y) (set! x y)) (just #t))
              x))

;; Given Nothing, ensure the proc argument is not executed.
(test "maybe-for-each 2" #f
      (let ((x #f))
        (maybe-for-each (lambda (_) (set! x #t)) (nothing))
        x))

;; either-for-each
(test "either-for-each" #t (let ((x #f))
              (either-for-each (lambda (y) (set! x y)) (right #t))
              x))

;; Given a Left, ensure the proc argument is not executed.
(test "Map, fold, and unfold 10" #f (let ((x #f))
              (either-for-each (lambda (_) (set! x #t)) (left 'z))
              x))

(test "Map, fold, and unfold 11" '() (maybe-fold cons '() (nothing)))
(test "Map, fold, and unfold 12" '(#t) (maybe-fold cons '() (just #t)))
(test "Map, fold, and unfold 13" 24 (maybe-fold * 2 (just 3 4)))

(test "Map, fold, and unfold 14" '() (either-fold cons '() (left #t)))
(test "Map, fold, and unfold 15" '(#t) (either-fold cons '() (right #t)))
(test "Map, fold, and unfold 16" 24 (either-fold * 2 (right 3 4)))

(test "Map, fold, and unfold 17" #t (nothing? (maybe-unfold always not always #f)))
(test "Map, fold, and unfold 18" #t (maybe= eqv? (just #t) (maybe-unfold values not not #f)))
(test "Map, fold, and unfold 19" #t (maybe= eqv? (just #t 'z)
                         (maybe-unfold (lambda (b _) (not b))
                                       values
                                       (lambda (b x) (values (not b) x))
                                       #t
                                       'z)))

(test "Map, fold, and unfold 20" #t (left-of-z? (either-unfold always not always 'z)))
(test "Map, fold, and unfold 21" #t (either= eqv? (right #t) (either-unfold values not not #f)))
(test "Map, fold, and unfold 22" #t (either= eqv? (right #t 'z)
                       (either-unfold (lambda (b _) (not b))
                                      values
                                      (lambda (b x) (values (not b) x))
                                      #t
                                      'z)))





;;;; Trivalent logic

(define (tri-true? m)
  (and (just? m) (maybe-ref/default m 'z)))

(define (tri-false? m)
  (and (just? m) (not (maybe-ref/default m 'z))))

(test "trivalent 1" #t (tri-true? (tri-not (just #f))))
(test "trivalent 2" #t (tri-false? (tri-not (just #t))))
(test "trivalent 3" #t (nothing? (tri-not (nothing))))

(test "trivalent 4" #t (tri-true? (tri=? (just #t) (just 1) (just 'x))))
(test "trivalent 5" #t (tri-true? (tri=? (just #f) (just #f))))
(test "trivalent 6" #t (tri-true? (tri=? (just #f) (just #f))))
(test "trivalent 7" #t (tri-false? (tri=? (just #f) (just #t))))
(test "trivalent 8" #t (tri-false? (tri=? (just #f) (nothing))))

(test "trivalent 9" #t (tri-true? (tri-and (just #t) (just 1) (just 'x))))
(test "trivalent 10" #t (nothing? (tri-and (just #t) (nothing))))
(test "trivalent 11" #t (tri-false? (tri-and (just #f) (just #t))))
(test "trivalent 12" #t (tri-true? (tri-and)))

(test "trivalent 13" #t (tri-false? (tri-or (just #f) (just #f) (just #f))))
(test "trivalent 14" #t (nothing? (tri-or (just #f) (nothing))))
(let ((m-true (just 'x)))
  (test "trivalent 15" #t (maybe= eqv? m-true (tri-or (just #f) m-true))))
(test "trivalent 16" #t (tri-false? (tri-or)))

(test "trivalent 17" #t (nothing? (tri-merge (nothing) (nothing) (nothing))))
(let ((m-true (just 'x)))
  (test "trivalent 18" #t (maybe= eqv? m-true (tri-merge (nothing) m-true))))
(let ((m-false (just #f)))
  (test "trivalent 19" #t (maybe= eqv? m-false (tri-merge (nothing) m-false))))
(test "trivalent 20" #t (nothing? (tri-merge)))

;; ----------------------------------------------------------------------
;;  SRFI 190 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 190 - Coroutine Generators")

(require "srfi-190")

(let ()
  (define g1 (coroutine-generator
           (do ((i 0 (+ i 1)))
               ((<= 5 i))
             (yield i))))

  (define g2 (let ((yield-square (lambda (yield i) (yield (* i i)))))
               (coroutine-generator
                (do ((i 0 (+ i 1)))
                    ((<= 5 i))
                  (yield-square yield i)))))

  (define-coroutine-generator (g3 n)
    (do ((i 0 (+ i 1)))
        ((<= n i))
      (yield i)))

  (test "Coroutine generator.1" '(0 1 2 3 4)
        (generator->list g1))
  (test "Coroutine generator.2" '(0 1 4 9 16)
        (generator->list g2))
  (test "Coroutine generator.3" '(0 1 2 3 4 5 6)
        (generator->list (g3 7))))

;; ----------------------------------------------------------------------
;;  SRFI 193 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI-193 - Command Line")

(let ((val (command-line)))
  (test "command-line validate" #t
        (and (list? val)
               (not (null? val))
               (or (boolean? (car val))
                   (string? (car val)))
               (every string? (cdr val))))
  (test "command-args"
        #t
        (eq? (cdr val)
             (command-args))))

(parameterize ((command-line '("" "1" "2")))
  (test "new command line.1"
        #t
        (let ((val (command-line)))
          (and (not (command-name))
               (equal? '("1" "2")
                       (command-args))))))

(parameterize ((command-line '("../../foo.stk" "1" "2" "3")))
  (test "new command line.2 (suffix must be supressed)"
        #t
        (let ((val (command-line)))
          (and (string=? (command-name) "foo")
               (equal? '("1" "2" "3")
                       (command-args))))))

(parameterize ((command-line '("../../foo.keep" "1" "2" "3")))
  (test "new command line.3 (suddix must be kept)"
        #t
        (let ((val (command-line)))
          (and (string=? (command-name) "foo.keep")
               (equal? '("1" "2" "3")
                       (command-args))))))

;; ----------------------------------------------------------------------
;;  SRFI 195 ...
;; ----------------------------------------------------------------------
;; Tests are in the file test-box.stk

;; ----------------------------------------------------------------------
;;  SRFI 196 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI-196 - Range objects")

(require "srfi-196")

(define *tests-failed* 0)

(define-syntax check
  (syntax-rules (=>)
    ((check expr => expected)
     (test "" expected expr))))

(define (identity x) x)

;; change print-header to make tests silent
;; -- jpellegrini
(define (print-header message) (void))
  ;; (newline)
  ;; (display ";;; ")
  ;; (display message)
  ;; (newline))

(define-syntax constantly
  (syntax-rules ()
    ((_ obj) (lambda _ obj))))

(define always (constantly #t))
(define never (constantly #f))

(define (range=/eqv? ra rb)
  (range=? eqv? ra rb))

(define (%range-empty? r) (zero? (range-length r)))

;;;; Test ranges

(define test-num-range (numeric-range 10 30))

(define test-num-seq (iota 20 10))

(define test-empty-range (numeric-range 0 0))

;; Produces the range {#f, #t}.
(define test-bool-range
  (range 2 (lambda (n) (not (zero? n)))))

;;;; Conversion

(define (check-conversion)
  (print-header "Running conversion tests...")

  (check (range->list test-empty-range) => '())
  (check (range->list test-bool-range)  => '(#f #t))
  (check (range->list test-num-range)   => test-num-seq)

  (check (generator->list (range->generator test-num-range))
   => test-num-seq)

  (check (vector->list (range->vector test-num-range)) => test-num-seq)

  (check (range->string test-empty-range) => "")
  (let ((s "0123456789"))
    (check (range->string (string-range s)) => s))

  (let* ((vec (vector 1 3 5 7 9))
         (vrange (vector->range vec)))
    (check (range-length vrange)  => (vector-length vec))
    (check (range-first vrange)   => (vector-ref vec 0))
    (check (range-last vrange)    => (vector-ref vec 4))
    (check (range->vector vrange) => vec)
    (check (range->list (begin (vector-set! vec 0 0) vrange))
     => '(1 3 5 7 9)))
)

(define (check-constructors)
  (print-header "Running constructor tests...")

  (check (%range-empty? (numeric-range 1 1))      => #t)
  (check (range->list (numeric-range -5 -1))      => (iota 4 -5))
  (check (range->list (numeric-range 1 -5 -1))    => (iota 6 1 -1))
  (check (range->list (numeric-range 4/3 16/3))   => (iota 4 4/3))
  (check (range->list (numeric-range 0 9 4))      => (iota 3 0 4))
  (check (%range-empty? (numeric-range 0 10 -1))  => #t)
  (check (%range-empty? (numeric-range 0 -10))    => #t)
  (check (range->list (numeric-range 5 1 -1))     => (iota 4 5 -1))
  (check (range->list (numeric-range -2 2))       => (iota 4 -2))
  (check (range->list (numeric-range 2 -2 -1))    => (iota 4 2 -1))
  (check (range->list (numeric-range -4 -8 -1))   => (iota 4 -4 -1))
  (check (range->list (numeric-range -1 -4 -2/3)) => (iota 5 -1 -2/3))

  (check (range=/eqv? (iota-range 10 0 0)
                      (range 10 (lambda (_) 0)))
   => #t)
  (check (%range-empty? (iota-range 0))     => #t)
  (check (range->list (iota-range 10))      => (iota 10))
  (check (range->list (iota-range 10 0))    => (iota 10))
  (check (range->list (iota-range 10 0 1))  => (iota 10))
  (check (range->list (iota-range 10 10 2)) => (iota 10 10 2))
  (check (range->list (iota-range 10 0 -1)) => (iota 10 0 -1))
  (check (range->list (iota-range 10 5 -2)) => (iota 10 5 -2))
  (check (range->list (iota-range 10 1/2))  => (iota 10 1/2))

  (let ((vec (vector 1 3 5 7 9)))
    (check (range-length (vector-range vec))  => (vector-length vec))
    (check (range-first (vector-range vec))   => (vector-ref vec 0))
    (check (range-last (vector-range vec))    => (vector-ref vec 4))
    (check (range->vector (vector-range vec)) => vec))

  (let* ((s "0123456789") (srange (string-range s)))
    (check (range-length srange) => (string-length s))
    (check (range-first srange)  => (string-ref s 0))
    (check (range-last srange)   => (string-ref s 9))
    (check (range->list srange)  => (string->list s)))
)

;;;; Predicates

(define (check-predicates)
  (print-header "Running predicate tests...")

  (check (range=? eqv? (numeric-range 0 0) (numeric-range 5 5))  => #t)
  (check (range=? eqv? (numeric-range 0 0) test-num-range)       => #f)
  (check (range=? eqv? test-num-range test-num-range)            => #t)
  (check (range=? eqv? test-num-range (numeric-range 10 30))     => #t)
  (check (range=? eqv? test-num-range (numeric-range 10 20))     => #f)
  (check (range=? eqv? test-bool-range (vector-range #(#f #t))) => #t)
  (check (range=? eqv? test-bool-range (vector-range #(#t #f))) => #f)
  (check (range=? eqv?
                  test-num-range
                  (numeric-range 10 30)
                  (subrange (numeric-range 0 50) 10 30))
   => #t)
  (check (range=? eqv?
                  test-bool-range
                  (numeric-range 10 30)
                  (subrange (numeric-range 0 50) 10 30))
   => #f)
  (check (range=? eqv?
                  test-num-range
                  (numeric-range 11 31)
                  (subrange (numeric-range 0 50) 10 30))
   => #f)
)

;;;; Accessors

(define (check-accessors)
  (print-header "Running accessor tests...")

  (check (range-ref test-num-range 0)  => 10)
  (check (range-ref test-bool-range 1) => #t)
)

;;;; Iteration

(define (check-iteration)
  (print-header "Running iteration tests...")

  ;; Check lengths of ranges returned by range-split-at.
  (let ((n 10))
    (check (let-values (((ra rb) (range-split-at test-num-range n)))
             (list (range-length ra) (range-length rb)))
     => (list n (- (range-length test-num-range) n))))

  ;; Joining the two ranges returned by range-split-at gives the
  ;; original range.
  (check (let-values (((ra rb) (range-split-at test-bool-range 1)))
           (range=/eqv? (range-append ra rb) test-bool-range))
   => #t)

  (check (range=/eqv?
          (subrange test-bool-range 0 (range-length test-bool-range))
          test-bool-range)
   => #t)
  (let ((a 5) (b 10))
    (check (= (range-length (subrange test-num-range a b)) (- b a))
     => #t)
    (check (range=/eqv? (subrange test-num-range a b)
                        (range-take (range-drop test-num-range a) (- b a)))
     => #t)
    (check (range=/eqv? (subrange test-num-range 0 b)
                        (range-take test-num-range b))
     => #t)
    (check (range=/eqv?
            (subrange test-num-range a (range-length test-num-range))
            (range-drop test-num-range a))
     => #t))

  ;; range-take r n returns a range of length n.
  (check (range-length (range-take test-num-range 10)) => 10)
  (check (range-length
          (range-take test-num-range (range-length test-num-range)))
   => (range-length test-num-range))
  (check (range->list (range-take test-num-range 5))
   => (take test-num-seq 5))

  ;; range-take-right r n returns a range of length n.
  (check (range-length (range-take-right test-num-range 10)) => 10)
  (check (range-length
          (range-take-right test-num-range (range-length test-num-range)))
   => (range-length test-num-range))
  (check (range->list (range-take-right test-num-range 5))
   => (drop test-num-seq 15))

  ;; range-drop r n returns a range of length (range-length r) - n.
  (check (range-length (range-drop test-num-range 10))
   => (- (range-length test-num-range) 10))
  (check (range-length
          (range-drop test-num-range (range-length test-num-range)))
   => 0)
  (check (range->list (range-drop test-num-range 15))
   => (drop test-num-seq 15))

  ;; range-drop-right r n returns a range of length (range-length r) - n.
  (check (range-length (range-drop-right test-num-range 10))
   => (- (range-length test-num-range) 10))
  (check (range-length
          (range-drop-right test-num-range (range-length test-num-range)))
   => 0)
  (check (range->list (range-drop-right test-num-range 15))
   => (take test-num-seq 5))

  (check (range=/eqv? (car (range-segment test-num-range 5))
                      (range-take test-num-range 5))
   => #t)
  (check (range=/eqv? (apply range-append
                             (cdr (range-segment test-num-range 5)))
                      (range-drop test-num-range 5))
   => #t)
  (check (range=/eqv? (apply range-append (range-segment test-num-range 5))
                      test-num-range)
   => #t)
  (check (fold + 0 (map range-length (range-segment test-num-range 5)))
   => (range-length test-num-range))
  (check (fold + 0 (map range-length (range-segment test-num-range 7)))
   => (range-length test-num-range))

  (check (range-count always test-num-range) => (range-length test-num-range))
  (check (range-count never test-num-range)  => 0)
  (check (range-count even? test-num-range)  => (count even? test-num-seq))
  (check (range-count (lambda (x y) y) test-num-range test-bool-range)
   => 1)
  (check (range-count (lambda (x y) (zero? (+ x y)))
                      test-num-range
                      (range-map - test-num-range))
   => (range-length test-num-range))

  (check (range-any even? test-num-range) => #t)
  (check (range-any never test-num-range) => #f)
  (check (range-any (lambda (x y) y) test-num-range test-bool-range)
   => #t)
  (check (range-any (lambda (x y) (zero? (+ x y)))
                    test-num-range
                    test-num-range)
   => #f)

  (check (range-every number? test-num-range) => #t)
  (check (range-every even? test-num-range)   => #f)
  (check (range-every (lambda (x y) y) test-num-range test-bool-range)
   => #f)
  (check (range-every (lambda (x y) (zero? (+ x y)))
                      test-num-range
                      (range-map - test-num-range))
   => #t)

  ;;; map, filter-map, & for-each

  (check (range=/eqv? (range-map (lambda (x) (+ 1 x)) test-num-range)
                      (numeric-range 11 31))
   => #t)
  (check (equal? (range->list (range-map square test-num-range))
                 (map square test-num-seq))
   => #t)
  (check (range=/eqv? (range-map + test-num-range test-num-range)
                      (numeric-range 20 60 2))
   => #t)
  ;; range-map over ranges with unequal lengths terminates when
  ;; the shortest range is exhausted.
  (check (range=/eqv?
          (range-map (lambda (x _) x) test-num-range test-bool-range)
          (range-take test-num-range (range-length test-bool-range)))
   => #t)

  ;; (range-map->list f r) = (map f (range->list r))
  (check (equal? (range-map->list not test-bool-range)
                 (map not (range->list test-bool-range)))
   => #t)
  (check (equal? (range-map->list + test-num-range test-num-range)
                 (map + test-num-seq test-num-seq))
   => #t)

  ;; (range-map->vector f r) = (map f (range->vector r))
  (check (equal? (range-map->vector not test-bool-range)
                 (vector-map not (range->vector test-bool-range)))
   => #t)
  (let ((num-vec (list->vector test-num-seq)))
    (check (equal? (range-map->vector + test-num-range test-num-range)
                   (vector-map + num-vec num-vec))
     => #t))

  (check (%range-empty? (range-filter-map never test-bool-range)) => #t)
  (check (range=/eqv? (range-filter-map values test-num-range)
                      test-num-range)
   => #t)
  (check (equal?
          (range->list (range-filter-map (lambda (x) (and (even? x) x))
                                         test-num-range))
          (filter-map (lambda (x) (and (even? x) x)) test-num-seq))
   => #t)
  (let ((proc (lambda (x y) (and (even? x) (even? y) (+ x y)))))
    (check (range=/eqv? (range-filter-map proc test-num-range test-num-range)
                        (numeric-range 20 60 4))
     => #t))

  (check (range-filter-map->list never test-bool-range) => '())
  (check (equal? (range-filter-map->list values test-num-range)
                 test-num-seq)
   => #t)
  (check (equal?
          (range-filter-map->list (lambda (x) (and (even? x) x))
                                  test-num-range)
          (filter-map (lambda (x) (and (even? x) x)) test-num-seq))
   => #t)
  (let ((proc (lambda (x y) (and (even? x) (even? y) (+ x y)))))
    (check (equal? (range-filter-map->list proc
                                           test-num-range
                                           test-num-range)
                   (filter-map proc test-num-seq test-num-seq))
     => #t))

  (check (let ((v #f))
           (range-for-each (lambda (x) (set! v x)) test-bool-range)
           v)
   => #t)
  (check (let ((v #f))
           (range-for-each (lambda (x y) (when y (set! v x)))
                           test-num-range
                           test-bool-range)
           v)
   => 11)

  ;;; filter & remove

  (check (range=/eqv? (range-filter always test-bool-range)
                      test-bool-range)
   => #t)
  (check (%range-empty? (range-filter never test-bool-range)) => #t)
  (check (equal? (range->list (range-filter even? test-num-range))
                 (filter even? test-num-seq))
   => #t)

  (check (range-filter->list always test-bool-range) => '(#f #t))

  (check (null? (range-filter->list never test-bool-range)) => #t)

  ;; (range-filter->list pred r) = (filter pred (range->list r))
  (check (equal? (range-filter->list even? test-num-range)
                 (filter even? test-num-seq))
   => #t)

  (check (range=/eqv? (range-remove never test-bool-range)
                      test-bool-range)
   => #t)
  (check (%range-empty? (range-remove always test-bool-range))
   => #t)
  (check (equal? (range->list (range-remove even? test-num-range))
                 (remove even? test-num-seq))
   => #t)

  (check (equal? (range-remove->list never test-bool-range)
                 (range->list test-bool-range))
   => #t)

  (check (null? (range-remove->list always test-bool-range)) => #t)

  ;; (range-remove->list pred r) = (remove pred (range->list r))
  (check (equal? (range-remove->list even? test-num-range)
                 (remove even? test-num-seq))
   => #t)

  ;; (range-fold (lambda (b) (+ 1 b)) 0 r) = (range-length r)
  (check (= (range-fold (lambda (b _) (+ b 1)) 0 test-num-range)
            (range-length test-num-range))
   => #t)

  ;; (range-fold proc nil r) = (fold proc nil (range->list r))
  (check (equal? (range-fold + 0 test-num-range)
                 (fold + 0 test-num-seq))
   => #t)

  (check (= (range-fold + 0 test-num-range test-num-range)
            (fold + 0 test-num-seq test-num-seq))
   => #t)

  ;; range-fold over ranges with unequal lengths terminates when
  ;; the shortest range is exhausted.
  (check (= (range-fold (lambda (s x _) (+ s x))
                        0
                        test-num-range
                        test-bool-range)
            (range-fold + 0 (range-take test-num-range
                                        (range-length test-bool-range))))
   => #t)

  ;; (range-fold-right (lambda (b) (+ 1 b)) 0 r) = (range-length r)
  (check (= (range-fold-right (lambda (b _) (+ b 1)) 0 test-num-range)
            (range-length test-num-range))
   => #t)

  ;; (range-fold-right r proc nil) = (fold-right proc nil (range->list r))
  (check (equal? (range-fold-right + 0 test-num-range)
                 (fold-right + 0 test-num-seq))
   => #t)

  (check (= (range-fold-right + 0 test-num-range test-num-range)
            (fold-right + 0 test-num-seq test-num-seq))
   => #t)

  ;; range-fold-right over ranges with unequal lengths terminates when
  ;; the shortest range is exhausted.
  (check (= (range-fold-right (lambda (s x _) (+ s x))
                              0
                              test-num-range
                              test-bool-range)
            (range-fold-right + 0 (range-take test-num-range
                                              (range-length
                                               test-bool-range))))
   => #t)

  (check (eqv? (range-first (range-reverse test-bool-range))
               (range-last test-bool-range))
   => #t)

  (check (eqv? (range-last (range-reverse test-bool-range))
               (range-first test-bool-range))
   => #t)

  (check (equal? (range->list (range-reverse test-num-range))
                 (reverse test-num-seq))
   => #t)

  (check (%range-empty? (range-append)) => #t)
  (check (range->list (range-append test-bool-range)) => '(#f #t))
  (check (range=/eqv? (range-append (numeric-range 10 20)
                                    (numeric-range 20 30))
                      test-num-range)
   => #t)
  (check (range=/eqv? (range-append (numeric-range 10 15)
                                    (numeric-range 15 20)
                                    (numeric-range 20 25)
                                    (numeric-range 25 30))
                      test-num-range)
   => #t)
)

;;;; Searching

(define (check-searching)
  (print-header "Running search tests...")

  (check (range-index always test-num-range) => 0)
  (check (range-index never test-num-range)  => #f)
  (check (range-index values test-bool-range) => 1)
  (check (range-index (lambda (x y) (and (odd? x) y))
                      test-num-range
                      test-bool-range)
   => 1)

  (check (eqv? (range-index-right always test-num-range)
               (- (range-length test-num-range) 1))
   => #t)
  (check (range-index-right never test-num-range)  => #f)
  (check (range-index-right values test-bool-range) => 1)
  (check (range-index-right (lambda (x y) (< (+ x y) 30))
                            test-num-range
                            test-num-range)
   => 4)

  ;; range-index and range-index-right produce the same index if pred
  ;; is only satisfied by the element at that index.
  (let ((fifteen? (lambda (n) (= n 15))))
    (check (= (range-index fifteen? test-num-range)
              (range-index-right fifteen? test-num-range)
              (list-index fifteen? test-num-seq))
     => #t))

  ;; (range-take-while always r) = r
  (check (range=/eqv? (range-take-while always test-bool-range)
                      test-bool-range)
   => #t)

  ;; (range-take-while never r) = [empty range]
  (check (%range-empty? (range-take-while never test-bool-range)) => #t)

  (let ((pred (lambda (n) (< n 15))))
    (check (range->list (range-take-while pred test-num-range))
     => (take-while pred test-num-seq)))

  ;; (range-drop-while always r) = [empty range]
  (check (%range-empty? (range-drop-while always test-bool-range)) => #t)

  ;; (range-drop-while never r) = r
  (check (range=/eqv? (range-drop-while never test-bool-range)
                      test-bool-range)
   => #t)

  (let ((pred (lambda (n) (< n 15))))
    (check (range->list (range-drop-while pred test-num-range))
     => (drop-while pred test-num-seq)))

  ;; (range-append (range-take-while p r) (range-drop-while p r)) = r
  (let ((pred (lambda (n) (< n 10))))
    (check (range=/eqv?
            (range-append (range-take-while pred test-num-range)
                          (range-drop-while pred test-num-range))
            test-num-range)
     => #t))

  ;; (range-take-while-right always r) = r
  (check (range=/eqv? (range-take-while-right always test-bool-range)
                      test-bool-range)
   => #t)

  ;; (range-take-while-right never r) = [empty range]
  (check (%range-empty? (range-take-while-right never test-bool-range)) => #t)

  (let ((pred (lambda (n) (>= n 15))))
    (check (range->list (range-take-while-right pred test-num-range))
     => (iota 15 15)))

  ;; (range-drop-while-right always r) = [empty range]
  (check (%range-empty? (range-drop-while-right always test-bool-range)) => #t)

  ;; (range-drop-while-right never r) = r
  (check (range=/eqv? (range-drop-while-right never test-bool-range)
                      test-bool-range)
   => #t)

  (let ((pred (lambda (n) (>= n 15))))
    (check (range->list (range-drop-while-right pred test-num-range))
     => (take test-num-seq 5)))

  ;; (range-append (range-drop-while-right p r)
  ;;               (range-take-while-right p r)) = r
  (let ((pred (lambda (n) (< n 10))))
    (check (range=/eqv?
            (range-append (range-drop-while-right pred test-num-range)
                          (range-take-while-right pred test-num-range))
            test-num-range)
     => #t))
)

(define (check-all)
  (check-predicates)
  (check-conversion)
  (check-constructors)
  (check-accessors)
  (check-iteration)
  (check-searching)

  ;;(newline)
  ;;(check-report)
  )

(check-all)


;; ----------------------------------------------------------------------
(test-section-end)
